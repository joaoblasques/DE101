# 04. Aggregate Functions

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Summarizing and analyzing data using COUNT, SUM, AVG, MIN, MAX, and DISTINCT

---

## 📋 Overview

Aggregate functions are the workhorses of data analysis in SQL. They take multiple rows of data and return a single summary value - perfect for answering questions like "How many customers do we have?", "What's our total revenue?", or "What's the average order value?"

Unlike regular functions that operate on individual values, aggregate functions operate on **sets of rows**, collapsing many rows into a single result. This is fundamental to analytics, reporting, and understanding your data at scale.

Understanding aggregate functions is essential because they form the foundation for GROUP BY queries (next subchapter), data validation, KPI tracking, and nearly every analytics dashboard you'll ever build.

**Real-World Applications:**
- Business metrics: total sales, average customer lifetime value, product inventory counts
- Data quality checks: counting NULLs, finding min/max dates to validate data freshness
- Performance monitoring: average query time, maximum concurrent users
- Financial reporting: sum of transactions, average account balance

---

## 🎯 Learning Objectives

After completing this subchapter, you will be able to:
- Use COUNT() to count rows, including handling NULL values correctly
- Calculate sums and averages with SUM() and AVG()
- Find minimum and maximum values with MIN() and MAX()
- Combine multiple aggregate functions in a single query
- Use DISTINCT with aggregate functions to count unique values
- Understand how NULL values affect aggregate functions
- Apply aggregate functions to solve real business problems
- Recognize when to use each aggregate function for different data types

---

## 📚 Core Concepts

### 1. COUNT() - Counting Rows

COUNT() is the most commonly used aggregate function. It counts rows or non-NULL values.

#### COUNT(*) - Count All Rows

```sql
-- How many customers do we have?
SELECT COUNT(*) AS total_customers
FROM customers;

-- Result: 15420 (counts ALL rows, including rows with NULLs)
```

**Key Point:** `COUNT(*)` counts **every row**, regardless of NULL values in any column.

#### COUNT(column) - Count Non-NULL Values

```sql
-- How many customers have an email address?
SELECT COUNT(email) AS customers_with_email
FROM customers;

-- Result: 14892 (only counts rows where email IS NOT NULL)
```

**Critical Difference:**
```sql
SELECT
    COUNT(*) AS total_rows,          -- All rows: 15420
    COUNT(email) AS with_email,      -- Non-NULL emails: 14892
    COUNT(phone) AS with_phone       -- Non-NULL phones: 13567
FROM customers;
```

#### COUNT(DISTINCT column) - Count Unique Values

```sql
-- How many different countries do our customers come from?
SELECT COUNT(DISTINCT country) AS unique_countries
FROM customers;

-- Result: 47 (counts unique non-NULL values only)
```

**Use Cases:**
- Counting unique users, products, categories
- Finding distinct values for categorical data
- Data profiling (how many unique values in this column?)

---

### 2. SUM() - Totaling Numeric Values

SUM() adds up all non-NULL numeric values in a column.

```sql
-- What's our total revenue?
SELECT SUM(total_amount) AS total_revenue
FROM orders;

-- Result: 15847293.45
```

#### With WHERE Clause

```sql
-- Total revenue from orders in October 2024
SELECT SUM(total_amount) AS october_revenue
FROM orders
WHERE order_date >= '2024-10-01'
  AND order_date < '2024-11-01';
```

#### NULL Handling

```sql
-- SUM ignores NULL values
SELECT SUM(discount_amount) AS total_discounts
FROM orders;
-- If 3 orders have discounts (10, 20, 30) and 2 have NULL:
-- Result: 60 (not affected by NULLs)
```

**Important:** SUM() returns NULL if **all** values are NULL, not 0.

```sql
-- All discounts are NULL
SELECT SUM(discount_amount) AS total_discounts
FROM orders
WHERE discount_amount IS NOT NULL;
-- Result: NULL (not 0!)

-- To get 0 instead of NULL, use COALESCE:
SELECT COALESCE(SUM(discount_amount), 0) AS total_discounts
FROM orders;
-- Result: 0
```

---

### 3. AVG() - Calculating Averages

AVG() calculates the arithmetic mean of non-NULL values.

```sql
-- What's the average order value?
SELECT AVG(total_amount) AS avg_order_value
FROM orders;

-- Result: 387.52
```

#### AVG vs SUM/COUNT

```sql
-- These are equivalent:
SELECT AVG(total_amount) FROM orders;
SELECT SUM(total_amount) / COUNT(total_amount) FROM orders;
```

**Key Insight:** AVG() divides by COUNT(column), not COUNT(*). This matters when NULLs are present.

```sql
-- Example with NULLs
-- 5 orders: [100, 200, 300, NULL, NULL]

SELECT
    AVG(total_amount) AS using_avg,           -- 200 (600/3)
    SUM(total_amount) / COUNT(*) AS manual    -- 120 (600/5)
FROM orders;
```

#### Rounding Averages

```sql
-- Round to 2 decimal places
SELECT ROUND(AVG(price), 2) AS avg_price
FROM products;

-- Result: 127.83 (instead of 127.8294736)
```

---

### 4. MIN() and MAX() - Finding Extremes

MIN() and MAX() find the smallest and largest values.

#### Numeric Values

```sql
-- Price range of products
SELECT
    MIN(price) AS lowest_price,
    MAX(price) AS highest_price
FROM products;

-- Result: lowest_price: 9.99, highest_price: 1299.99
```

#### Date Values

```sql
-- When was the first and most recent order?
SELECT
    MIN(order_date) AS first_order,
    MAX(order_date) AS most_recent_order
FROM orders;

-- Result: first_order: 2020-01-15, most_recent_order: 2024-10-21
```

#### Text Values (Alphabetical)

```sql
-- Alphabetically first and last customer names
SELECT
    MIN(customer_name) AS alphabetically_first,
    MAX(customer_name) AS alphabetically_last
FROM customers;

-- Result: first: "Aaron Smith", last: "Zoe Williams"
```

**Use Cases:**
- Data validation (is earliest date reasonable?)
- Range analysis (min/max prices, dates, ages)
- Outlier detection (combined with AVG)

---

### 5. Combining Multiple Aggregate Functions

You can use multiple aggregate functions in a single query.

```sql
-- Comprehensive order statistics
SELECT
    COUNT(*) AS total_orders,
    COUNT(DISTINCT customer_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value,
    MIN(total_amount) AS smallest_order,
    MAX(total_amount) AS largest_order,
    MIN(order_date) AS first_order_date,
    MAX(order_date) AS last_order_date
FROM orders;
```

**Result:**
```
total_orders: 40892
unique_customers: 15203
total_revenue: 15847293.45
avg_order_value: 387.52
smallest_order: 5.00
largest_order: 9847.99
first_order_date: 2020-01-15
last_order_date: 2024-10-21
```

---

### 6. DISTINCT with Aggregates

DISTINCT removes duplicates before aggregating.

#### COUNT(DISTINCT) - Already Covered

```sql
-- Unique customers who placed orders
SELECT COUNT(DISTINCT customer_id) AS unique_customers
FROM orders;
```

#### SUM(DISTINCT) - Less Common

```sql
-- Sum of unique prices (not useful in most cases)
SELECT SUM(DISTINCT price) AS sum_unique_prices
FROM order_items;

-- If prices are [10, 10, 20, 30]:
-- SUM(price) = 70
-- SUM(DISTINCT price) = 60 (10 + 20 + 30)
```

#### AVG(DISTINCT) - Rare Use Case

```sql
-- Average of unique values only
SELECT AVG(DISTINCT rating) AS avg_unique_ratings
FROM reviews;
```

**Practical Note:** COUNT(DISTINCT) is very common; SUM(DISTINCT) and AVG(DISTINCT) are rarely needed.

---

## 💡 Practical Examples

### Example 1: E-Commerce Dashboard Metrics

```sql
-- Key metrics for business dashboard
SELECT
    -- Orders
    COUNT(*) AS total_orders,
    COUNT(DISTINCT customer_id) AS unique_customers,

    -- Revenue
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value,

    -- Order size
    MIN(total_amount) AS min_order,
    MAX(total_amount) AS max_order,

    -- Time period
    MIN(order_date) AS period_start,
    MAX(order_date) AS period_end,

    -- Customer metrics
    ROUND(COUNT(*) * 1.0 / COUNT(DISTINCT customer_id), 2) AS orders_per_customer
FROM orders
WHERE order_date >= '2024-01-01'
  AND status = 'completed';
```

---

### Example 2: Product Inventory Analysis

```sql
-- Inventory health metrics
SELECT
    COUNT(*) AS total_products,
    COUNT(DISTINCT category) AS product_categories,

    -- Stock levels
    SUM(quantity_in_stock) AS total_units_in_stock,
    AVG(quantity_in_stock) AS avg_stock_per_product,
    MIN(quantity_in_stock) AS lowest_stock,
    MAX(quantity_in_stock) AS highest_stock,

    -- Pricing
    MIN(price) AS cheapest_product,
    MAX(price) AS most_expensive_product,
    AVG(price) AS avg_price,

    -- Out of stock
    COUNT(CASE WHEN quantity_in_stock = 0 THEN 1 END) AS out_of_stock_count
FROM products
WHERE is_active = TRUE;
```

---

### Example 3: Data Quality Report

```sql
-- Check data completeness
SELECT
    COUNT(*) AS total_records,

    -- Email completeness
    COUNT(email) AS records_with_email,
    COUNT(*) - COUNT(email) AS records_missing_email,
    ROUND(100.0 * COUNT(email) / COUNT(*), 2) AS email_completeness_pct,

    -- Phone completeness
    COUNT(phone) AS records_with_phone,
    COUNT(*) - COUNT(phone) AS records_missing_phone,
    ROUND(100.0 * COUNT(phone) / COUNT(*), 2) AS phone_completeness_pct,

    -- Address completeness
    COUNT(address) AS records_with_address,
    ROUND(100.0 * COUNT(address) / COUNT(*), 2) AS address_completeness_pct
FROM customers;
```

**Result:**
```
total_records: 15420
records_with_email: 14892
records_missing_email: 528
email_completeness_pct: 96.58
...
```

---

## 🔧 Code Examples

### Example: Monthly Sales Report

```sql
-- Calculate comprehensive sales metrics
SELECT
    -- Volume metrics
    COUNT(*) AS number_of_sales,
    COUNT(DISTINCT customer_id) AS unique_buyers,
    COUNT(DISTINCT product_id) AS unique_products_sold,

    -- Revenue metrics
    SUM(sale_amount) AS total_revenue,
    AVG(sale_amount) AS average_sale_amount,
    MIN(sale_amount) AS smallest_sale,
    MAX(sale_amount) AS largest_sale,

    -- Derived metrics
    SUM(sale_amount) / COUNT(DISTINCT customer_id) AS revenue_per_customer,
    COUNT(*) * 1.0 / COUNT(DISTINCT customer_id) AS avg_purchases_per_customer
FROM sales
WHERE sale_date >= '2024-10-01'
  AND sale_date < '2024-11-01'
  AND status = 'completed';
```

---

### Example: Performance Comparison (YoY)

```sql
-- Compare this year vs last year
SELECT
    'This Year' AS period,
    COUNT(*) AS orders,
    SUM(total_amount) AS revenue,
    AVG(total_amount) AS avg_order_value
FROM orders
WHERE order_date >= '2024-01-01' AND order_date < '2025-01-01'

UNION ALL

SELECT
    'Last Year' AS period,
    COUNT(*) AS orders,
    SUM(total_amount) AS revenue,
    AVG(total_amount) AS avg_order_value
FROM orders
WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01';
```

---

## ✅ Best Practices

### 1. Use COUNT(*) for Row Counts
```sql
-- ✅ Good: Fastest, counts all rows
SELECT COUNT(*) FROM orders;

-- ❌ Slower: Has to check if primary key is NULL (never is)
SELECT COUNT(order_id) FROM orders;
```

### 2. Handle NULLs in SUM/AVG
```sql
-- ✅ Good: Returns 0 instead of NULL when all values are NULL
SELECT COALESCE(SUM(discount_amount), 0) AS total_discounts
FROM orders;

-- ❌ May return NULL unexpectedly
SELECT SUM(discount_amount) AS total_discounts
FROM orders;
```

### 3. Use DISTINCT Carefully (Performance)
```sql
-- ✅ Good: DISTINCT needed for unique count
SELECT COUNT(DISTINCT customer_id) FROM orders;

-- ❌ Expensive: DISTINCT on large result sets
SELECT DISTINCT * FROM huge_table;  -- Avoid if possible
```

### 4. Round Averages for Display
```sql
-- ✅ Good: Readable results
SELECT ROUND(AVG(price), 2) AS avg_price FROM products;

-- ❌ Too many decimals: 127.8294736842105
SELECT AVG(price) AS avg_price FROM products;
```

### 5. Always Filter First (Performance)
```sql
-- ✅ Good: Filter reduces data before aggregation
SELECT COUNT(*)
FROM orders
WHERE order_date >= '2024-01-01';

-- ❌ Slower: Aggregates all data, then filters (if using HAVING)
```

---

## ⚠️ Common Pitfalls

### 1. Confusing COUNT(*) and COUNT(column)
```sql
-- ❌ Wrong assumption: These are NOT always equal
SELECT COUNT(*) FROM customers;         -- 10000
SELECT COUNT(email) FROM customers;     -- 9500 (500 NULLs)
```

### 2. SUM() Returning NULL
```sql
-- ❌ Unexpected NULL
SELECT SUM(bonus) FROM employees WHERE bonus > 1000000;
-- If no employees have bonus > 1M, returns NULL, not 0!

-- ✅ Better: Default to 0
SELECT COALESCE(SUM(bonus), 0) FROM employees WHERE bonus > 1000000;
```

### 3. AVG() With NULLs
```sql
-- Values: [100, 200, NULL, NULL]
SELECT AVG(score) FROM tests;  -- 150 (300/2, not 300/4)

-- Be aware NULLs are excluded from average calculation
```

### 4. MIN/MAX on Wrong Data Type
```sql
-- ❌ String comparison, not numeric
-- '9' > '10' alphabetically!
SELECT MAX(order_id) FROM orders WHERE order_id is VARCHAR;

-- ✅ Convert to number first
SELECT MAX(CAST(order_id AS INTEGER)) FROM orders;
```

### 5. Forgetting to Filter Data
```sql
-- ❌ Includes cancelled orders
SELECT SUM(total_amount) FROM orders;

-- ✅ Only completed orders
SELECT SUM(total_amount) FROM orders WHERE status = 'completed';
```

---

## 🏋️ Hands-On Exercises

### Exercise 1: Basic Aggregates
Using the `orders` table:
1. Count total number of orders
2. Find the sum of all order amounts
3. Calculate the average order value
4. Find the smallest and largest order amounts

### Exercise 2: NULL Handling
Using the `customers` table:
1. Count total customers
2. Count customers with email addresses
3. Count customers with phone numbers
4. Calculate email completeness percentage

### Exercise 3: DISTINCT Counts
Using the `orders` table:
1. Count unique customers who placed orders
2. Count unique products that were ordered
3. Count unique order dates

### Exercise 4: Comprehensive Analysis
Write a single query that returns:
- Total number of products
- Number of unique categories
- Total inventory value (sum of price * quantity)
- Average product price
- Cheapest and most expensive products
- Number of products out of stock (quantity = 0)

### Exercise 5: Real-World Scenario
Create a monthly sales summary showing:
- Number of orders
- Total revenue
- Average order value
- Number of unique customers
- Smallest and largest order
- Revenue per customer

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-03-Solutions.sql`

---

## 📚 Further Reading

- [PostgreSQL Aggregate Functions](https://www.postgresql.org/docs/current/functions-aggregate.html)
- [SQL Aggregate Functions Tutorial (Mode)](https://mode.com/sql-tutorial/sql-aggregate-functions/)
- [Understanding COUNT()](https://www.essentialsql.com/count-versus-count-distinct/)
- [Handling NULLs in Aggregates](https://modern-sql.com/feature/aggregate-functions)

---

## 📝 Key Takeaways

1. **COUNT(*)** counts all rows; **COUNT(column)** counts non-NULL values only
2. **COUNT(DISTINCT column)** counts unique non-NULL values
3. **SUM()** and **AVG()** ignore NULL values but return NULL if all values are NULL
4. Use **COALESCE(SUM(...), 0)** to default to 0 instead of NULL
5. **MIN()** and **MAX()** work on numbers, dates, and text (alphabetical)
6. **AVG()** divides by COUNT(column), not COUNT(*), so NULLs affect the result
7. Multiple aggregates can be combined in a single SELECT
8. Always **filter data with WHERE** before aggregating for better performance
9. **ROUND()** averages and sums for readable output
10. Aggregate functions are the foundation for GROUP BY queries (next subchapter)

---

## 🔗 Related Concepts

- [[03. Filtering and Logical Operators|Previous: Advanced Filtering]]
- [[05. GROUP BY and HAVING|Next: Grouping and Filtering Aggregates]]
- [[08. Window Functions|Advanced: Window Functions for Row-Level Aggregates]]

---

## ✏️ Notes Section

**My Key Insights:**
-

**NULL Handling Patterns:**
-

**Business Metrics to Remember:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ✅ Complete - Ready for study*
