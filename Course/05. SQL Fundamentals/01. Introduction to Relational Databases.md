# 01. Introduction to Relational Databases

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Core concepts of relational database systems and why they matter for data engineering

---

## üìã Overview

Before diving into SQL syntax, it's essential to understand the foundation: relational databases. These systems have been the backbone of data storage for over 40 years, and for good reason. They provide a structured, reliable, and efficient way to store and query data.

Relational databases organize data into tables (relations) with rows and columns, enforce relationships between tables, and guarantee data integrity through ACID properties. Whether you're building data pipelines, designing data warehouses, or analyzing business data, you'll work with relational databases daily.

Understanding the "why" behind relational databases - not just the "how" - will make you a better data engineer. You'll make smarter design decisions, write more efficient queries, and appreciate why certain patterns exist.

**Why This Matters:**
- Relational databases power 90%+ of business applications and data warehouses
- Understanding database fundamentals prevents costly design mistakes
- ACID properties ensure your data pipelines produce reliable results
- These concepts transfer to NoSQL, data warehouses, and distributed systems

---

## üéØ Learning Objectives

After completing this subchapter, you will be able to:
- Explain what a relational database is and why it's called "relational"
- Understand ACID properties and why they matter for data integrity
- Identify the components of a relational database (schemas, tables, rows, columns)
- Explain primary keys, foreign keys, and relationships between tables
- Understand normalization and why we organize data into multiple tables
- Recognize when to use relational databases vs other data stores
- Appreciate the tradeoffs relational databases make (ACID vs performance)
- Understand transactions and how they protect data consistency

---

## üìö Core Concepts

### 1. What is a Relational Database?

A **relational database** is a structured collection of data organized into **tables** (relations) where:
- Each table represents an entity (customers, orders, products)
- Rows represent individual records (one customer, one order)
- Columns represent attributes (customer_name, order_date)
- Tables are related to each other through **keys**

**Key Insight:** "Relational" refers to the mathematical concept of relations (tables) and how they connect to each other, not to "relationships" in the colloquial sense.

#### Example: E-Commerce Database Structure
```
CUSTOMERS Table              ORDERS Table
+-------------+             +--------------+
| customer_id | ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí| customer_id  |  (Foreign Key)
| name        |             | order_id     |  (Primary Key)
| email       |             | order_date   |
| country     |             | total_amount |
+-------------+             +--------------+
```

---

### 2. ACID Properties

ACID is the cornerstone of relational databases, ensuring data integrity even in the face of failures.

#### A - Atomicity
**Definition:** Transactions are all-or-nothing. Either all operations succeed, or none do.

**Example:**
```sql
-- Bank transfer: Both must succeed or both must fail
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;
```

If the database crashes after the first UPDATE but before the second, **atomicity** ensures both updates are rolled back. You can't lose money!

#### C - Consistency
**Definition:** Database moves from one valid state to another. All rules (constraints) are enforced.

**Example:**
```sql
-- This constraint ensures email is always unique
ALTER TABLE customers
ADD CONSTRAINT unique_email UNIQUE (email);

-- This INSERT will fail if email already exists (maintains consistency)
INSERT INTO customers (email) VALUES ('duplicate@example.com');
```

#### I - Isolation
**Definition:** Concurrent transactions don't interfere with each other. Each transaction sees a consistent snapshot.

**Example:** Two users booking the last concert ticket simultaneously. Isolation ensures only one succeeds.

**Isolation Levels:**
- **Read Uncommitted:** Lowest isolation, allows dirty reads
- **Read Committed:** Default for most databases
- **Repeatable Read:** Prevents non-repeatable reads
- **Serializable:** Highest isolation, transactions execute as if serial

#### D - Durability
**Definition:** Once a transaction commits, data persists even if system crashes.

**Example:**
```sql
COMMIT; -- Once this succeeds, data is safely written to disk
-- Even if power fails 1 second later, your data is safe
```

**Real-World Impact:** ACID is why banks trust relational databases with financial transactions. NoSQL databases often sacrifice ACID for performance.

---

### 3. Database Components

#### Schemas
A **schema** is a namespace that groups related tables together.

```sql
-- Create schema for sales data
CREATE SCHEMA sales;

-- Create tables within schema
CREATE TABLE sales.customers (...);
CREATE TABLE sales.orders (...);

-- Reference with full path
SELECT * FROM sales.customers;
```

**Use Cases:**
- Organize tables by business domain (sales, marketing, operations)
- Separate dev/test/prod environments
- Multi-tenant applications (one schema per customer)

#### Tables
Tables (relations) are the primary data structure.

```sql
CREATE TABLE customers (
    customer_id    INT PRIMARY KEY,
    customer_name  VARCHAR(100) NOT NULL,
    email          VARCHAR(255) UNIQUE,
    created_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Components:**
- **Columns:** Attributes with defined data types
- **Rows:** Individual records
- **Constraints:** Rules enforcing data integrity

#### Rows and Columns
- **Row (Record):** One instance of an entity
- **Column (Attribute):** One property of the entity

```
+-------------+---------------+---------------------+
| customer_id | customer_name | email               |
+-------------+---------------+---------------------+
| 1           | Alice Johnson | alice@example.com   |  ‚Üê Row
| 2           | Bob Smith     | bob@example.com     |  ‚Üê Row
+-------------+---------------+---------------------+
      ‚Üë              ‚Üë               ‚Üë
   Columns      Columns         Columns
```

---

### 4. Keys and Relationships

#### Primary Key
Uniquely identifies each row in a table. Cannot be NULL.

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,  -- Unique identifier
    customer_id INT,
    order_date DATE
);
```

**Characteristics:**
- Must be unique
- Cannot be NULL
- Usually an auto-incrementing integer or UUID
- One primary key per table

#### Foreign Key
References a primary key in another table, creating relationships.

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

**Enforces Referential Integrity:**
- Cannot insert an order with a non-existent customer_id
- Cannot delete a customer who has orders (without CASCADE)

#### Types of Relationships

**One-to-Many (Most Common):**
```
One customer ‚Üí Many orders
One order ‚Üí Many order items
```

**One-to-One:**
```
One customer ‚Üí One customer_profile
```

**Many-to-Many (Requires Junction Table):**
```
Many students ‚Üî Many courses
(Requires student_courses junction table)
```

---

### 5. Normalization

**Normalization** is the process of organizing data to reduce redundancy and improve data integrity.

#### Why Normalize?

**‚ùå Un-normalized (Redundant):**
```
ORDERS Table
+---------+---------------+---------------+------------------+
| order_id| customer_name | customer_email| product_name     |
+---------+---------------+---------------+------------------+
| 1       | Alice         | alice@ex.com  | Laptop           |
| 2       | Alice         | alice@ex.com  | Mouse            |
| 3       | Bob           | bob@ex.com    | Keyboard         |
+---------+---------------+---------------+------------------+
```
**Problems:**
- Customer data repeated (update anomalies)
- Wasted storage
- Inconsistencies (what if email changes?)

**‚úÖ Normalized (Efficient):**
```
CUSTOMERS Table             ORDERS Table
+-------------+--------+    +---------+-------------+
| customer_id | name   |    | order_id| customer_id |
+-------------+--------+    +---------+-------------+
| 1           | Alice  |    | 1       | 1           |
| 2           | Bob    |    | 2       | 1           |
+-------------+--------+    | 3       | 2           |
                            +---------+-------------+
```

#### Normal Forms (Simplified)

**1st Normal Form (1NF):**
- Each column contains atomic values (no lists/arrays)
- Each column contains one type of data
- Each row is unique

**2nd Normal Form (2NF):**
- Must be in 1NF
- No partial dependencies (all non-key columns depend on entire primary key)

**3rd Normal Form (3NF):**
- Must be in 2NF
- No transitive dependencies (non-key columns depend only on primary key, not on other non-key columns)

**Practical Takeaway:** Most business databases aim for 3NF as a balance between data integrity and query performance.

---

### 6. Transactions

A **transaction** is a sequence of database operations treated as a single unit.

```sql
-- Transfer money between accounts
BEGIN TRANSACTION;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;

    -- If everything looks good, commit
    IF (balance check passes) THEN
        COMMIT;
    ELSE
        ROLLBACK;  -- Undo all changes
    END IF;
```

**Transaction Commands:**
- `BEGIN TRANSACTION` - Start transaction
- `COMMIT` - Save all changes permanently
- `ROLLBACK` - Undo all changes since BEGIN
- `SAVEPOINT` - Create checkpoint within transaction

---

## üí° Practical Examples

### Example 1: E-Commerce Database Design

```sql
-- Customers table (Primary entity)
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Orders table (Related to customers)
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10, 2),
    status VARCHAR(20),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- Order items (Many-to-many: orders ‚Üî products)
CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10, 2),
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
```

**Why This Design?**
- Customers stored once (no redundancy)
- Orders reference customers via foreign key
- Order items capture many-to-many relationship
- Can query: "What did customer X order?" or "Who ordered product Y?"

---

### Example 2: ACID in Action - Banking Transaction

```sql
-- Ensure accounts never go negative and transfers are atomic
BEGIN TRANSACTION;
    -- Deduct from sender
    UPDATE accounts
    SET balance = balance - 500
    WHERE account_id = 123 AND balance >= 500;

    -- Check if deduction succeeded (balance was sufficient)
    IF FOUND THEN
        -- Add to receiver
        UPDATE accounts
        SET balance = balance + 500
        WHERE account_id = 456;

        COMMIT;  -- Both updates succeed together
    ELSE
        ROLLBACK;  -- Insufficient funds, undo everything
    END IF;
```

**ACID at Work:**
- **Atomicity:** Both updates or neither
- **Consistency:** Balance constraints maintained
- **Isolation:** Other transactions don't see intermediate state
- **Durability:** Once committed, transfer is permanent

---

## üîß Code Examples

### Creating a Complete Database Schema

```sql
-- Create schema
CREATE SCHEMA ecommerce;

-- Products table
CREATE TABLE ecommerce.products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(200) NOT NULL,
    category VARCHAR(100),
    price DECIMAL(10, 2) CHECK (price >= 0),
    stock_quantity INT CHECK (stock_quantity >= 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Customers table with constraints
CREATE TABLE ecommerce.customers (
    customer_id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_email CHECK (email LIKE '%@%.%')
);

-- Orders with foreign key
CREATE TABLE ecommerce.orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending',
    total_amount DECIMAL(10, 2),
    FOREIGN KEY (customer_id)
        REFERENCES ecommerce.customers(customer_id)
        ON DELETE RESTRICT  -- Prevent deleting customers with orders
);
```

---

## ‚úÖ Best Practices

### 1. Always Define Primary Keys
```sql
-- ‚úÖ Good: Explicit primary key
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50)
);

-- ‚ùå Bad: No primary key (hard to reference, update, delete)
CREATE TABLE users (
    username VARCHAR(50)
);
```

### 2. Use Foreign Keys for Data Integrity
```sql
-- ‚úÖ Good: Enforces referential integrity
FOREIGN KEY (customer_id) REFERENCES customers(customer_id)

-- ‚ùå Bad: No constraint (orphaned records possible)
customer_id INT  -- No foreign key
```

### 3. Choose Appropriate Data Types
```sql
-- ‚úÖ Good: Specific types
email VARCHAR(255)
age INT
price DECIMAL(10, 2)
created_at TIMESTAMP

-- ‚ùå Bad: Everything as VARCHAR
email VARCHAR(1000)
age VARCHAR(100)
price VARCHAR(100)
```

### 4. Add NOT NULL Where Appropriate
```sql
-- ‚úÖ Good: Enforce required fields
email VARCHAR(255) NOT NULL
customer_id INT NOT NULL

-- ‚ùå Bad: Everything nullable (data quality issues)
email VARCHAR(255)  -- Can be NULL unexpectedly
```

### 5. Use Transactions for Multi-Step Operations
```sql
-- ‚úÖ Good: Atomic operations
BEGIN;
    UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 123;
    INSERT INTO orders (...) VALUES (...);
COMMIT;

-- ‚ùå Bad: No transaction (partial updates possible)
UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 123;
INSERT INTO orders (...) VALUES (...);  -- Might fail, leaving inventory wrong
```

---

## ‚ö†Ô∏è Common Pitfalls

### 1. Not Using Transactions for Related Operations
**Problem:** Database crashes between related updates
**Solution:** Wrap in BEGIN/COMMIT

### 2. Over-Normalization
**Problem:** Too many JOINs slow down queries
**Solution:** Normalize to 3NF, denormalize for specific performance needs

### 3. Ignoring Foreign Key Constraints
**Problem:** Orphaned records, data integrity issues
**Solution:** Always use foreign keys for relationships

### 4. Using VARCHAR for Everything
**Problem:** Wasted space, slow queries, loss of data type benefits
**Solution:** Use specific types (INT, DECIMAL, DATE, etc.)

### 5. Not Planning for Scale
**Problem:** Schema redesign needed when data grows
**Solution:** Think about cardinality, indexes, and partitioning early

---

## üèãÔ∏è Hands-On Exercises

### Exercise 1: Identify ACID Violations
Given these scenarios, identify which ACID property would be violated:
1. Half a bank transfer completes before system crash
2. Two users book the same seat simultaneously
3. Committed transaction disappears after restart
4. Inserting a row violates a unique constraint

### Exercise 2: Database Design
Design a database schema for a library system with:
- Books (title, author, ISBN, publication_year)
- Members (name, email, join_date)
- Loans (which member borrowed which book, when)

Include:
- Primary keys
- Foreign keys
- Appropriate data types
- Constraints (NOT NULL, UNIQUE, CHECK)

### Exercise 3: Normalization
Given this denormalized table, normalize to 3NF:
```
STUDENT_COURSES
+------------+-------------+-------------+--------------+
| student_id | student_name| course_name | instructor   |
+------------+-------------+-------------+--------------+
| 1          | Alice       | Math 101    | Dr. Smith    |
| 1          | Alice       | CS 101      | Dr. Jones    |
| 2          | Bob         | Math 101    | Dr. Smith    |
+------------+-------------+-------------+--------------+
```

**Solutions:** Available in `Exercises/Chapter-05/Solutions/`

---

## üìö Further Reading

### Books
- **"Database System Concepts"** by Silberschatz, Korth, Sudarshan - Comprehensive theory
- **"SQL Performance Explained"** by Markus Winand - Performance implications of design

### Articles
- [ACID Properties Explained](https://www.databass.dev/acid-properties-explained)
- [Database Normalization Explained](https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/)
- [Designing Data-Intensive Applications (Chapter 7)](https://dataintensive.net/) - Transactions

### Videos
- [MIT 6.814 Database Systems](https://www.youtube.com/playlist?list=PLUl4u3cNGP61dN2VkHBH3YGLBGPXdN3pB) - Academic foundation
- [Carnegie Mellon Database Group](https://www.youtube.com/@CMUDatabaseGroup) - Advanced topics

---

## üìù Key Takeaways

1. **Relational databases** organize data into tables with relationships defined by keys
2. **ACID properties** (Atomicity, Consistency, Isolation, Durability) ensure data integrity
3. **Primary keys** uniquely identify rows; **foreign keys** create relationships between tables
4. **Normalization** reduces redundancy and improves data integrity (aim for 3NF)
5. **Transactions** group related operations into atomic units
6. **Schemas** organize tables into namespaces for better organization
7. Use **appropriate data types** for storage efficiency and data integrity
8. **Foreign key constraints** prevent orphaned records and maintain referential integrity
9. Relational databases excel at **structured data** with well-defined relationships
10. Understanding database fundamentals makes you a better data engineer

---

## üîó Related Concepts

- [[02. SQL Basics - SELECT, WHERE, ORDER BY|Next: Basic SQL Queries]]
- [[Course/06. Database Systems/README|Chapter 6: Database Systems]] - When to use relational vs other stores
- [[Course/07. Data Modeling/README|Chapter 7: Data Modeling]] - Schema design patterns
- [[Resources/Legacy-Content/1. SQL/11. Data Modeling & Table Design|Legacy: Data Modeling Notes]]

---

## ‚úèÔ∏è Notes Section

**My Key Insights:**
-

**Questions to Explore Further:**
-

**Real-World Examples I've Encountered:**
-

**Design Patterns to Remember:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ‚úÖ Complete - Ready for study*
