Please comm# 03. Filtering and Logical Operators

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Advanced filtering techniques using logical operators, ranges, lists, and pattern matching

---

## üìã Overview

Filtering data precisely is one of the most critical skills in SQL. While basic WHERE clauses handle simple comparisons, real-world queries often require complex filtering logic combining multiple conditions.

This subchapter goes beyond basic filtering to cover logical operators (AND, OR, NOT), specialized operators (IN, BETWEEN, LIKE), and NULL handling. Master these techniques and you'll be able to express any filtering logic you need, from simple to highly complex.

**Real-World Applications:**
- Customer segmentation (age 25-35 AND (country = 'USA' OR country = 'Canada'))
- Product filtering (category IN ('Electronics', 'Computers') AND price < 1000)
- Data quality checks (finding records with missing or invalid data)
- Pattern-based searches (emails matching certain domains, product codes with specific formats)

---

## üéØ Learning Objectives

After completing this subchapter, you will be able to:
- Combine multiple filter conditions using AND, OR, and NOT operators
- Use parentheses to control logical operator precedence
- Filter using value lists with the IN operator
- Filter ranges efficiently with BETWEEN
- Perform pattern matching with LIKE and wildcards
- Handle NULL values correctly in filter conditions
- Write complex multi-condition filters for business logic
- Understand SQL's three-valued logic (TRUE, FALSE, NULL)

---

## üìö Core Concepts

### 1. Logical Operators

#### AND Operator - All Conditions Must Be TRUE

The AND operator requires **all** conditions to be TRUE for a row to be returned.

```sql
-- Find premium customers in California
SELECT customer_name, state, account_balance
FROM customers
WHERE state = 'CA'
  AND account_balance > 10000
  AND status = 'active';
```

**Logic:** Only returns rows where:
- state = 'CA' **AND**
- account_balance > 10000 **AND**
- status = 'active'

**Truth Table:**
```
Condition1  Condition2  Result
TRUE        TRUE        TRUE   ‚Üê Only this returns rows
TRUE        FALSE       FALSE
FALSE       TRUE        FALSE
FALSE       FALSE       FALSE
```

---

#### OR Operator - At Least One Condition Must Be TRUE

The OR operator requires **at least one** condition to be TRUE.

```sql
-- Find customers from USA, Canada, or UK
SELECT customer_name, country
FROM customers
WHERE country = 'USA'
   OR country = 'Canada'
   OR country = 'UK';
```

**Truth Table:**
```
Condition1  Condition2  Result
TRUE        TRUE        TRUE   ‚Üê Returns rows
TRUE        FALSE       TRUE   ‚Üê Returns rows
FALSE       TRUE        TRUE   ‚Üê Returns rows
FALSE       FALSE       FALSE
```

---

#### NOT Operator - Negates a Condition

The NOT operator reverses the truth value of a condition.

```sql
-- Find customers NOT from USA
SELECT customer_name, country
FROM customers
WHERE NOT country = 'USA';

-- Equivalent to:
WHERE country != 'USA'
-- Or:
WHERE country <> 'USA'
```

**Use Cases:**
- Excluding specific values
- Finding records that DON'T match a pattern
- Inverting complex conditions

---

### 2. Combining AND/OR - Operator Precedence

**Critical Rule:** AND has higher precedence than OR!

```sql
-- ‚ùå WRONG: Ambiguous logic
WHERE country = 'USA' OR country = 'Canada' AND balance > 5000

-- Evaluated as:
WHERE country = 'USA' OR (country = 'Canada' AND balance > 5000)
-- Returns: ALL USA customers + Canadian customers with balance > 5000

-- ‚úÖ CORRECT: Use parentheses!
WHERE (country = 'USA' OR country = 'Canada') AND balance > 5000
-- Returns: USA or Canadian customers with balance > 5000
```

**Best Practice:** Always use parentheses when mixing AND/OR, even if not strictly necessary. Makes intent clear.

#### Example: Complex Business Logic

```sql
-- Find high-value customers OR customers with recent orders
SELECT
    customer_name,
    account_balance,
    last_order_date
FROM customers
WHERE (
        account_balance > 10000  -- High value
        OR last_order_date > CURRENT_DATE - INTERVAL '30 days'  -- Recent activity
    )
  AND status = 'active'  -- Must be active
  AND country IN ('USA', 'Canada', 'UK');  -- Specific countries
```

---

### 3. IN Operator - Matching Against a List

The IN operator checks if a value matches **any value** in a list.

```sql
-- Find customers from specific countries
SELECT customer_name, country
FROM customers
WHERE country IN ('USA', 'Canada', 'UK', 'Australia');

-- Equivalent to (but much cleaner than):
WHERE country = 'USA'
   OR country = 'Canada'
   OR country = 'UK'
   OR country = 'Australia';
```

#### IN with Numbers
```sql
-- Find orders with specific priorities
SELECT order_id, priority
FROM orders
WHERE priority IN (1, 2, 3);  -- High priorities only
```

#### IN with Subqueries (Preview)
```sql
-- Find customers who have placed orders
SELECT customer_name
FROM customers
WHERE customer_id IN (
    SELECT DISTINCT customer_id FROM orders
);
```

#### NOT IN
```sql
-- Find customers NOT from these countries
SELECT customer_name, country
FROM customers
WHERE country NOT IN ('USA', 'Canada');
```

**‚ö†Ô∏è Warning:** NOT IN with NULLs can produce unexpected results (covered in NULL handling section).

---

### 4. BETWEEN Operator - Range Filtering

The BETWEEN operator filters for values within a range (inclusive).

```sql
-- Find products priced between $50 and $200
SELECT product_name, price
FROM products
WHERE price BETWEEN 50 AND 200;

-- Equivalent to:
WHERE price >= 50 AND price <= 200;
```

**Important:** BETWEEN is **inclusive** on both ends.

#### Numeric Ranges
```sql
-- Find adult customers (ages 18-65)
SELECT customer_name, age
FROM customers
WHERE age BETWEEN 18 AND 65;
```

#### Date Ranges
```sql
-- Find orders from last quarter
SELECT order_id, order_date, total_amount
FROM orders
WHERE order_date BETWEEN '2024-07-01' AND '2024-09-30';
```

#### NOT BETWEEN
```sql
-- Find outlier prices (< $10 or > $1000)
SELECT product_name, price
FROM products
WHERE price NOT BETWEEN 10 AND 1000;

-- Equivalent to:
WHERE price < 10 OR price > 1000;
```

---

### 5. LIKE Operator - Pattern Matching

The LIKE operator enables pattern matching using wildcards.

#### Wildcards

| Wildcard | Matches | Example | Matches |
|----------|---------|---------|---------|
| `%` | Zero or more characters | `'%son'` | "Johnson", "Anderson", "son" |
| `%` | | `'J%'` | "John", "Jane", "J" |
| `%` | | `'%tech%'` | "technology", "biotech", "tech" |
| `_` | Exactly ONE character | `'J_hn'` | "John", "Jahn" (NOT "Johan") |
| `_` | | `'___'` | Any 3-character string |

#### Examples

**Starts With:**
```sql
-- Find customers whose name starts with 'A'
SELECT customer_name
FROM customers
WHERE customer_name LIKE 'A%';
-- Matches: "Alice", "Andrew", "Anderson", "A"
```

**Ends With:**
```sql
-- Find Gmail users
SELECT email
FROM customers
WHERE email LIKE '%@gmail.com';
-- Matches: "user@gmail.com", "test@gmail.com"
```

**Contains:**
```sql
-- Find products with "Pro" in the name
SELECT product_name
FROM products
WHERE product_name LIKE '%Pro%';
-- Matches: "MacBook Pro", "GoPro Camera", "Professional Tools"
```

**Exact Length with _:**
```sql
-- Find 3-letter country codes
SELECT country_code
FROM countries
WHERE country_code LIKE '___';
-- Matches: "USA", "GBR", "CAN" (exactly 3 characters)
```

**Combine Wildcards:**
```sql
-- Find product codes like "PROD-XX-YYYY"
SELECT product_code
FROM products
WHERE product_code LIKE 'PROD-__-____';
-- Matches: "PROD-AB-1234", "PROD-XY-5678"
```

#### Case Sensitivity

```sql
-- Case-sensitive (default in most databases)
WHERE customer_name LIKE 'John%'
-- Matches: "John", "Johnson" (NOT "john" or "JOHN")

-- Case-insensitive (PostgreSQL)
WHERE customer_name ILIKE 'john%'
-- Matches: "John", "JOHN", "john", "Johnson"

-- Case-insensitive (MySQL, SQL Server)
WHERE UPPER(customer_name) LIKE 'JOHN%'
-- Matches: "John", "JOHN", "john"
```

#### NOT LIKE
```sql
-- Find customers NOT using Gmail
SELECT email
FROM customers
WHERE email NOT LIKE '%@gmail.com';
```

---

### 6. Working with NULL Values

NULL represents missing or unknown data. NULL comparisons use special logic.

#### IS NULL / IS NOT NULL

```sql
-- Find customers with no email
SELECT customer_name
FROM customers
WHERE email IS NULL;

-- Find customers with an email
SELECT customer_name
FROM customers
WHERE email IS NOT NULL;
```

**‚ùå WRONG:**
```sql
-- This will NOT work! Always returns no rows
WHERE email = NULL   -- NULL = NULL is always unknown, not true
```

**‚úÖ CORRECT:**
```sql
WHERE email IS NULL  -- Proper NULL check
```

#### NULL in Logical Operators

**Three-Valued Logic:** SQL uses TRUE, FALSE, and **UNKNOWN** (NULL).

```sql
-- If age is NULL:
WHERE age > 18  -- Result: UNKNOWN (not TRUE, so row not returned)
```

**AND with NULL:**
```
TRUE AND NULL = NULL
FALSE AND NULL = FALSE
NULL AND NULL = NULL
```

**OR with NULL:**
```
TRUE OR NULL = TRUE
FALSE OR NULL = NULL
NULL OR NULL = NULL
```

#### NOT IN with NULLs - A Common Pitfall

```sql
-- ‚ö†Ô∏è If subcategory list contains NULL, this might return no rows!
WHERE category NOT IN (
    SELECT subcategory FROM products
);

-- ‚úÖ Better: Explicitly handle NULLs
WHERE category NOT IN (
    SELECT subcategory FROM products WHERE subcategory IS NOT NULL
);
```

---

## üí° Practical Examples

### Example 1: Customer Segmentation Query

```sql
-- Find high-value customers for targeted marketing
SELECT
    customer_id,
    customer_name,
    country,
    account_balance,
    last_order_date
FROM customers
WHERE (
        -- Segment 1: High spenders
        account_balance > 10000
        OR
        -- Segment 2: Recent high-value orders
        (
            last_order_date > CURRENT_DATE - INTERVAL '30 days'
            AND last_order_value > 1000
        )
    )
  AND status = 'active'  -- Must be active
  AND country IN ('USA', 'Canada', 'UK', 'Australia')  -- Target markets
  AND email IS NOT NULL;  -- Must have email for marketing
```

**Business Logic:** Target active customers in key markets who are either high-balance OR recently made a high-value purchase.

---

### Example 2: Product Inventory Filtering

```sql
-- Find products needing attention
SELECT
    product_id,
    product_name,
    category,
    stock_quantity,
    reorder_level,
    price
FROM products
WHERE (
        -- Low stock
        stock_quantity < reorder_level
        OR
        -- Discontinued but still in stock
        (status = 'discontinued' AND stock_quantity > 0)
    )
  AND category NOT IN ('Clearance', 'Seasonal')  -- Exclude certain categories
  AND price BETWEEN 10 AND 5000  -- Reasonable price range
ORDER BY stock_quantity ASC;
```

---

### Example 3: Data Quality Check

```sql
-- Find potentially invalid customer records
SELECT
    customer_id,
    customer_name,
    email,
    phone,
    country
FROM customers
WHERE
    -- Missing critical information
    (email IS NULL OR phone IS NULL)
    OR
    -- Invalid email format
    email NOT LIKE '%@%.%'
    OR
    -- Invalid phone (not 10 digits for USA)
    (country = 'USA' AND phone NOT LIKE '___-___-____')
    OR
    -- Suspicious names
    (customer_name LIKE '%test%' OR customer_name LIKE '%admin%');
```

---

## üîß Code Examples

### Complex Multi-Condition Query

```sql
-- E-commerce: Find orders requiring special attention
SELECT
    o.order_id,
    o.customer_id,
    o.order_date,
    o.total_amount,
    o.status,
    o.shipping_country
FROM orders o
WHERE
    -- Condition Set 1: High-value international orders
    (
        o.total_amount > 1000
        AND o.shipping_country NOT IN ('USA', 'Canada')
        AND o.status IN ('processing', 'pending_payment')
    )
    OR
    -- Condition Set 2: Delayed domestic orders
    (
        o.shipping_country IN ('USA', 'Canada')
        AND o.order_date < CURRENT_DATE - INTERVAL '7 days'
        AND o.status = 'processing'
    )
    OR
    -- Condition Set 3: Orders with payment issues
    (
        o.status = 'payment_failed'
        AND o.order_date > CURRENT_DATE - INTERVAL '3 days'
    )
ORDER BY o.total_amount DESC, o.order_date ASC;
```

---

## ‚úÖ Best Practices

### 1. Always Use Parentheses for Complex Logic
```sql
-- ‚úÖ Good: Clear precedence
WHERE (a = 1 OR a = 2) AND (b = 3 OR b = 4)

-- ‚ùå Confusing: Relies on operator precedence knowledge
WHERE a = 1 OR a = 2 AND b = 3 OR b = 4
```

### 2. Use IN for Multiple Values
```sql
-- ‚úÖ Good: Clean and readable
WHERE country IN ('USA', 'Canada', 'UK')

-- ‚ùå Verbose
WHERE country = 'USA' OR country = 'Canada' OR country = 'UK'
```

### 3. Use BETWEEN for Ranges
```sql
-- ‚úÖ Good: Clear intent
WHERE price BETWEEN 100 AND 500

-- ‚ùå Less clear
WHERE price >= 100 AND price <= 500
```

### 4. Handle NULLs Explicitly
```sql
-- ‚úÖ Good: Explicit NULL handling
WHERE (email LIKE '%@company.com' OR email IS NULL)

-- ‚ùå May miss NULL values
WHERE email LIKE '%@company.com'
```

### 5. Use Case-Insensitive Search When Appropriate
```sql
-- ‚úÖ Good: Case-insensitive
WHERE UPPER(customer_name) LIKE UPPER('john%')

-- ‚ùå Miss "JOHN", "John", etc.
WHERE customer_name LIKE 'john%'
```

---

## ‚ö†Ô∏è Common Pitfalls

### 1. AND/OR Precedence Errors
```sql
-- ‚ùå Wrong: Returns all USA customers + Canadian customers with balance > 5000
WHERE country = 'USA' OR country = 'Canada' AND balance > 5000

-- ‚úÖ Correct: Parentheses make intent clear
WHERE (country = 'USA' OR country = 'Canada') AND balance > 5000
```

### 2. Using = with NULL
```sql
-- ‚ùå Wrong: Always returns no rows
WHERE email = NULL

-- ‚úÖ Correct
WHERE email IS NULL
```

### 3. NOT IN with NULLs
```sql
-- ‚ùå Might return no rows if list contains NULL
WHERE id NOT IN (SELECT category_id FROM categories)

-- ‚úÖ Correct: Filter out NULLs
WHERE id NOT IN (SELECT category_id FROM categories WHERE category_id IS NOT NULL)
```

### 4. Forgetting LIKE Wildcards
```sql
-- ‚ùå Exact match (same as =)
WHERE product_name LIKE 'MacBook'

-- ‚úÖ Pattern match
WHERE product_name LIKE '%MacBook%'
```

### 5. Case Sensitivity Assumptions
```sql
-- ‚ùå May miss matches in case-sensitive databases
WHERE email LIKE '%@gmail.com'  -- Won't match "@GMAIL.COM"

-- ‚úÖ Better
WHERE LOWER(email) LIKE '%@gmail.com'
```

---

## üèãÔ∏è Hands-On Exercises

### Exercise 1: Logical Operators
Write queries to find:
1. Customers from USA or Canada with account_balance > $5000
2. Products priced between $50 and $200 in category 'Electronics'
3. Orders placed in last 30 days with status NOT 'cancelled'

### Exercise 2: Pattern Matching
Write queries to find:
1. Customers with Gmail or Yahoo email addresses
2. Product codes matching pattern "PROD-XX-YYYY" (exactly)
3. Customers whose names contain "son" or "sen"

### Exercise 3: Complex Filtering
Write a query to find customers who:
- Are from USA, Canada, or UK
- Have either:
  - Account balance > $10,000 OR
  - Made an order in last 30 days worth > $1,000
- Have a valid email (contains @ and .)
- Status is 'active'

### Exercise 4: NULL Handling
1. Find all products with NULL descriptions
2. Find customers with either missing email OR missing phone
3. Count customers by whether they have email (with/without)

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-02-Solutions.sql`

---

## üìö Further Reading

- [PostgreSQL Pattern Matching](https://www.postgresql.org/docs/current/functions-matching.html)
- [SQL LIKE Operator](https://www.w3schools.com/sql/sql_like.asp)
- [Understanding SQL's Three-Valued Logic](https://modern-sql.com/concept/three-valued-logic)
- [SQL Logical Operators](https://mode.com/sql-tutorial/sql-logical-operators/)

---

## üìù Key Takeaways

1. **AND** requires all conditions to be TRUE; **OR** requires at least one
2. **Always use parentheses** when mixing AND/OR to make precedence explicit
3. **IN operator** cleanly handles multiple value matching
4. **BETWEEN** is inclusive on both ends (>= AND <=)
5. **LIKE** enables pattern matching with `%` (zero or more) and `_` (exactly one)
6. **NULL comparisons** require IS NULL / IS NOT NULL, never = or !=
7. **NOT IN with NULLs** can produce unexpected results - filter NULLs first
8. **Three-valued logic** (TRUE, FALSE, UNKNOWN) affects all NULL operations
9. Consider **case sensitivity** when doing text comparisons
10. Complex filters are easier to read with proper formatting and comments

---

## üîó Related Concepts

- [[02. SQL Basics - SELECT, WHERE, ORDER BY|Previous: Basic SQL Queries]]
- [[04. Aggregate Functions|Next: Aggregating Data]]
- [[13. Working with NULL Values|Advanced NULL Handling]]

---

## ‚úèÔ∏è Notes Section

**My Key Insights:**
-

**Tricky Scenarios Encountered:**
-

**Business Logic Patterns:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ‚úÖ Complete - Ready for study*
