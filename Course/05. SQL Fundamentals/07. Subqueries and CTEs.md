# 07. Subqueries and CTEs

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Writing modular, readable SQL using subqueries and Common Table Expressions (CTEs)

---

## 📋 Overview

As your SQL queries grow more complex, you'll need ways to break them into manageable, logical pieces. This is where subqueries and CTEs (Common Table Expressions) become essential tools in your data engineering toolkit.

A **subquery** is a SELECT statement nested inside another query, allowing you to use the result of one query as input to another. A **CTE** is a named temporary result set that exists only for the duration of a query, making complex SQL more readable and maintainable.

Both techniques enable you to write sophisticated analytical queries, perform multi-step data transformations, and solve problems that would be difficult or impossible with a single SELECT statement. They're fundamental to building data pipelines, creating analytical dashboards, and performing complex data analysis.

**Real-World Applications:**
- Data transformation pipelines: Step-by-step data cleaning and enrichment
- Complex filtering: Use aggregated results to filter raw data
- Analytical queries: Year-over-year comparisons, ranking, segmentation
- Hierarchical data: Organization charts, category trees, bill of materials
- Code organization: Break 300-line queries into readable components

---

## 🎯 Learning Objectives

After completing this subchapter, you will be able to:
- Write subqueries in SELECT, FROM, and WHERE clauses
- Use correlated vs uncorrelated subqueries appropriately
- Understand subquery performance implications
- Create single and multiple CTEs using WITH syntax
- Chain CTEs to build multi-step transformations
- Write recursive CTEs for hierarchical data
- Choose between subqueries, CTEs, and JOINs for different scenarios
- Debug and optimize complex queries with subqueries/CTEs
- Refactor monolithic queries into maintainable CTE pipelines
- Understand when to use MATERIALIZED hints for performance

---

## 📚 Core Concepts

### 1. Subqueries - Queries Within Queries

A subquery is a SELECT statement nested inside another query. The outer query uses the subquery's result for filtering, calculation, or as a data source.

#### Subquery Locations

Subqueries can appear in three main places:
1. **SELECT clause** - Calculate derived values
2. **FROM clause** - Create temporary tables
3. **WHERE clause** - Filter based on another query's results

---

### 2. Subqueries in WHERE Clause

The most common use: filter rows based on results from another query.

#### Single-Value Subquery

```sql
-- Find products more expensive than the average
SELECT
    product_name,
    price
FROM products
WHERE price > (
    SELECT AVG(price)
    FROM products
);
```

**How it works:**
1. Inner query calculates `AVG(price)` → returns single value (e.g., 127.50)
2. Outer query compares each product's price to that average
3. Returns products where `price > 127.50`

#### Multi-Value Subquery with IN

```sql
-- Find customers who placed orders in October 2024
SELECT
    customer_id,
    customer_name,
    email
FROM customers
WHERE customer_id IN (
    SELECT DISTINCT customer_id
    FROM orders
    WHERE order_date >= '2024-10-01'
      AND order_date < '2024-11-01'
);
```

**Key Operators for Multi-Value Subqueries:**
- `IN` - Value exists in subquery results
- `NOT IN` - Value does NOT exist in subquery results
- `ANY` / `SOME` - Comparison is true for at least one value
- `ALL` - Comparison is true for all values

#### Using ANY and ALL

```sql
-- Find products cheaper than ANY product in Electronics category
SELECT product_name, price
FROM products
WHERE price < ANY (
    SELECT price
    FROM products
    WHERE category = 'Electronics'
);

-- Find products cheaper than ALL products in Electronics category
WHERE price < ALL (...);  -- Must be cheaper than the cheapest Electronics product
```

---

### 3. Subqueries in FROM Clause

Use a subquery as a temporary table (also called a "derived table").

```sql
-- Calculate metrics on aggregated data
SELECT
    country,
    AVG(customer_count) AS avg_customers_per_city
FROM (
    -- Inner query: customers per city
    SELECT
        country,
        city,
        COUNT(*) AS customer_count
    FROM customers
    GROUP BY country, city
) AS city_stats
GROUP BY country;
```

**Pattern:**
1. Inner query creates temporary result set
2. Outer query treats it as a regular table
3. **Must provide alias** (`AS city_stats`)

#### Real-World Example: Top 10% of Customers

```sql
-- Find customers in the top 10% by spending
SELECT
    customer_id,
    customer_name,
    total_spent
FROM (
    SELECT
        c.customer_id,
        c.customer_name,
        SUM(o.total_amount) AS total_spent
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    GROUP BY c.customer_id, c.customer_name
) AS customer_spending
WHERE total_spent > (
    SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY total_spent)
    FROM (
        SELECT
            c.customer_id,
            SUM(o.total_amount) AS total_spent
        FROM customers c
        JOIN orders o ON c.customer_id = o.customer_id
        GROUP BY c.customer_id
    ) AS spending_distribution
);
```

---

### 4. Subqueries in SELECT Clause

Calculate derived values for each row.

```sql
-- Show each customer with their order count
SELECT
    customer_id,
    customer_name,
    (
        SELECT COUNT(*)
        FROM orders
        WHERE orders.customer_id = customers.customer_id
    ) AS order_count
FROM customers;
```

**Key Characteristic:** This is a **correlated subquery** - it references the outer query's table (`customers.customer_id`).

#### Correlated vs Uncorrelated Subqueries

**Uncorrelated (Independent):**
```sql
-- Runs once, returns single value
WHERE price > (SELECT AVG(price) FROM products)
```

**Correlated (Dependent):**
```sql
-- Runs once PER ROW of outer query
SELECT
    product_name,
    (SELECT AVG(price) FROM products p2
     WHERE p2.category = p1.category) AS category_avg_price
FROM products p1;
```

**Performance Impact:** Correlated subqueries can be slow on large datasets (runs N times for N rows). Consider JOINs or window functions instead.

---

### 5. Common Table Expressions (CTEs) - WITH Clause

CTEs provide a cleaner, more readable way to write complex queries by giving subqueries names.

#### Basic CTE Syntax

```sql
WITH cte_name AS (
    SELECT column1, column2
    FROM table_name
    WHERE condition
)
SELECT *
FROM cte_name;
```

**Equivalent to:**
```sql
SELECT *
FROM (
    SELECT column1, column2
    FROM table_name
    WHERE condition
) AS cte_name;
```

**Advantages of CTEs:**
- ✅ More readable (name describes purpose)
- ✅ Can reference earlier CTEs
- ✅ Easier to test individual components
- ✅ Better for code maintenance

---

### 6. Multiple CTEs - Chaining Logic

You can define multiple CTEs, with each one referencing previous CTEs.

```sql
WITH
  -- CTE 1: Filter recent orders
  recent_orders AS (
    SELECT *
    FROM orders
    WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
  ),

  -- CTE 2: Aggregate by customer (references recent_orders)
  customer_metrics AS (
    SELECT
        customer_id,
        COUNT(*) AS order_count,
        SUM(total_amount) AS total_spent,
        AVG(total_amount) AS avg_order_value
    FROM recent_orders
    GROUP BY customer_id
  ),

  -- CTE 3: Segment customers (references customer_metrics)
  customer_segments AS (
    SELECT
        *,
        CASE
            WHEN total_spent > 10000 THEN 'Premium'
            WHEN total_spent > 5000 THEN 'Gold'
            WHEN total_spent > 1000 THEN 'Silver'
            ELSE 'Bronze'
        END AS segment
    FROM customer_metrics
  )

-- Final query: Segment summary
SELECT
    segment,
    COUNT(*) AS customer_count,
    SUM(total_spent) AS segment_revenue,
    AVG(avg_order_value) AS segment_avg_order
FROM customer_segments
GROUP BY segment
ORDER BY segment_revenue DESC;
```

**Pattern:**
1. Each CTE is separated by comma (no comma after last CTE!)
2. Later CTEs can reference earlier ones
3. Final SELECT uses the CTEs like regular tables
4. Entire structure reads like a data pipeline

---

### 7. Recursive CTEs - Hierarchical Data

Recursive CTEs can reference themselves, enabling queries on tree structures (org charts, categories, graphs).

#### Syntax

```sql
WITH RECURSIVE cte_name AS (
    -- Base case (anchor member)
    SELECT ...

    UNION ALL

    -- Recursive case (recursive member)
    SELECT ...
    FROM cte_name  -- Self-reference!
    JOIN ...
)
SELECT * FROM cte_name;
```

#### Example: Employee Hierarchy

```sql
-- Build complete org chart from employees table
WITH RECURSIVE employee_hierarchy AS (
    -- Base case: Top-level employees (no manager)
    SELECT
        employee_id,
        name,
        manager_id,
        1 AS level,
        name AS path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: Employees with managers
    SELECT
        e.employee_id,
        e.name,
        e.manager_id,
        eh.level + 1,
        eh.path || ' > ' || e.name
    FROM employees e
    INNER JOIN employee_hierarchy eh
        ON e.manager_id = eh.employee_id
)
SELECT
    employee_id,
    name,
    level,
    path AS org_path
FROM employee_hierarchy
ORDER BY path;
```

**How It Works:**
1. **Base case** finds starting point (CEO, top categories, etc.)
2. **Recursive case** joins to find next level (direct reports, sub-categories)
3. Repeats until no more rows match
4. Returns UNION of all iterations

#### Example Result

```
employee_id | name    | level | org_path
------------|---------|-------|---------------------------
1           | Alice   | 1     | Alice
2           | Bob     | 2     | Alice > Bob
4           | Dave    | 3     | Alice > Bob > Dave
3           | Carol   | 2     | Alice > Carol
5           | Eve     | 3     | Alice > Carol > Eve
```

**Use Cases:**
- Organization charts
- Bill of materials (parts containing sub-parts)
- Category hierarchies
- Graph traversal
- Finding all descendants or ancestors

---

### 8. CTE Performance Considerations

#### Materialization

Some databases (PostgreSQL 12+, SQL Server) can materialize (cache) CTE results.

```sql
-- PostgreSQL: Force materialization
WITH MATERIALIZED orders_2024 AS (
    SELECT * FROM orders WHERE order_date >= '2024-01-01'
)
SELECT * FROM orders_2024;

-- PostgreSQL: Prevent materialization (inline CTE)
WITH NOT MATERIALIZED orders_2024 AS (...)
SELECT * FROM orders_2024;
```

**When to Materialize:**
- CTE is referenced multiple times
- CTE result is small but expensive to compute
- Testing shows materialization is faster

**When NOT to Materialize:**
- CTE is only referenced once
- Database optimizer can push filters down
- Result set is very large

#### Optimization Tips

```sql
-- ✅ Good: Filter early in CTEs
WITH recent_data AS (
    SELECT *
    FROM huge_table
    WHERE date_column >= '2024-01-01'  -- Reduce data volume early
)
SELECT * FROM recent_data WHERE ...;

-- ❌ Bad: Filter late
WITH all_data AS (
    SELECT * FROM huge_table  -- Loads all data!
)
SELECT * FROM all_data WHERE date_column >= '2024-01-01';
```

---

## 💡 Practical Examples

### Example 1: Finding Above-Average Performers

```sql
-- Customers who spent more than average
SELECT
    customer_id,
    customer_name,
    total_lifetime_value
FROM customers
WHERE total_lifetime_value > (
    SELECT AVG(total_lifetime_value)
    FROM customers
);
```

---

### Example 2: Top N Per Category

```sql
-- Top 3 products by revenue in each category
WITH product_revenue AS (
    SELECT
        p.product_id,
        p.product_name,
        p.category,
        SUM(oi.quantity * oi.price) AS total_revenue,
        ROW_NUMBER() OVER (
            PARTITION BY p.category
            ORDER BY SUM(oi.quantity * oi.price) DESC
        ) AS rank_in_category
    FROM products p
    JOIN order_items oi ON p.product_id = oi.product_id
    GROUP BY p.product_id, p.product_name, p.category
)
SELECT
    category,
    product_name,
    total_revenue,
    rank_in_category
FROM product_revenue
WHERE rank_in_category <= 3
ORDER BY category, rank_in_category;
```

---

### Example 3: Multi-Step Data Transformation

```sql
-- Calculate year-over-year revenue growth by category
WITH
  -- Step 1: Monthly revenue by category
  monthly_revenue AS (
    SELECT
        p.category,
        DATE_TRUNC('month', o.order_date) AS month,
        SUM(oi.quantity * oi.price) AS revenue
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE o.status = 'completed'
    GROUP BY p.category, DATE_TRUNC('month', o.order_date)
  ),

  -- Step 2: Add prior year revenue
  yoy_comparison AS (
    SELECT
        category,
        month,
        revenue AS current_revenue,
        LAG(revenue, 12) OVER (
            PARTITION BY category
            ORDER BY month
        ) AS prior_year_revenue
    FROM monthly_revenue
  )

-- Step 3: Calculate growth rate
SELECT
    category,
    month,
    current_revenue,
    prior_year_revenue,
    ROUND(
        100.0 * (current_revenue - prior_year_revenue) / prior_year_revenue,
        2
    ) AS yoy_growth_pct
FROM yoy_comparison
WHERE prior_year_revenue IS NOT NULL
ORDER BY category, month;
```

---

### Example 4: Recursive Category Tree

```sql
-- Find all subcategories under "Electronics"
WITH RECURSIVE category_tree AS (
    -- Base: Start with Electronics
    SELECT
        category_id,
        category_name,
        parent_category_id,
        1 AS depth,
        category_name AS path
    FROM categories
    WHERE category_name = 'Electronics'

    UNION ALL

    -- Recursive: Find subcategories
    SELECT
        c.category_id,
        c.category_name,
        c.parent_category_id,
        ct.depth + 1,
        ct.path || ' > ' || c.category_name
    FROM categories c
    INNER JOIN category_tree ct
        ON c.parent_category_id = ct.category_id
)
SELECT
    category_id,
    category_name,
    depth,
    path
FROM category_tree
ORDER BY path;
```

---

## 🔧 Code Examples

### Refactoring: Subquery → CTE

```sql
-- ❌ Hard to read: Nested subqueries
SELECT
    c.customer_name,
    c.total_spent
FROM (
    SELECT
        customer_id,
        customer_name,
        (
            SELECT SUM(total_amount)
            FROM orders
            WHERE orders.customer_id = customers.customer_id
        ) AS total_spent
    FROM customers
) AS c
WHERE c.total_spent > (
    SELECT AVG(total_spent)
    FROM (
        SELECT
            customer_id,
            (
                SELECT SUM(total_amount)
                FROM orders
                WHERE orders.customer_id = customers.customer_id
            ) AS total_spent
        FROM customers
    ) AS customer_spending
);

-- ✅ Much clearer: CTEs
WITH customer_spending AS (
    SELECT
        c.customer_id,
        c.customer_name,
        COALESCE(SUM(o.total_amount), 0) AS total_spent
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    GROUP BY c.customer_id, c.customer_name
),
spending_avg AS (
    SELECT AVG(total_spent) AS avg_spending
    FROM customer_spending
)
SELECT
    customer_name,
    total_spent
FROM customer_spending
CROSS JOIN spending_avg
WHERE total_spent > avg_spending;
```

---

## ✅ Best Practices

### 1. Use CTEs for Readability

```sql
-- ✅ Good: Clear, self-documenting
WITH high_value_customers AS (
    SELECT customer_id FROM customers WHERE lifetime_value > 10000
)
SELECT * FROM orders
WHERE customer_id IN (SELECT customer_id FROM high_value_customers);

-- ❌ Less clear: Unnamed subquery
SELECT * FROM orders
WHERE customer_id IN (
    SELECT customer_id FROM customers WHERE lifetime_value > 10000
);
```

### 2. Keep CTE Count Reasonable

```sql
-- ✅ Good: 3-5 focused CTEs
WITH step1 AS (...), step2 AS (...), step3 AS (...)
SELECT...;

-- ❌ Too many: Hard to follow
WITH cte1 AS (...), cte2 AS (...), cte3 AS (...),
     cte4 AS (...), cte5 AS (...), cte6 AS (...),
     cte7 AS (...), cte8 AS (...)  -- Too many!
```

### 3. Filter Early

```sql
-- ✅ Good: Filter in CTE
WITH recent_orders AS (
    SELECT * FROM orders WHERE order_date >= '2024-01-01'
)
SELECT * FROM recent_orders JOIN ...;

-- ❌ Bad: Load all data first
WITH all_orders AS (
    SELECT * FROM orders
)
SELECT * FROM all_orders WHERE order_date >= '2024-01-01' ...;
```

### 4. Use Descriptive CTE Names

```sql
-- ✅ Good: Describes purpose
WITH high_value_churned_customers AS (...)

-- ❌ Bad: Generic names
WITH temp1 AS (...), temp2 AS (...), temp3 AS (...)
```

### 5. Prefer CTEs Over Correlated Subqueries

```sql
-- ❌ Slow: Correlated subquery (runs for each row)
SELECT
    product_name,
    (SELECT AVG(price) FROM products p2
     WHERE p2.category = p1.category) AS category_avg
FROM products p1;

-- ✅ Faster: CTE + JOIN
WITH category_avg AS (
    SELECT category, AVG(price) AS avg_price
    FROM products
    GROUP BY category
)
SELECT
    p.product_name,
    ca.avg_price AS category_avg
FROM products p
JOIN category_avg ca ON p.category = ca.category;
```

---

## ⚠️ Common Pitfalls

### 1. NOT IN with NULLs

```sql
-- ❌ Dangerous: Returns no rows if subquery contains NULL
SELECT customer_name
FROM customers
WHERE customer_id NOT IN (
    SELECT customer_id FROM orders  -- If any NULL, entire query returns nothing!
);

-- ✅ Safe: Use NOT EXISTS
WHERE NOT EXISTS (
    SELECT 1 FROM orders WHERE orders.customer_id = customers.customer_id
);
```

### 2. Correlated Subquery Performance

```sql
-- ❌ Slow: Runs subquery for every row
SELECT
    product_name,
    (SELECT COUNT(*) FROM order_items
     WHERE order_items.product_id = products.product_id) AS times_ordered
FROM products;

-- ✅ Faster: JOIN or CTE
WITH order_counts AS (
    SELECT product_id, COUNT(*) AS times_ordered
    FROM order_items
    GROUP BY product_id
)
SELECT p.product_name, COALESCE(oc.times_ordered, 0)
FROM products p
LEFT JOIN order_counts oc ON p.product_id = oc.product_id;
```

### 3. Missing Alias for Derived Tables

```sql
-- ❌ Error: Every derived table must have alias
SELECT *
FROM (SELECT * FROM customers WHERE country = 'USA');

-- ✅ Fixed: Add alias
FROM (SELECT * FROM customers WHERE country = 'USA') AS us_customers;
```

### 4. Infinite Recursive CTEs

```sql
-- ❌ Can run forever if no termination condition
WITH RECURSIVE bad_recursion AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM bad_recursion  -- Never stops!
)
SELECT * FROM bad_recursion;

-- ✅ Add limit or termination condition
SELECT n + 1 FROM bad_recursion WHERE n < 100
```

### 5. Comma Placement in CTEs

```sql
-- ❌ Syntax error: Comma after last CTE
WITH
    cte1 AS (...),
    cte2 AS (...),  -- ← Remove this comma!
SELECT...;

-- ✅ Correct: No comma after last CTE
WITH
    cte1 AS (...),
    cte2 AS (...)
SELECT...;
```

---

## 🏋️ Hands-On Exercises

### Exercise 1: Basic Subqueries
Write queries using subqueries to:
1. Find products more expensive than the average price
2. Find customers who have never placed an order (use NOT IN)
3. Find the top 5 customers by total spending

### Exercise 2: Subquery in SELECT
Add a correlated subquery to show each customer with their total number of orders.

### Exercise 3: Multi-Level CTEs
Write a CTE pipeline to:
1. Filter orders from last 90 days
2. Calculate total revenue per customer
3. Segment customers into quartiles based on revenue
4. Show count and total revenue per quartile

### Exercise 4: Recursive CTE
Given a `categories` table with `category_id` and `parent_category_id`:
1. Write a recursive CTE to show the full category hierarchy
2. Calculate the depth of each category
3. Find all leaf categories (categories with no children)

### Exercise 5: Performance Comparison
Compare execution time of:
1. Correlated subquery in SELECT clause
2. JOIN with aggregation
3. CTE with JOIN

For finding each product's category average price on a large dataset.

### Exercise 6: Refactoring
Refactor this nested subquery mess into clean CTEs:
```sql
SELECT customer_name
FROM customers
WHERE customer_id IN (
    SELECT customer_id FROM orders
    WHERE total_amount > (
        SELECT AVG(total_amount) FROM orders
        WHERE customer_id IN (
            SELECT customer_id FROM customers WHERE country = 'USA'
        )
    )
);
```

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-07-Solutions.sql`

---

## 📚 Further Reading

### Official Documentation
- [PostgreSQL CTEs and Recursive Queries](https://www.postgresql.org/docs/current/queries-with.html)
- [MySQL Subqueries](https://dev.mysql.com/doc/refman/8.0/en/subqueries.html)
- [SQL Server Common Table Expressions](https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql)

### Tutorials
- [CTEs Tutorial (Mode Analytics)](https://mode.com/sql-tutorial/sql-cte/)
- [Understanding Recursive CTEs](https://www.essentialsql.com/introduction-common-table-expressions-ctes/)
- [When to Use CTEs vs Subqueries](https://www.sqlite.org/lang_with.html)

### Performance
- [CTE Materialization in PostgreSQL](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MATERIALIZED)
- [Optimizing Recursive Queries](https://explainextended.com/2009/09/24/with-recursive/)

---

## 📝 Key Takeaways

1. **Subqueries** are SELECT statements nested inside other queries (WHERE, FROM, SELECT clauses)
2. **CTEs** use WITH clause to create named temporary result sets
3. **Uncorrelated subqueries** run once; **correlated subqueries** run once per outer row
4. Use **IN, ANY, ALL** operators with multi-value subqueries
5. **NOT IN** with NULLs is dangerous; prefer NOT EXISTS
6. **Multiple CTEs** can reference earlier CTEs, building data pipelines
7. **Recursive CTEs** solve hierarchical data problems (org charts, categories)
8. CTEs are **more readable** than nested subqueries for complex queries
9. **MATERIALIZED** hints can improve CTE performance when used wisely
10. **Filter early** in CTEs to reduce data volume
11. Prefer **CTEs over correlated subqueries** for better performance
12. Keep CTE count under 5-7 for readability
13. Use **descriptive names** for CTEs (not temp1, temp2)
14. **Every derived table must have an alias**
15. CTEs exist only for the duration of a single query

---

## 🔗 Related Concepts

- [[06. JOINs - Combining Tables|Previous: JOINs]]
- [[08. Window Functions|Next: Analytical Window Functions]]
- [[04. Aggregate Functions|Related: Aggregation]]
- [[Resources/Legacy-Content/1. SQL/07. CTEs - Common Table Expressions|Original: CTE Notes]]

---

## ✏️ Notes Section

**My Key Insights:**
-

**CTE vs Subquery Decision Tree:**
-

**Recursive CTE Patterns:**
-

**Performance Observations:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ✅ Complete - Ready for study*
