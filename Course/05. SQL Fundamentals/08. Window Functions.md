# 08. Window Functions

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Advanced analytical functions for rankings, running calculations, and row-level comparisons

---

## üìã Overview

Window functions are one of the most powerful features in modern SQL, unlocking analytical capabilities that would be difficult or impossible with standard aggregations. Unlike GROUP BY which collapses rows, window functions let you perform calculations **across sets of rows while preserving every individual row** in your result set.

Think of window functions as performing calculations "through a sliding window" over your data. You can rank products within categories, calculate running totals over time, compare each row to previous or next rows, and compute moving averages - all without losing row-level detail.

This makes window functions indispensable for time-series analysis, financial calculations, business analytics, ranking queries, and data quality tasks. They're the foundation of modern analytical SQL and a must-have skill for data engineers working with analytical databases and data warehouses.

**Real-World Applications:**
- Dashboards: Top N products per category, year-over-year growth, running revenue totals
- Time-series analysis: Moving averages, cumulative metrics, period-over-period comparisons
- Data quality: Deduplication using ROW_NUMBER(), finding gaps in sequences
- Business analytics: Customer lifetime value, cohort analysis, percentile calculations
- Financial reporting: Running balances, portfolio returns, volatility metrics

---

## üéØ Learning Objectives

After completing this subchapter, you will be able to:
- Understand the fundamental difference between window functions and GROUP BY
- Use PARTITION BY to define calculation boundaries
- Apply ORDER BY within windows for sequential operations
- Write ranking functions (ROW_NUMBER, RANK, DENSE_RANK, NTILE)
- Calculate running totals and moving averages with aggregate window functions
- Use LAG() and LEAD() to access previous/next rows
- Apply FIRST_VALUE() and LAST_VALUE() for boundary values
- Define custom window frames with ROWS and RANGE
- Optimize window function performance with proper indexing
- Combine multiple window functions in a single query
- Choose appropriate window functions for business requirements

---

## üìö Core Concepts

### 1. Window Functions vs GROUP BY

The fundamental difference: GROUP BY **aggregates** rows (reducing output), while window functions **preserve** rows (same row count in output).

#### GROUP BY Example

```sql
-- Returns one row per category
SELECT
    category,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price
FROM products
GROUP BY category;

-- Result: 5 rows (one per category)
```

#### Window Function Example

```sql
-- Returns one row per product (preserves all rows)
SELECT
    product_id,
    product_name,
    category,
    price,
    AVG(price) OVER (PARTITION BY category) AS category_avg_price
FROM products;

-- Result: 1000 rows (all products, each with category average)
```

**When to Use Which:**
- **GROUP BY:** Need summary statistics, reducing data
- **Window Functions:** Need row-level detail WITH contextual calculations

---

### 2. Window Function Syntax

```sql
SELECT
    column1,
    column2,
    FUNCTION_NAME() OVER (
        PARTITION BY partition_column  -- Optional: Define groups
        ORDER BY order_column          -- Optional: Define order within groups
        ROWS/RANGE BETWEEN ... AND ... -- Optional: Define frame
    ) AS window_result
FROM table_name;
```

**Three Key Components:**

1. **PARTITION BY** - Divides data into groups (like GROUP BY, but doesn't collapse rows)
2. **ORDER BY** - Defines row order within each partition
3. **Window Frame** - Specifies which rows to include in calculation

---

### 3. PARTITION BY - Defining Groups

PARTITION BY divides result set into groups, and window functions calculate separately for each group.

```sql
-- Calculate average price per category
SELECT
    product_name,
    category,
    price,
    AVG(price) OVER (PARTITION BY category) AS category_avg
FROM products;
```

**Result:**
```
product_name | category     | price  | category_avg
-------------|--------------|--------|-------------
Laptop       | Electronics  | 1200   | 850.00
Mouse        | Electronics  | 25     | 850.00
Keyboard     | Electronics  | 75     | 850.00
Desk         | Furniture    | 300    | 250.00
Chair        | Furniture    | 200    | 250.00
```

**Without PARTITION BY:**
```sql
-- Calculates over ALL rows
AVG(price) OVER ()  -- Average across entire table
```

---

### 4. ORDER BY - Defining Sequence

ORDER BY within the OVER clause defines the order for sequential calculations (rankings, running totals, LAG/LEAD).

```sql
-- Running total of revenue by date
SELECT
    order_date,
    revenue,
    SUM(revenue) OVER (ORDER BY order_date) AS running_total
FROM daily_revenue;
```

**Result:**
```
order_date  | revenue | running_total
------------|---------|-------------
2024-01-01  | 1000    | 1000
2024-01-02  | 1500    | 2500
2024-01-03  | 1200    | 3700
```

---

## üìö Ranking Functions

### 1. ROW_NUMBER() - Sequential Numbering

Assigns a **unique** sequential integer to each row within a partition.

```sql
-- Rank products by price within each category
SELECT
    product_name,
    category,
    price,
    ROW_NUMBER() OVER (
        PARTITION BY category
        ORDER BY price DESC
    ) AS price_rank
FROM products;
```

**Result:**
```
product_name | category    | price | price_rank
-------------|-------------|-------|----------
Laptop       | Electronics | 1200  | 1
Tablet       | Electronics | 600   | 2
Mouse        | Electronics | 25    | 3
Desk         | Furniture   | 300   | 1
Chair        | Furniture   | 200   | 2
```

**Use Cases:**
- Deduplication (keep row_num = 1)
- Pagination (OFFSET/LIMIT alternative)
- Assigning unique IDs within groups

---

### 2. RANK() - Ranking with Gaps

Assigns ranks with **gaps** for ties. If two rows tie for rank 2, next rank is 4.

```sql
SELECT
    product_name,
    category,
    sales,
    RANK() OVER (
        PARTITION BY category
        ORDER BY sales DESC
    ) AS sales_rank
FROM product_sales;
```

**Result with Ties:**
```
product_name | category    | sales | sales_rank
-------------|-------------|-------|----------
Laptop       | Electronics | 1000  | 1
Tablet       | Electronics | 900   | 2
Mouse        | Electronics | 900   | 2   ‚Üê Tie
Keyboard     | Electronics | 800   | 4   ‚Üê Gap (skipped 3)
```

---

### 3. DENSE_RANK() - Ranking Without Gaps

Assigns ranks **without gaps**. If two rows tie for rank 2, next rank is 3.

```sql
SELECT
    product_name,
    category,
    sales,
    DENSE_RANK() OVER (
        PARTITION BY category
        ORDER BY sales DESC
    ) AS dense_rank
FROM product_sales;
```

**Result with Ties:**
```
product_name | category    | sales | dense_rank
-------------|-------------|-------|----------
Laptop       | Electronics | 1000  | 1
Tablet       | Electronics | 900   | 2
Mouse        | Electronics | 900   | 2   ‚Üê Tie
Keyboard     | Electronics | 800   | 3   ‚Üê No gap
```

**Comparison:**
| Function | Unique Values | Handles Ties | Gaps |
|----------|--------------|--------------|------|
| ROW_NUMBER() | ‚úì Always unique | Arbitrary order | No |
| RANK() | ‚úó Not unique | Same rank | Yes |
| DENSE_RANK() | ‚úó Not unique | Same rank | No |

---

### 4. NTILE(n) - Dividing into Buckets

Divides rows into **n approximately equal groups** (quartiles, quintiles, percentiles).

```sql
-- Segment customers into quartiles by spending
SELECT
    customer_name,
    total_spent,
    NTILE(4) OVER (ORDER BY total_spent DESC) AS spending_quartile
FROM customers;
```

**Result:**
```
customer_name | total_spent | spending_quartile
--------------|-------------|------------------
Alice         | 10000       | 1  ‚Üê Top 25%
Bob           | 9500        | 1
Carol         | 8000        | 2
Dave          | 7500        | 2
Eve           | 5000        | 3
...           | ...         | ...
```

**Use Cases:**
- Creating percentile buckets
- Customer segmentation
- A/B test group assignment
- Portfolio rebalancing

---

## üìö Aggregate Window Functions

Standard aggregate functions (SUM, AVG, COUNT, MIN, MAX) can be used as window functions.

### 1. Running Total (Cumulative Sum)

```sql
SELECT
    order_date,
    order_amount,
    SUM(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM orders;
```

**Result:**
```
order_date  | order_amount | running_total
------------|--------------|-------------
2024-01-01  | 100          | 100
2024-01-02  | 150          | 250
2024-01-03  | 200          | 450
```

---

### 2. Moving Average

```sql
-- 3-day moving average
SELECT
    order_date,
    order_amount,
    AVG(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS three_day_moving_avg
FROM daily_orders;
```

**Result:**
```
order_date  | order_amount | three_day_moving_avg
------------|--------------|---------------------
2024-01-01  | 100          | 100.00   (only 1 row)
2024-01-02  | 150          | 125.00   (avg of 100, 150)
2024-01-03  | 200          | 150.00   (avg of 100, 150, 200)
2024-01-04  | 180          | 176.67   (avg of 150, 200, 180)
```

---

### 3. Percentage of Total

```sql
-- Each product's percentage of category sales
SELECT
    product_name,
    category,
    sales,
    ROUND(
        100.0 * sales / SUM(sales) OVER (PARTITION BY category),
        2
    ) AS pct_of_category_sales
FROM product_sales;
```

---

### 4. Running Total with Reset

Calculate running total that resets for each partition.

```sql
-- Customer lifetime value (running total per customer)
SELECT
    customer_id,
    order_date,
    order_amount,
    SUM(order_amount) OVER (
        PARTITION BY customer_id
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS lifetime_value
FROM orders;
```

---

## üìö Value Access Functions

### 1. LAG() - Access Previous Row

Retrieve value from **n rows before** the current row.

```sql
SELECT
    order_date,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY order_date) AS previous_day_revenue,
    revenue - LAG(revenue, 1) OVER (ORDER BY order_date) AS day_over_day_change
FROM daily_revenue;
```

**Result:**
```
order_date  | revenue | previous_day_revenue | day_over_day_change
------------|---------|---------------------|--------------------
2024-01-01  | 1000    | NULL                | NULL
2024-01-02  | 1500    | 1000                | 500
2024-01-03  | 1200    | 1500                | -300
```

**Syntax:**
```sql
LAG(column, offset, default_value) OVER (ORDER BY ...)
```
- **column:** Column to retrieve
- **offset:** Number of rows back (default: 1)
- **default_value:** Value if no previous row (default: NULL)

---

### 2. LEAD() - Access Next Row

Retrieve value from **n rows ahead** of the current row.

```sql
SELECT
    order_date,
    revenue,
    LEAD(revenue, 1) OVER (ORDER BY order_date) AS next_day_revenue,
    LEAD(revenue, 1) OVER (ORDER BY order_date) - revenue AS expected_growth
FROM daily_revenue;
```

---

### 3. FIRST_VALUE() - First Value in Window

Returns the **first value** in the window frame.

```sql
-- Compare each salary to highest in department
SELECT
    employee_name,
    department,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS highest_dept_salary
FROM employees;
```

**‚ö†Ô∏è Important:** Always specify full frame (`UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`) to ensure you get the actual first value.

---

### 4. LAST_VALUE() - Last Value in Window

Returns the **last value** in the window frame.

```sql
SELECT
    order_date,
    order_amount,
    LAST_VALUE(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS most_recent_order
FROM orders;
```

**‚ö†Ô∏è Critical:** Default window frame only goes to CURRENT ROW, giving unexpected results. Always specify full frame for LAST_VALUE.

---

## üìö Window Frames

Window frames define **which rows relative to the current row** are included in the calculation.

### Frame Types

#### 1. ROWS - Physical Row Position

```sql
-- Current row only
ROWS BETWEEN CURRENT ROW AND CURRENT ROW

-- All previous rows + current row (running total)
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- 2 rows before to 1 row after (5-row window)
ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING

-- All rows in partition
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

#### 2. RANGE - Logical Value Range

```sql
-- All rows with same ORDER BY value
RANGE BETWEEN CURRENT ROW AND CURRENT ROW

-- Date range (7-day trailing window)
RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW

-- Value range (within $100)
RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING
```

### Frame Boundaries

| Boundary | Description |
|----------|-------------|
| `UNBOUNDED PRECEDING` | Start of partition |
| `n PRECEDING` | n rows/values before current row |
| `CURRENT ROW` | Current row |
| `n FOLLOWING` | n rows/values after current row |
| `UNBOUNDED FOLLOWING` | End of partition |

---

## üí° Practical Examples

### Example 1: Top 3 Per Category

```sql
-- Find top 3 products by revenue in each category
WITH ranked_products AS (
    SELECT
        product_name,
        category,
        SUM(quantity * price) AS revenue,
        ROW_NUMBER() OVER (
            PARTITION BY category
            ORDER BY SUM(quantity * price) DESC
        ) AS rank_in_category
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
    GROUP BY product_name, category
)
SELECT
    category,
    product_name,
    revenue,
    rank_in_category
FROM ranked_products
WHERE rank_in_category <= 3
ORDER BY category, rank_in_category;
```

---

### Example 2: Year-over-Year Growth

```sql
-- Calculate YoY revenue growth
WITH annual_revenue AS (
    SELECT
        EXTRACT(YEAR FROM order_date) AS year,
        SUM(total_amount) AS revenue
    FROM orders
    GROUP BY EXTRACT(YEAR FROM order_date)
)
SELECT
    year,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY year) AS prev_year_revenue,
    ROUND(
        100.0 * (revenue - LAG(revenue, 1) OVER (ORDER BY year))
        / LAG(revenue, 1) OVER (ORDER BY year),
        2
    ) AS yoy_growth_pct
FROM annual_revenue
ORDER BY year;
```

---

### Example 3: Deduplication with ROW_NUMBER

```sql
-- Keep only most recent record per customer
WITH ranked_records AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY customer_id
            ORDER BY updated_at DESC
        ) AS rn
    FROM customer_records
)
SELECT *
FROM ranked_records
WHERE rn = 1;
```

---

### Example 4: Moving Average for Smoothing

```sql
-- 7-day moving average to smooth daily volatility
SELECT
    order_date,
    daily_revenue,
    ROUND(
        AVG(daily_revenue) OVER (
            ORDER BY order_date
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS seven_day_moving_avg
FROM (
    SELECT
        order_date,
        SUM(total_amount) AS daily_revenue
    FROM orders
    GROUP BY order_date
) daily;
```

---

### Example 5: Percentile Segmentation

```sql
-- Segment customers into spending tiers
SELECT
    customer_id,
    customer_name,
    total_spent,
    NTILE(10) OVER (ORDER BY total_spent DESC) AS spending_decile,
    CASE
        WHEN NTILE(10) OVER (ORDER BY total_spent DESC) = 1 THEN 'Top 10%'
        WHEN NTILE(10) OVER (ORDER BY total_spent DESC) <= 3 THEN 'Top 30%'
        WHEN NTILE(10) OVER (ORDER BY total_spent DESC) <= 5 THEN 'Top 50%'
        ELSE 'Bottom 50%'
    END AS tier
FROM customer_summary;
```

---

## üîß Code Examples

### Reusing Window Specifications

```sql
-- Define window once, use multiple times
SELECT
    customer_id,
    order_date,
    order_amount,
    SUM(order_amount) OVER w AS running_total,
    AVG(order_amount) OVER w AS running_avg,
    COUNT(*) OVER w AS order_count,
    ROW_NUMBER() OVER w AS order_number
FROM orders
WINDOW w AS (
    PARTITION BY customer_id
    ORDER BY order_date
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
);
```

---

### Multiple Window Functions in One Query

```sql
SELECT
    product_name,
    category,
    sales,
    -- Rank within category
    RANK() OVER (PARTITION BY category ORDER BY sales DESC) AS category_rank,
    -- Rank overall
    RANK() OVER (ORDER BY sales DESC) AS overall_rank,
    -- Percentage of category total
    ROUND(100.0 * sales / SUM(sales) OVER (PARTITION BY category), 2) AS pct_of_category,
    -- Percentage of grand total
    ROUND(100.0 * sales / SUM(sales) OVER (), 2) AS pct_of_total,
    -- Quartile within category
    NTILE(4) OVER (PARTITION BY category ORDER BY sales DESC) AS category_quartile
FROM product_sales;
```

---

## ‚úÖ Best Practices

### 1. Always Specify ORDER BY for Ranking Functions

```sql
-- ‚úÖ Good: Deterministic ordering
ROW_NUMBER() OVER (PARTITION BY category ORDER BY product_id)

-- ‚ùå Bad: Non-deterministic results
ROW_NUMBER() OVER (PARTITION BY category)
```

### 2. Use Proper Frame for LAST_VALUE

```sql
-- ‚ùå Wrong: Default frame only goes to current row
LAST_VALUE(salary) OVER (ORDER BY hire_date)

-- ‚úÖ Correct: Specify full frame
LAST_VALUE(salary) OVER (
    ORDER BY hire_date
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

### 3. Index PARTITION BY and ORDER BY Columns

```sql
-- For optimal performance
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- Then window function runs efficiently
SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date)
```

### 4. Reuse Window Definitions

```sql
-- ‚úÖ Good: Define once
WINDOW w AS (PARTITION BY customer_id ORDER BY order_date)

-- ‚ùå Bad: Repeat definition
SUM(...) OVER (PARTITION BY customer_id ORDER BY order_date),
AVG(...) OVER (PARTITION BY customer_id ORDER BY order_date)
```

### 5. Use CTEs for Complex Window Logic

```sql
-- ‚úÖ Good: Readable, testable
WITH ranked AS (
    SELECT *, ROW_NUMBER() OVER (...) AS rn
    FROM table
)
SELECT * FROM ranked WHERE rn = 1;

-- ‚ùå Less clear: Subquery in WHERE
SELECT * FROM (
    SELECT *, ROW_NUMBER() OVER (...) AS rn FROM table
) WHERE rn = 1;
```

---

## ‚ö†Ô∏è Common Pitfalls

### 1. LAST_VALUE Default Frame

```sql
-- ‚ùå Returns current row value, not last in partition!
SELECT LAST_VALUE(amount) OVER (ORDER BY date)
FROM orders;

-- ‚úÖ Correct
SELECT LAST_VALUE(amount) OVER (
    ORDER BY date
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
```

### 2. Forgetting ORDER BY in Ranking

```sql
-- ‚ùå Non-deterministic: Row number changes on each run
SELECT ROW_NUMBER() OVER (PARTITION BY category)

-- ‚úÖ Deterministic
SELECT ROW_NUMBER() OVER (PARTITION BY category ORDER BY product_id)
```

### 3. Large Window Frames Hurting Performance

```sql
-- ‚ùå Slow: Processes 10,000 rows for each row
SELECT AVG(price) OVER (
    ORDER BY date
    ROWS BETWEEN 10000 PRECEDING AND CURRENT ROW
)

-- ‚úÖ Faster: Reasonable frame size
SELECT AVG(price) OVER (
    ORDER BY date
    ROWS BETWEEN 30 PRECEDING AND CURRENT ROW
)
```

### 4. Misunderstanding PARTITION BY Scope

```sql
-- ‚ùå Wrong assumption: This does NOT filter rows
SELECT * FROM products
WHERE price > AVG(price) OVER (PARTITION BY category);
-- Error: Window functions not allowed in WHERE

-- ‚úÖ Correct: Use subquery or CTE
WITH avg_prices AS (
    SELECT *, AVG(price) OVER (PARTITION BY category) AS category_avg
    FROM products
)
SELECT * FROM avg_prices WHERE price > category_avg;
```

### 5. NULL Handling in LAG/LEAD

```sql
-- ‚ùå NULL in first row might cause issues downstream
SELECT LAG(revenue) OVER (ORDER BY date) AS prev_revenue

-- ‚úÖ Provide default value
SELECT LAG(revenue, 1, 0) OVER (ORDER BY date) AS prev_revenue
```

---

## üèãÔ∏è Hands-On Exercises

### Exercise 1: Basic Ranking
For the `products` table, write queries to:
1. Rank products by price within each category (highest price = rank 1)
2. Assign row numbers to all products ordered by product_id
3. Divide products into quintiles based on price

### Exercise 2: Running Calculations
Using the `orders` table:
1. Calculate running total revenue by order date
2. Calculate 7-day moving average of daily revenue
3. Show each order with percentage of total revenue

### Exercise 3: Row Comparisons
Write queries to:
1. Show each day's revenue with previous day's revenue (use LAG)
2. Calculate day-over-day revenue change
3. Find the first and last order amount for each customer

### Exercise 4: Top N Per Group
Find top 5 customers by spending in each country.

### Exercise 5: Deduplication
Given a `user_logins` table with duplicate records per user, keep only the most recent login record for each user.

### Exercise 6: Advanced Analytics
Create a query that shows:
- Each product's sales rank within its category
- Percentage of category sales
- Sales difference from category average
- Quartile within category (using NTILE)

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-08-Solutions.sql`

---

## üìö Further Reading

### Official Documentation
- [PostgreSQL Window Functions](https://www.postgresql.org/docs/current/tutorial-window.html)
- [MySQL Window Functions](https://dev.mysql.com/doc/refman/8.0/en/window-functions.html)
- [SQL Server Window Functions](https://learn.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql)

### Tutorials
- [Window Functions Tutorial (Mode Analytics)](https://mode.com/sql-tutorial/sql-window-functions/)
- [The Definitive Guide to Window Functions](https://www.windowfunctions.com/)
- [Advanced Window Functions](https://www.postgresqltutorial.com/postgresql-window-function/)

### Performance
- [Optimizing Window Functions](https://www.crunchydata.com/blog/postgres-indexing-when-does-brin-win)
- [Window Function Performance Tuning](https://use-the-index-luke.com/sql/partial-results/window-functions)

---

## üìù Key Takeaways

1. **Window functions preserve row count** - Unlike GROUP BY, every input row appears in output
2. **Three components:** PARTITION BY (groups), ORDER BY (sequence), window frame (rows)
3. **Ranking functions:** ROW_NUMBER (unique), RANK (gaps for ties), DENSE_RANK (no gaps), NTILE (buckets)
4. **Aggregate window functions** enable running totals, moving averages, percentage of total
5. **LAG/LEAD** access previous/next rows for period-over-period comparisons
6. **FIRST_VALUE/LAST_VALUE** require proper frame specification (UNBOUNDED PRECEDING AND FOLLOWING)
7. **Window frames** define calculation scope: ROWS (physical), RANGE (logical)
8. **Performance:** Index PARTITION BY and ORDER BY columns
9. **Reuse window definitions** with WINDOW clause for cleaner code
10. **Common uses:** Rankings, running calculations, deduplication, time-series analysis
11. **Always specify ORDER BY** for ranking functions (deterministic results)
12. **Frame defaults** can cause unexpected behavior; be explicit
13. **More efficient than self-joins** for many analytical queries
14. **Cannot use in WHERE clause** - use subquery/CTE instead
15. **Essential for modern analytics** - core skill for data engineering

---

## üîó Related Concepts

- [[07. Subqueries and CTEs|Previous: Subqueries and CTEs]]
- [[09. CASE Statements and Conditional Logic|Next: Conditional Logic]]
- [[04. Aggregate Functions|Related: Aggregate Functions]]
- [[Resources/Legacy-Content/1. SQL/08. Window Functions - Advanced SQL Analytics|Original: Window Functions Notes]]

---

## ‚úèÔ∏è Notes Section

**My Key Insights:**
-

**Window Frame Patterns:**
-

**Performance Observations:**
-

**Real-World Use Cases:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ‚úÖ Complete - Ready for study*
