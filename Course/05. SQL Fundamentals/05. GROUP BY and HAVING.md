# 05. GROUP BY and HAVING

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Grouping data by dimensions and filtering aggregated results

---

## 📋 Overview

GROUP BY is where SQL becomes truly powerful for analytics. While aggregate functions give you summary statistics for entire tables, GROUP BY lets you calculate those statistics **for each group** of data - answering questions like "sales by region", "customers by country", or "average order value by month".

Think of GROUP BY as creating mini-tables for each unique value in your grouping column(s), then running aggregate functions on each mini-table separately. Combined with HAVING (which filters groups after aggregation), you can build sophisticated analytical queries.

This is the foundation of dimensional analytics, business intelligence dashboards, and nearly every report you'll create as a data engineer. Master GROUP BY and you can answer any "by category" question your business has.

**Real-World Applications:**
- Sales reporting: revenue by product category, region, or time period
- Customer analytics: user counts by signup month, country, or customer tier
- Performance monitoring: error rates by service, API endpoint latency by region
- Business KPIs: monthly active users, daily order counts, retention by cohort

---

## 🎯 Learning Objectives

After completing this subchapter, you will be able to:
- Use GROUP BY to partition data into groups for aggregate calculations
- Group by single and multiple columns
- Understand SQL query execution order (FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY)
- Use HAVING to filter groups based on aggregate conditions
- Differentiate between WHERE (filters rows) and HAVING (filters groups)
- Combine WHERE and HAVING in the same query for optimal performance
- Handle NULL values in GROUP BY
- Create multi-dimensional aggregations with multiple GROUP BY columns
- Build real-world analytical queries for business reporting

---

## 📚 Core Concepts

### 1. GROUP BY Fundamentals

GROUP BY partitions rows into groups based on unique values in one or more columns, then applies aggregate functions to each group.

#### Basic GROUP BY Syntax

```sql
SELECT
    column_to_group_by,
    AGGREGATE_FUNCTION(column_to_aggregate)
FROM table_name
GROUP BY column_to_group_by;
```

#### Example: Count Orders by Priority

```sql
-- How many orders do we have for each priority level?
SELECT
    order_priority,
    COUNT(*) AS num_orders
FROM orders
GROUP BY order_priority;
```

**Result:**
```
order_priority | num_orders
---------------+------------
HIGH           | 2847
MEDIUM         | 5691
LOW            | 3142
```

**What Happened:**
1. SQL groups all rows by unique `order_priority` values
2. For each group, it counts the rows
3. Returns one row per group

---

### 2. Query Execution Order (Critical to Understand!)

```sql
SELECT column, AGG(other_column)     -- 5. Select columns
FROM table                           -- 1. Get data from table
WHERE filter_condition               -- 2. Filter ROWS (before grouping)
GROUP BY column                      -- 3. Group rows
HAVING AGG(other_column) > value     -- 4. Filter GROUPS (after aggregation)
ORDER BY column                      -- 6. Sort results
LIMIT n;                             -- 7. Limit results
```

**Key Insight:** WHERE filters **rows before grouping**, HAVING filters **groups after aggregation**.

---

### 3. Grouping by Single Column

```sql
-- Total revenue by country
SELECT
    country,
    COUNT(*) AS num_customers,
    SUM(account_balance) AS total_balance,
    AVG(account_balance) AS avg_balance
FROM customers
GROUP BY country
ORDER BY total_balance DESC;
```

**Result:**
```
country | num_customers | total_balance | avg_balance
--------+---------------+---------------+-------------
USA     | 5420          | 24583920.50   | 4534.52
UK      | 3892          | 18293847.21   | 4700.31
Canada  | 2841          | 12847563.88   | 4521.08
```

---

### 4. Grouping by Multiple Columns

You can group by multiple columns to create multi-dimensional aggregations.

```sql
-- Sales by country AND customer segment
SELECT
    country,
    customer_segment,
    COUNT(*) AS num_customers,
    SUM(total_purchases) AS total_revenue,
    AVG(total_purchases) AS avg_revenue_per_customer
FROM customers
GROUP BY country, customer_segment
ORDER BY country, total_revenue DESC;
```

**Result:**
```
country | customer_segment | num_customers | total_revenue | avg_revenue_per_customer
--------+------------------+---------------+---------------+--------------------------
Canada  | Enterprise       | 142           | 2847593.45    | 20053.47
Canada  | Small Business   | 891           | 1594728.92    | 1790.04
Canada  | Individual       | 1808          | 8405241.51    | 4648.47
USA     | Enterprise       | 287           | 5847291.33    | 20373.69
USA     | Small Business   | 2103          | 8429384.72    | 4008.27
USA     | Individual       | 3030          | 10307244.45   | 3401.40
```

**Order Matters:** Grouping by (country, segment) is the same as (segment, country) in terms of results, but may affect performance and readability.

---

### 5. GROUP BY with Multiple Aggregates

```sql
-- Comprehensive product category analysis
SELECT
    category,
    COUNT(*) AS num_products,
    SUM(quantity_in_stock) AS total_inventory,
    AVG(price) AS avg_price,
    MIN(price) AS cheapest_product,
    MAX(price) AS most_expensive_product,
    SUM(price * quantity_in_stock) AS total_inventory_value
FROM products
GROUP BY category
ORDER BY total_inventory_value DESC;
```

---

### 6. WHERE vs HAVING

**WHERE:** Filters **individual rows BEFORE grouping**
**HAVING:** Filters **groups AFTER aggregation**

```sql
-- Example: High-value customer segments
SELECT
    country,
    customer_segment,
    COUNT(*) AS num_customers,
    AVG(total_purchases) AS avg_purchases
FROM customers
WHERE total_purchases > 0            -- WHERE: Filter rows BEFORE grouping
GROUP BY country, customer_segment
HAVING COUNT(*) >= 100               -- HAVING: Filter groups AFTER aggregation
   AND AVG(total_purchases) > 1000
ORDER BY avg_purchases DESC;
```

**Execution Flow:**
1. **WHERE:** Remove customers with $0 purchases (row filter)
2. **GROUP BY:** Group remaining customers by country and segment
3. **HAVING:** Remove groups with <100 customers OR avg purchases ≤ $1000 (group filter)
4. **SELECT:** Return the filtered groups
5. **ORDER BY:** Sort by average purchases

#### Visual Example

**Starting Data:**
```
customer_id | country | purchases
1           | USA     | 0
2           | USA     | 5000
3           | USA     | 3000
4           | Canada  | 0
5           | Canada  | 2000
```

**Query:**
```sql
SELECT country, COUNT(*), AVG(purchases)
FROM customers
WHERE purchases > 0              -- Removes rows 1, 4
GROUP BY country
HAVING AVG(purchases) > 2000;    -- Keeps only USA (avg = 4000)
```

**Result:**
```
country | count | avg
USA     | 2     | 4000
```

---

### 7. HAVING Clause Deep Dive

HAVING filters groups based on aggregate conditions.

#### Basic HAVING

```sql
-- Find countries with more than 1000 customers
SELECT
    country,
    COUNT(*) AS customer_count
FROM customers
GROUP BY country
HAVING COUNT(*) > 1000
ORDER BY customer_count DESC;
```

#### Multiple HAVING Conditions

```sql
-- High-volume, high-value markets
SELECT
    country,
    COUNT(*) AS num_customers,
    SUM(total_purchases) AS total_revenue,
    AVG(total_purchases) AS avg_revenue
FROM customers
GROUP BY country
HAVING COUNT(*) > 500              -- At least 500 customers
   AND SUM(total_purchases) > 1000000  -- At least $1M revenue
   AND AVG(total_purchases) > 1500     -- Average purchase > $1500
ORDER BY total_revenue DESC;
```

#### HAVING with Aggregate Aliases (Database-Dependent)

```sql
-- Some databases allow this (PostgreSQL, MySQL with HAVING):
SELECT
    category,
    COUNT(*) AS product_count,
    AVG(price) AS avg_price
FROM products
GROUP BY category
HAVING avg_price > 100;  -- Using alias from SELECT

-- Standard SQL (works everywhere):
HAVING AVG(price) > 100;  -- Repeat the aggregate function
```

---

### 8. NULL Values in GROUP BY

NULL values are grouped together as a single group.

```sql
-- Products grouped by category (including NULL)
SELECT
    category,
    COUNT(*) AS num_products
FROM products
GROUP BY category;
```

**Result:**
```
category      | num_products
--------------+--------------
Electronics   | 452
Clothing      | 387
Home & Garden | 294
NULL          | 67           -- Products with no category
```

**To exclude NULLs:**
```sql
SELECT
    category,
    COUNT(*) AS num_products
FROM products
WHERE category IS NOT NULL  -- Filter before grouping
GROUP BY category;
```

---

## 💡 Practical Examples

### Example 1: Monthly Sales Report

```sql
-- Sales metrics by month
SELECT
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS num_orders,
    COUNT(DISTINCT customer_id) AS unique_customers,
    SUM(total_amount) AS total_revenue,
    AVG(total_amount) AS avg_order_value,
    SUM(total_amount) / COUNT(DISTINCT customer_id) AS revenue_per_customer
FROM orders
WHERE status = 'completed'
  AND order_date >= '2024-01-01'
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;
```

**Result:**
```
month      | num_orders | unique_customers | total_revenue | avg_order_value | revenue_per_customer
-----------+------------+------------------+---------------+-----------------+----------------------
2024-01-01 | 3254       | 1892             | 1258392.48    | 386.74          | 665.19
2024-02-01 | 3102       | 1847             | 1194857.91    | 385.23          | 647.08
2024-03-01 | 3589       | 2103             | 1382947.55    | 385.36          | 657.51
```

---

### Example 2: Customer Segmentation

```sql
-- Segment customers by purchase behavior
SELECT
    CASE
        WHEN total_purchases >= 10000 THEN 'VIP'
        WHEN total_purchases >= 5000 THEN 'High Value'
        WHEN total_purchases >= 1000 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS customer_segment,
    COUNT(*) AS num_customers,
    SUM(total_purchases) AS segment_revenue,
    AVG(total_purchases) AS avg_customer_value,
    MIN(total_purchases) AS min_purchase,
    MAX(total_purchases) AS max_purchase
FROM customers
WHERE total_purchases > 0
GROUP BY
    CASE
        WHEN total_purchases >= 10000 THEN 'VIP'
        WHEN total_purchases >= 5000 THEN 'High Value'
        WHEN total_purchases >= 1000 THEN 'Medium Value'
        ELSE 'Low Value'
    END
ORDER BY
    CASE customer_segment
        WHEN 'VIP' THEN 1
        WHEN 'High Value' THEN 2
        WHEN 'Medium Value' THEN 3
        WHEN 'Low Value' THEN 4
    END;
```

---

### Example 3: Product Performance by Category

```sql
-- Find underperforming categories
SELECT
    category,
    COUNT(*) AS num_products,
    SUM(units_sold) AS total_units_sold,
    SUM(revenue) AS total_revenue,
    AVG(revenue) AS avg_revenue_per_product,
    SUM(revenue) / NULLIF(SUM(units_sold), 0) AS avg_price_per_unit
FROM product_sales
WHERE sale_date >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY category
HAVING SUM(units_sold) > 0  -- Exclude categories with no sales
ORDER BY total_revenue DESC;
```

---

## 🔧 Code Examples

### Example: E-Commerce Cohort Analysis

```sql
-- Customer cohorts by signup month
SELECT
    DATE_TRUNC('month', signup_date) AS cohort_month,
    COUNT(*) AS cohort_size,
    SUM(total_purchases) AS cohort_revenue,
    AVG(total_purchases) AS avg_ltv,
    COUNT(CASE WHEN total_purchases > 0 THEN 1 END) AS active_customers,
    ROUND(100.0 * COUNT(CASE WHEN total_purchases > 0 THEN 1 END) / COUNT(*), 2) AS activation_rate_pct
FROM customers
WHERE signup_date >= '2024-01-01'
GROUP BY DATE_TRUNC('month', signup_date)
HAVING COUNT(*) >= 100  -- Only cohorts with 100+ signups
ORDER BY cohort_month;
```

---

### Example: Regional Performance with Targets

```sql
-- Compare regional performance to targets
SELECT
    region,
    COUNT(DISTINCT sales_rep_id) AS num_reps,
    SUM(sales_amount) AS actual_sales,
    SUM(sales_target) AS total_target,
    ROUND(100.0 * SUM(sales_amount) / NULLIF(SUM(sales_target), 0), 2) AS target_achievement_pct,
    CASE
        WHEN SUM(sales_amount) >= SUM(sales_target) THEN 'Met Target'
        WHEN SUM(sales_amount) >= SUM(sales_target) * 0.9 THEN 'Close'
        ELSE 'Below Target'
    END AS performance_status
FROM sales_performance
WHERE quarter = 'Q3-2024'
GROUP BY region
HAVING SUM(sales_target) > 0
ORDER BY target_achievement_pct DESC;
```

---

## ✅ Best Practices

### 1. Use WHERE to Filter Before GROUP BY
```sql
-- ✅ Good: Filter early (better performance)
SELECT category, COUNT(*)
FROM products
WHERE price > 100  -- Reduces data before grouping
GROUP BY category;

-- ❌ Less efficient: Filtering after grouping
SELECT category, COUNT(*)
FROM products
GROUP BY category
HAVING AVG(price) > 100;  -- Only if you need aggregate filter
```

### 2. Include All Non-Aggregated Columns in GROUP BY
```sql
-- ✅ Good: All non-aggregate columns in GROUP BY
SELECT country, city, COUNT(*)
FROM customers
GROUP BY country, city;

-- ❌ Error: city not in GROUP BY
SELECT country, city, COUNT(*)
FROM customers
GROUP BY country;  -- SQL error in most databases
```

### 3. Use Meaningful Aliases
```sql
-- ✅ Good: Clear column names
SELECT
    category,
    COUNT(*) AS num_products,
    AVG(price) AS avg_price
FROM products
GROUP BY category;

-- ❌ Confusing: No aliases
SELECT category, COUNT(*), AVG(price)
FROM products
GROUP BY category;
```

### 4. Order Matters for Readability
```sql
-- ✅ Good: Most important dimension first
SELECT region, country, city, SUM(sales)
FROM transactions
GROUP BY region, country, city
ORDER BY region, country, city;

-- Produces hierarchical grouping that's easy to read
```

### 5. Comment Complex GROUP BY Logic
```sql
-- ✅ Good: Explain business logic
-- Group customers by lifetime value tier
-- VIP: $10k+, High: $5k-10k, Medium: $1k-5k, Low: <$1k
SELECT
    CASE
        WHEN total_purchases >= 10000 THEN 'VIP'
        ...
    END AS tier,
    COUNT(*) AS customers
FROM customers
GROUP BY ... ;
```

---

## ⚠️ Common Pitfalls

### 1. Forgetting to Include Columns in GROUP BY
```sql
-- ❌ Error: customer_name not in GROUP BY
SELECT customer_name, country, COUNT(*)
FROM customers
GROUP BY country;

-- ✅ Correct: Both columns in GROUP BY
SELECT customer_name, country, COUNT(*)
FROM customers
GROUP BY customer_name, country;
```

### 2. Using WHERE Instead of HAVING (or vice versa)
```sql
-- ❌ Wrong: Can't use aggregate in WHERE
SELECT category, COUNT(*)
FROM products
WHERE COUNT(*) > 10  -- Error!
GROUP BY category;

-- ✅ Correct: Use HAVING for aggregates
SELECT category, COUNT(*)
FROM products
GROUP BY category
HAVING COUNT(*) > 10;
```

### 3. Filtering After GROUP BY When Before Would Be Faster
```sql
-- ❌ Inefficient: Groups all data, then filters
SELECT category, COUNT(*)
FROM products
GROUP BY category
HAVING category IN ('Electronics', 'Computers');

-- ✅ Better: Filter before grouping
SELECT category, COUNT(*)
FROM products
WHERE category IN ('Electronics', 'Computers')
GROUP BY category;
```

### 4. Mixing Aggregate and Non-Aggregate Without GROUP BY
```sql
-- ❌ Error: Mixing aggregates with non-aggregates
SELECT customer_name, COUNT(*)
FROM customers;

-- ✅ Either aggregate all:
SELECT COUNT(*)
FROM customers;

-- ✅ Or group by non-aggregates:
SELECT customer_name, COUNT(*)
FROM customers
GROUP BY customer_name;
```

### 5. NULLs in GROUP BY Surprise
```sql
-- Be aware NULL is a group!
SELECT category, COUNT(*)
FROM products
GROUP BY category;
-- Includes a row for category = NULL

-- To exclude NULLs:
WHERE category IS NOT NULL
```

---

## 🏋️ Hands-On Exercises

### Exercise 1: Basic GROUP BY
1. Count orders by order status
2. Sum revenue by product category
3. Find average order value by customer segment

### Exercise 2: Multi-Column GROUP BY
1. Count customers by country and city
2. Sum sales by region and quarter
3. Average product price by category and brand

### Exercise 3: WHERE vs HAVING
Write queries to find:
1. Categories with more than 100 products (use HAVING)
2. Revenue by month for completed orders only (use WHERE)
3. Countries with average customer balance > $5000 and at least 50 customers (use both)

### Exercise 4: Real-World Scenario
Create a monthly sales dashboard showing:
- Month
- Number of orders
- Unique customers
- Total revenue
- Average order value
- Revenue per customer

Filter to show only months with:
- At least 100 orders
- Revenue > $50,000

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-04-Solutions.sql`

---

## 📚 Further Reading

- [PostgreSQL GROUP BY](https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY)
- [SQL GROUP BY Tutorial (Mode)](https://mode.com/sql-tutorial/sql-group-by/)
- [Understanding GROUP BY (Essential SQL)](https://www.essentialsql.com/get-ready-to-learn-sql-server-20-using-group-by-with-aggregates/)

---

## 📝 Key Takeaways

1. **GROUP BY** partitions data into groups and applies aggregates to each group
2. **Query execution order:** FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
3. **WHERE** filters rows BEFORE grouping (more efficient when possible)
4. **HAVING** filters groups AFTER aggregation (use for aggregate conditions)
5. **All non-aggregated SELECT columns must be in GROUP BY**
6. **Multiple GROUP BY columns** create multi-dimensional aggregations
7. **NULL values form their own group** in GROUP BY
8. **Filter early with WHERE** for better performance
9. **Use meaningful aliases** for aggregate columns
10. **ORDER BY** can reference GROUP BY columns or aggregates

---

## 🔗 Related Concepts

- [[04. Aggregate Functions|Previous: Aggregate Functions]]
- [[06. JOINs - Combining Tables|Next: Combining Data from Multiple Tables]]
- [[08. Window Functions|Advanced: Row-Level Aggregates Without Grouping]]

---

## ✏️ Notes Section

**My Key Insights:**
-

**WHERE vs HAVING Patterns:**
-

**Common Grouping Scenarios:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ✅ Complete - Ready for study*
