# 10. Set Operations

**Chapter:** SQL Fundamentals & Relational Databases
**Topic:** Combining query results using UNION, INTERSECT, and EXCEPT

---

## üìã Overview

Set operations allow you to combine results from multiple SELECT statements, treating query results as mathematical sets. Just as you learned set theory in mathematics (union, intersection, difference), SQL provides equivalent operations to merge, compare, and contrast data from different queries.

These operations are essential when you need to combine data from multiple tables with similar structures, compare datasets to find common or unique records, or consolidate results from different data sources. They're particularly useful in data migrations, reconciliations, deduplication, and building comprehensive reports from disparate sources.

Understanding set operations gives you powerful tools for data analysis: finding customers who exist in both systems, identifying orphaned records, combining historical and current data, and generating complex reports that pull from multiple tables or databases.

**Real-World Applications:**
- Data migration: Combine customer data from old and new systems
- Reconciliation: Find records that exist in one system but not another
- Deduplication: Identify and remove duplicate records across tables
- Reporting: Consolidate results from multiple queries into single result set
- Data quality: Find orphaned records, missing relationships, data inconsistencies

---

## üéØ Learning Objectives

After completing this subchapter, you will be able to:
- Understand set theory concepts as applied to SQL queries
- Use UNION to combine results from multiple queries
- Distinguish between UNION and UNION ALL for different scenarios
- Apply INTERSECT to find common records between datasets
- Use EXCEPT/MINUS to find records in one set but not another
- Combine set operations with ORDER BY and LIMIT
- Understand column compatibility requirements for set operations
- Choose appropriate set operations for business requirements
- Optimize set operation queries for performance
- Debug common set operation errors and issues

---

## üìö Core Concepts

### 1. Set Theory Basics

SQL set operations are based on mathematical set theory:

```
Set A: {1, 2, 3, 4}
Set B: {3, 4, 5, 6}

UNION (A ‚à™ B):         {1, 2, 3, 4, 5, 6}  ‚Üê All unique elements
INTERSECT (A ‚à© B):     {3, 4}              ‚Üê Common elements
EXCEPT/MINUS (A - B):  {1, 2}              ‚Üê In A but not B
```

**Key Principles:**
- Sets contain **unique elements** (no duplicates)
- Order doesn't matter in pure sets
- Set operations return **unique rows** by default (except UNION ALL)

---

### 2. Column Compatibility Rules

All set operations require queries to have:

1. **Same number of columns**
2. **Compatible data types** in corresponding positions
3. **Column names from first SELECT** (subsequent names ignored)

```sql
-- ‚úÖ Compatible: Same column count and types
SELECT customer_id, customer_name FROM customers  -- 2 columns: INT, VARCHAR
UNION
SELECT supplier_id, supplier_name FROM suppliers; -- 2 columns: INT, VARCHAR

-- ‚ùå Error: Different column counts
SELECT customer_id, customer_name FROM customers  -- 2 columns
UNION
SELECT supplier_id FROM suppliers;                 -- 1 column

-- ‚ùå Error: Incompatible data types
SELECT customer_id, customer_name FROM customers  -- INT, VARCHAR
UNION
SELECT customer_name, customer_id FROM customers; -- VARCHAR, INT (wrong order!)
```

---

## üìö UNION and UNION ALL

### 1. UNION - Combine and Remove Duplicates

UNION combines results from multiple SELECT statements and **removes duplicate rows**.

#### Syntax

```sql
SELECT column1, column2 FROM table1
UNION
SELECT column1, column2 FROM table2;
```

#### Example: Combine Customers and Suppliers

```sql
-- Get all email addresses from both customers and suppliers
SELECT email, 'Customer' AS source
FROM customers
UNION
SELECT email, 'Supplier' AS source
FROM suppliers
ORDER BY email;
```

**Result:**
```
email                  | source
-----------------------|----------
alice@example.com      | Customer
bob@supplier.com       | Supplier
carol@example.com      | Customer
dave@supplier.com      | Supplier
```

**What Happened:**
- Combined results from both queries
- Removed duplicates (if same email existed in both tables)
- Sorted by email (ORDER BY applies to final result)

---

### 2. UNION ALL - Combine Keeping Duplicates

UNION ALL combines results **without removing duplicates** - faster than UNION.

```sql
SELECT email FROM customers
UNION ALL
SELECT email FROM suppliers;
```

**Result:**
```
email
-----------------------
alice@example.com
bob@example.com
carol@example.com      ‚Üê from customers
alice@example.com      ‚Üê Duplicate from suppliers
dave@supplier.com
```

**Performance:** UNION ALL is **significantly faster** than UNION because it doesn't need to eliminate duplicates.

---

### 3. UNION vs UNION ALL - When to Use Which

| Scenario | Use | Reason |
|----------|-----|--------|
| Combining mutually exclusive data (current + historical) | UNION ALL | No duplicates possible, avoid overhead |
| Combining data that might overlap | UNION | Need unique results |
| Building lists for IN clause | UNION | Want unique values |
| Appending tables for bulk operations | UNION ALL | Keep all rows, faster |
| Counting total records from multiple sources | UNION ALL | Count includes duplicates |

```sql
-- ‚úÖ Good: UNION ALL for partitioned data (no overlap)
SELECT * FROM orders_2023
UNION ALL
SELECT * FROM orders_2024;  -- No duplicates possible

-- ‚úÖ Good: UNION when overlap exists
SELECT customer_id FROM vip_customers
UNION
SELECT customer_id FROM loyalty_program_customers;  -- Same customer might be in both

-- ‚ùå Slower: UNION when UNION ALL would work
SELECT * FROM orders_2023
UNION  -- Unnecessary duplicate check!
SELECT * FROM orders_2024;
```

---

### 4. Multiple UNION Operations

You can chain multiple UNION operations.

```sql
-- Combine data from three sources
SELECT product_id, product_name, 'Store A' AS location
FROM store_a_products
UNION ALL
SELECT product_id, product_name, 'Store B' AS location
FROM store_b_products
UNION ALL
SELECT product_id, product_name, 'Store C' AS location
FROM store_c_products
ORDER BY product_name;
```

**Evaluation:** Set operations are evaluated **left to right** unless parentheses are used.

---

## üìö INTERSECT - Find Common Records

INTERSECT returns **only rows that appear in both** query results.

### Syntax

```sql
SELECT column1, column2 FROM table1
INTERSECT
SELECT column1, column2 FROM table2;
```

### Example: Find Customers Who Are Also Suppliers

```sql
-- Find email addresses that exist in both tables
SELECT email FROM customers
INTERSECT
SELECT email FROM suppliers;
```

**Result:**
```
email
-----------------------
alice@example.com  ‚Üê Exists in both customers and suppliers
```

**Use Cases:**
- Find customers who made purchases in both 2023 and 2024
- Identify products available in both warehouses
- Find users who have both email and phone verified

---

### Alternative: JOIN-Based INTERSECT

INTERSECT can often be replaced with INNER JOIN or EXISTS.

```sql
-- Using INTERSECT
SELECT email FROM customers
INTERSECT
SELECT email FROM suppliers;

-- Equivalent using INNER JOIN
SELECT DISTINCT c.email
FROM customers c
INNER JOIN suppliers s ON c.email = s.email;

-- Equivalent using EXISTS
SELECT DISTINCT email
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM suppliers s WHERE s.email = c.email
);
```

**Performance:** JOIN/EXISTS is often faster; use EXPLAIN to compare.

---

## üìö EXCEPT (MINUS in Oracle) - Find Differences

EXCEPT returns rows from the **first query that don't appear in the second query**.

### Syntax

```sql
-- PostgreSQL, SQL Server, BigQuery
SELECT column1, column2 FROM table1
EXCEPT
SELECT column1, column2 FROM table2;

-- Oracle
SELECT column1, column2 FROM table1
MINUS
SELECT column1, column2 FROM table2;
```

### Example: Find Customers Without Orders

```sql
-- Customers who have never placed an order
SELECT customer_id, customer_name FROM customers
EXCEPT
SELECT customer_id, customer_name FROM (
    SELECT DISTINCT customer_id, customer_name
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
);
```

**Result:**
```
customer_id | customer_name
------------|-------------
5           | Eve
12          | Frank
```

**Use Cases:**
- Find products never ordered
- Identify orphaned records
- Data quality checks (records in staging but not production)
- Find customers who churned (active in Jan, not active in Feb)

---

### EXCEPT Alternative: LEFT JOIN + IS NULL

```sql
-- Using EXCEPT
SELECT email FROM customers
EXCEPT
SELECT email FROM newsletter_subscribers;

-- Equivalent using LEFT JOIN
SELECT c.email
FROM customers c
LEFT JOIN newsletter_subscribers ns ON c.email = ns.email
WHERE ns.email IS NULL;

-- Equivalent using NOT EXISTS
SELECT email
FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM newsletter_subscribers ns WHERE ns.email = c.email
);
```

---

## üí° Practical Examples

### Example 1: Combine Current and Archived Data

```sql
-- Get all orders (current + archived)
SELECT
    order_id,
    customer_id,
    order_date,
    total_amount,
    'active' AS status
FROM orders
UNION ALL
SELECT
    order_id,
    customer_id,
    order_date,
    total_amount,
    'archived' AS status
FROM archived_orders
ORDER BY order_date DESC;
```

---

### Example 2: Find Customers Active in Both Periods

```sql
-- Customers who purchased in both Q1 and Q2 2024
SELECT DISTINCT customer_id
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31'

INTERSECT

SELECT DISTINCT customer_id
FROM orders
WHERE order_date BETWEEN '2024-04-01' AND '2024-06-30';
```

---

### Example 3: Data Reconciliation

```sql
-- Find records in staging but not in production
SELECT product_id, product_name, price
FROM staging.products
EXCEPT
SELECT product_id, product_name, price
FROM production.products;
```

**Use Case:** Identify new products to be promoted to production.

---

### Example 4: Consolidate Contact Information

```sql
-- Build complete contact list from multiple sources
SELECT
    email AS contact,
    'email' AS contact_type,
    customer_name AS name
FROM customers
WHERE email IS NOT NULL

UNION

SELECT
    phone AS contact,
    'phone' AS contact_type,
    customer_name AS name
FROM customers
WHERE phone IS NOT NULL

UNION

SELECT
    social_media_handle AS contact,
    'social' AS contact_type,
    customer_name AS name
FROM customer_social
WHERE social_media_handle IS NOT NULL

ORDER BY name, contact_type;
```

---

### Example 5: Find Churned Customers

```sql
-- Customers active in Q1 but not in Q2
SELECT DISTINCT customer_id
FROM orders
WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31'

EXCEPT

SELECT DISTINCT customer_id
FROM orders
WHERE order_date BETWEEN '2024-04-01' AND '2024-06-30';
```

---

## üîß Code Examples

### Complex Set Operations with Subqueries

```sql
-- Find high-value customers who bought in both electronics and furniture
WITH electronics_customers AS (
    SELECT DISTINCT customer_id
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE p.category = 'Electronics'
      AND o.total_amount > 500
),
furniture_customers AS (
    SELECT DISTINCT customer_id
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE p.category = 'Furniture'
      AND o.total_amount > 500
)
SELECT
    c.customer_id,
    c.customer_name,
    c.email
FROM customers c
WHERE customer_id IN (
    SELECT customer_id FROM electronics_customers
    INTERSECT
    SELECT customer_id FROM furniture_customers
)
ORDER BY c.customer_name;
```

---

### Combining Set Operations

```sql
-- Complex logic: (A UNION B) EXCEPT C
(
    SELECT employee_id FROM department_a_employees
    UNION
    SELECT employee_id FROM department_b_employees
)
EXCEPT
SELECT employee_id FROM terminated_employees
ORDER BY employee_id;
```

---

## ‚úÖ Best Practices

### 1. Use UNION ALL When Possible

```sql
-- ‚úÖ Good: No duplicates possible, use UNION ALL
SELECT * FROM orders_2023
UNION ALL
SELECT * FROM orders_2024;

-- ‚ùå Slower: Unnecessary duplicate elimination
SELECT * FROM orders_2023
UNION
SELECT * FROM orders_2024;
```

### 2. Column Names from First SELECT

```sql
-- ‚úÖ Good: Descriptive names in first SELECT
SELECT customer_id AS id, customer_name AS name FROM customers
UNION ALL
SELECT supplier_id, supplier_name FROM suppliers;  -- These names ignored

-- Result columns named: id, name
```

### 3. Add Source Indicators

```sql
-- ‚úÖ Good: Track data source
SELECT *, 'customers' AS source FROM customers
UNION ALL
SELECT *, 'suppliers' AS source FROM suppliers;
```

### 4. Use Parentheses for Complex Operations

```sql
-- ‚úÖ Good: Clear precedence
(SELECT * FROM table_a UNION SELECT * FROM table_b)
EXCEPT
SELECT * FROM table_c;

-- ‚ùå Ambiguous
SELECT * FROM table_a UNION SELECT * FROM table_b EXCEPT SELECT * FROM table_c;
```

### 5. Apply ORDER BY Only Once (at End)

```sql
-- ‚úÖ Good: ORDER BY on final result
SELECT name FROM customers
UNION
SELECT name FROM suppliers
ORDER BY name;  -- Sorts combined result

-- ‚ùå Wrong: ORDER BY in subquery has no effect
(SELECT name FROM customers ORDER BY name)  -- Ignored!
UNION
(SELECT name FROM suppliers ORDER BY name)  -- Ignored!
ORDER BY name;  -- This is the only ORDER BY that matters
```

---

## ‚ö†Ô∏è Common Pitfalls

### 1. Column Count Mismatch

```sql
-- ‚ùå Error: Different column counts
SELECT customer_id, customer_name FROM customers
UNION
SELECT supplier_id FROM suppliers;  -- Only 1 column!

-- ‚úÖ Fixed: Add placeholder column
SELECT customer_id, customer_name FROM customers
UNION
SELECT supplier_id, NULL AS supplier_name FROM suppliers;
```

### 2. Data Type Incompatibility

```sql
-- ‚ùå Error: INT vs VARCHAR
SELECT customer_id, total_spent FROM customers  -- INT, DECIMAL
UNION
SELECT customer_name, email FROM customers;     -- VARCHAR, VARCHAR

-- ‚úÖ Fixed: Cast to compatible types
SELECT CAST(customer_id AS VARCHAR), CAST(total_spent AS VARCHAR)
FROM customers
UNION
SELECT customer_name, email FROM customers;
```

### 3. Using UNION When UNION ALL Is Faster

```sql
-- ‚ùå Slow: UNION with mutually exclusive data
SELECT * FROM january_sales    -- No overlap
UNION
SELECT * FROM february_sales;  -- Unnecessary deduplication!

-- ‚úÖ Faster: UNION ALL
SELECT * FROM january_sales
UNION ALL
SELECT * FROM february_sales;
```

### 4. Forgetting DISTINCT in Subqueries

```sql
-- ‚ùå Wrong: Duplicates in subquery affect EXCEPT
SELECT customer_id FROM orders  -- customer_id appears multiple times!
EXCEPT
SELECT customer_id FROM archived_customers;

-- ‚úÖ Correct: Use DISTINCT
SELECT DISTINCT customer_id FROM orders
EXCEPT
SELECT customer_id FROM archived_customers;
```

### 5. ORDER BY in Wrong Place

```sql
-- ‚ùå Error: ORDER BY inside subquery ignored
(SELECT * FROM customers ORDER BY name)
UNION
(SELECT * FROM suppliers ORDER BY name);

-- ‚úÖ Correct: ORDER BY at end
SELECT * FROM customers
UNION
SELECT * FROM suppliers
ORDER BY name;
```

---

## üèãÔ∏è Hands-On Exercises

### Exercise 1: Basic UNION
Combine data from `customers` and `suppliers` tables to create a single contact list with columns: name, email, contact_type.

### Exercise 2: UNION vs UNION ALL
Compare performance of UNION vs UNION ALL when combining 5 years of order data (orders_2020 through orders_2024).

### Exercise 3: INTERSECT
Find products that were ordered in both January 2024 and July 2024.

### Exercise 4: EXCEPT for Churn Analysis
Identify customers who:
- Made purchases in Q1 2024
- Did NOT make purchases in Q2 2024
- Were not marked as inactive

### Exercise 5: Complex Set Operations
Find customers who:
1. Purchased from category "Electronics" OR "Computers"
2. AND have purchased in both 2023 and 2024
3. BUT have not purchased in the last 30 days

### Exercise 6: Data Reconciliation
Compare `staging.products` and `production.products`:
1. Find products in staging but not production (new products)
2. Find products in production but not staging (removed products)
3. Find products in both with different prices

**Solutions:** Available in `Exercises/Chapter-05/Solutions/Exercise-10-Solutions.sql`

---

## üìö Further Reading

### Official Documentation
- [PostgreSQL Set Operations](https://www.postgresql.org/docs/current/queries-union.html)
- [MySQL UNION](https://dev.mysql.com/doc/refman/8.0/en/union.html)
- [SQL Server Set Operators](https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-union-transact-sql)

### Tutorials
- [SQL Set Operations Tutorial (Mode)](https://mode.com/sql-tutorial/sql-union/)
- [Understanding UNION, INTERSECT, EXCEPT](https://www.essentialsql.com/sql-union/)
- [Set Operations Performance](https://use-the-index-luke.com/sql/partial-results/union)

---

## üìù Key Takeaways

1. **Set operations combine results** from multiple SELECT statements
2. **Column compatibility required:** same count, compatible types
3. **UNION** removes duplicates; **UNION ALL** keeps duplicates (faster)
4. **INTERSECT** finds common records between queries
5. **EXCEPT/MINUS** finds records in first query but not second
6. **Column names from first SELECT** used in result
7. **ORDER BY applies to final result** only (not individual subqueries)
8. **Use UNION ALL when possible** for better performance
9. **Add source indicators** when combining from multiple tables
10. **Parentheses control precedence** in complex set operations
11. **UNION ALL is significantly faster** than UNION (no deduplication overhead)
12. **Alternative approaches:** JOIN, EXISTS, NOT EXISTS often faster than INTERSECT/EXCEPT
13. **Use DISTINCT in subqueries** when needed for correct results
14. **Set operations evaluated left-to-right** unless parentheses used
15. **Essential for data reconciliation** migrations, and combining disparate sources

---

## üîó Related Concepts

- [[09. CASE Statements and Conditional Logic|Previous: CASE Statements]]
- [[11. String Functions and Pattern Matching|Next: String Functions]]
- [[06. JOINs - Combining Tables|Related: JOINs]]
- [[07. Subqueries and CTEs|Related: Subqueries]]

---

## ‚úèÔ∏è Notes Section

**My Key Insights:**
-

**Set Operation Use Cases:**
-

**Performance Observations:**
-

---

*Created: October 21, 2025*
*Last Updated: October 21, 2025*
*Status: ‚úÖ Complete - Ready for study*
