---
title: dbt Project Structure & Configuration
date: 2025-10-17
tags: [dbt, project-structure, configuration, sources, seeds, macros, packages, data-engineering]
status: active
learning_phase: "Foundation (Basics)"
source: https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview
---

**Created:** 2025-10-17
**Last Updated:** 2025-10-17
**Status:** ✅ Complete

---

## Overview

A well-structured dbt project is essential for maintainability, collaboration, and scale. This chapter covers how to organize models, configure projects, define sources, manage seeds, create macros, and use packages effectively.

**Key Principle:** Structure follows function. Organize your project to mirror the flow of data from raw sources through staging to final marts.

---

## 2.1 Standard dbt Project Structure

### Complete Project Layout

```
my_dbt_project/
├── dbt_project.yml          # Project configuration
├── packages.yml              # Package dependencies
├── profiles.yml              # Connection profiles (not in Git!)
├── README.md                 # Project documentation
├── .gitignore               # Git ignore patterns
│
├── models/                   # SQL transformation files
│   ├── staging/             # Source-aligned models
│   │   ├── stg_customers.sql
│   │   ├── stg_orders.sql
│   │   └── sources.yml      # Source definitions
│   │
│   ├── intermediate/        # Purpose-built transformations
│   │   ├── int_order_items_joined.sql
│   │   └── int_customer_metrics.sql
│   │
│   ├── marts/               # Business-focused models
│   │   ├── finance/
│   │   │   ├── revenue_by_month.sql
│   │   │   └── finance.yml
│   │   └── marketing/
│   │       ├── customer_segments.sql
│   │       └── marketing.yml
│   │
│   └── schema.yml           # Model/column documentation & tests
│
├── snapshots/               # Type-2 slowly changing dimensions
│   └── customers_snapshot.sql
│
├── tests/                   # Custom data tests
│   └── assert_positive_revenue.sql
│
├── macros/                  # Reusable SQL snippets
│   ├── generate_schema_name.sql
│   └── custom_macros.sql
│
├── seeds/                   # CSV files to load
│   ├── country_codes.csv
│   └── employee_ids.csv
│
├── analyses/                # Ad-hoc queries (compiled, not run)
│   └── exploratory_analysis.sql
│
├── target/                  # Compiled SQL (generated, not in Git)
│   ├── compiled/
│   └── run/
│
└── logs/                    # dbt run logs (not in Git)
    └── dbt.log
```

---

## 2.2 The Three-Layer Architecture

### Layer 1: Staging (Source-Aligned)

**Purpose:** Light transformations on source data - renaming, type casting, basic cleaning.

**Characteristics:**
- 1:1 relationship with source tables
- Minimal transformations
- Column renaming and standardization
- Type casting
- No business logic
- No joins (usually)

**Naming Convention:** `stg_<source>_<table>`

```sql
-- models/staging/stg_customers.sql
WITH source AS (
    SELECT * FROM {{ source('raw', 'customers') }}
)

SELECT
    -- IDs
    id AS customer_id,

    -- Strings (standardized)
    UPPER(TRIM(first_name)) AS first_name,
    UPPER(TRIM(last_name)) AS last_name,
    LOWER(TRIM(email)) AS email,

    -- Timestamps
    created_at::TIMESTAMP AS created_at,
    updated_at::TIMESTAMP AS updated_at,

    -- Booleans
    is_active::BOOLEAN AS is_active

FROM source
```

**Materialization:** Usually `view` (fast, always fresh)

```yaml
# dbt_project.yml
models:
  my_project:
    staging:
      +materialized: view
```

---

### Layer 2: Intermediate (Purpose-Built)

**Purpose:** Complex transformations, joins, business logic that don't fit in staging or marts.

**Characteristics:**
- Purpose-built for specific downstream needs
- Joins between staging models
- Complex business logic
- Heavy transformations
- Not exposed to end users
- Can be ephemeral

**Naming Convention:** `int_<description>`

```sql
-- models/intermediate/int_order_items_joined.sql
WITH orders AS (
    SELECT * FROM {{ ref('stg_orders') }}
),

order_items AS (
    SELECT * FROM {{ ref('stg_order_items') }}
),

products AS (
    SELECT * FROM {{ ref('stg_products') }}
)

SELECT
    orders.order_id,
    orders.customer_id,
    orders.order_date,

    order_items.order_item_id,
    order_items.quantity,

    products.product_id,
    products.product_name,
    products.unit_price,

    -- Calculated fields
    order_items.quantity * products.unit_price AS line_total

FROM orders
INNER JOIN order_items
    ON orders.order_id = order_items.order_id
INNER JOIN products
    ON order_items.product_id = products.product_id
```

**Materialization:** Usually `ephemeral` or `view`

---

### Layer 3: Marts (Business-Focused)

**Purpose:** Final, business-ready models organized by department or use case.

**Characteristics:**
- Business-focused
- Optimized for querying
- Well-documented
- Tested rigorously
- Exposed to BI tools
- Denormalized (often)

**Naming Convention:** `<domain>_<description>` or `fct_<entity>`, `dim_<entity>`

**Organization:**
```
marts/
├── finance/
│   ├── revenue_by_month.sql
│   ├── revenue_by_product.sql
│   └── finance.yml
├── marketing/
│   ├── customer_segments.sql
│   ├── campaign_performance.sql
│   └── marketing.yml
└── operations/
    ├── inventory_levels.sql
    └── operations.yml
```

**Example - Fact Table:**
```sql
-- models/marts/finance/fct_orders.sql
WITH orders AS (
    SELECT * FROM {{ ref('int_order_items_joined') }}
)

SELECT
    order_id,
    customer_id,
    order_date,

    -- Aggregated metrics
    SUM(line_total) AS order_total,
    COUNT(DISTINCT product_id) AS num_products,
    SUM(quantity) AS total_items,

    -- Derived fields
    CASE
        WHEN SUM(line_total) >= 1000 THEN 'High Value'
        WHEN SUM(line_total) >= 100 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS order_value_tier

FROM orders
GROUP BY order_id, customer_id, order_date
```

**Example - Dimension Table:**
```sql
-- models/marts/finance/dim_customers.sql
WITH customers AS (
    SELECT * FROM {{ ref('stg_customers') }}
),

customer_orders AS (
    SELECT
        customer_id,
        COUNT(DISTINCT order_id) AS lifetime_orders,
        SUM(order_total) AS lifetime_value,
        MIN(order_date) AS first_order_date,
        MAX(order_date) AS most_recent_order_date
    FROM {{ ref('fct_orders') }}
    GROUP BY customer_id
)

SELECT
    c.customer_id,
    c.first_name,
    c.last_name,
    c.email,
    c.created_at,

    -- Customer metrics
    COALESCE(co.lifetime_orders, 0) AS lifetime_orders,
    COALESCE(co.lifetime_value, 0) AS lifetime_value,
    co.first_order_date,
    co.most_recent_order_date,

    -- Segments
    CASE
        WHEN co.lifetime_value >= 10000 THEN 'VIP'
        WHEN co.lifetime_value >= 1000 THEN 'High Value'
        WHEN co.lifetime_value >= 100 THEN 'Medium Value'
        ELSE 'Low Value'
    END AS customer_segment

FROM customers c
LEFT JOIN customer_orders co
    ON c.customer_id = co.customer_id
```

**Materialization:** Usually `table` or `incremental`

---

## 2.3 dbt_project.yml Configuration

### Basic Structure

```yaml
# dbt_project.yml
name: 'my_dbt_project'
version: '1.0.0'
config-version: 2

# Profile to use (connects to warehouse)
profile: 'my_project'

# Directories
model-paths: ["models"]
analysis-paths: ["analyses"]
test-paths: ["tests"]
seed-paths: ["seeds"]
macro-paths: ["macros"]
snapshot-paths: ["snapshots"]

# Output paths (not committed to Git)
target-path: "target"
clean-targets:
  - "target"
  - "dbt_packages"

# Global model configurations
models:
  my_dbt_project:
    # Staging layer
    staging:
      +materialized: view
      +schema: staging

    # Intermediate layer
    intermediate:
      +materialized: ephemeral

    # Marts layer
    marts:
      +materialized: table
      +schema: marts

      # Finance-specific
      finance:
        +schema: finance
        +tags: ["finance", "pii"]

      # Marketing-specific
      marketing:
        +schema: marketing
        +tags: ["marketing"]

# Global test configurations
tests:
  my_dbt_project:
    +severity: error  # or 'warn'

# Global seed configurations
seeds:
  my_dbt_project:
    +schema: seeds
    country_codes:
      +column_types:
        country_code: varchar(2)
        country_name: varchar(100)

# Variables
vars:
  start_date: '2020-01-01'
  revenue_currency: 'USD'
```

---

### Configuration Precedence

**Priority (highest to lowest):**
1. In-file config block
2. Model-specific config in `.yml`
3. Subdirectory config in `dbt_project.yml`
4. Project-level config in `dbt_project.yml`

```sql
-- 1. In-file config (highest priority)
{{ config(
    materialized='incremental',
    unique_key='order_id',
    on_schema_change='fail'
) }}

SELECT ...
```

```yaml
# 2. Model-specific in .yml
version: 2
models:
  - name: fct_orders
    config:
      materialized: incremental
      unique_key: order_id
```

```yaml
# 3. Subdirectory config in dbt_project.yml
models:
  my_project:
    marts:
      finance:
        +materialized: table
```

---

## 2.4 Sources - Defining Raw Data

### Source Configuration

```yaml
# models/staging/sources.yml
version: 2

sources:
  - name: raw
    description: "Raw data from production database"
    database: production
    schema: raw_data

    # Source freshness
    loaded_at_field: _loaded_at
    freshness:
      warn_after: {count: 12, period: hour}
      error_after: {count: 24, period: hour}

    tables:
      - name: customers
        description: "Customer records from CRM"
        columns:
          - name: id
            description: "Primary key"
            tests:
              - unique
              - not_null

          - name: email
            tests:
              - not_null

      - name: orders
        description: "Order transaction data"
        freshness:
          warn_after: {count: 6, period: hour}  # Override default
        columns:
          - name: id
            tests:
              - unique
              - not_null

          - name: customer_id
            tests:
              - not_null
              - relationships:
                  to: source('raw', 'customers')
                  field: id
```

---

### Using Sources in Models

```sql
-- Reference source tables
SELECT * FROM {{ source('raw', 'customers') }}

-- This compiles to:
SELECT * FROM production.raw_data.customers
```

**Benefits:**
- Documents data lineage from source
- Tests source data quality
- Monitors source freshness
- Decouples from physical schema names
- Generates source → model lineage in docs

---

### Testing Source Freshness

```bash
# Check if sources are fresh
dbt source freshness

# Example output:
#  18:32:21 | 1 of 2 OK source.raw.customers [ok in 0.25s]
#  18:32:21 | 2 of 2 WARN source.raw.orders [warn 8h overdue in 0.18s]
```

---

## 2.5 Seeds - CSV Reference Data

### When to Use Seeds

**✅ Good use cases:**
- Country codes
- Employee IDs
- Zip code mappings
- Static reference data
- Lookup tables

**❌ Bad use cases:**
- Large datasets (>1MB)
- Frequently changing data
- Raw transactional data

---

### Creating Seeds

```csv
# seeds/country_codes.csv
country_code,country_name,region
US,United States,North America
CA,Canada,North America
UK,United Kingdom,Europe
DE,Germany,Europe
```

```bash
# Load seeds into warehouse
dbt seed

# Run specific seed
dbt seed --select country_codes
```

---

### Seed Configuration

```yaml
# dbt_project.yml
seeds:
  my_project:
    country_codes:
      +schema: reference
      +column_types:
        country_code: varchar(2)
        country_name: varchar(100)
        region: varchar(50)
```

```yaml
# seeds/schema.yml
version: 2

seeds:
  - name: country_codes
    description: "ISO country codes and names"
    columns:
      - name: country_code
        tests:
          - unique
          - not_null
      - name: country_name
        tests:
          - not_null
```

---

### Using Seeds in Models

```sql
SELECT
    o.order_id,
    o.customer_country_code,
    cc.country_name,
    cc.region
FROM {{ ref('stg_orders') }} o
LEFT JOIN {{ ref('country_codes') }} cc
    ON o.customer_country_code = cc.country_code
```

---

## 2.6 Macros - Reusable SQL

### Basic Macro

```sql
-- macros/cents_to_dollars.sql
{% macro cents_to_dollars(column_name, scale=2) %}
    ROUND({{ column_name }} / 100.0, {{ scale }})
{% endmacro %}
```

**Usage:**
```sql
SELECT
    order_id,
    {{ cents_to_dollars('amount_cents') }} AS amount_dollars
FROM {{ ref('stg_orders') }}
```

**Compiles to:**
```sql
SELECT
    order_id,
    ROUND(amount_cents / 100.0, 2) AS amount_dollars
FROM analytics.stg_orders
```

---

### Macros with Logic

```sql
-- macros/generate_alias_name.sql
{% macro generate_alias_name(custom_alias_name=none, node=none) -%}

    {%- if custom_alias_name is none -%}
        {{ node.name }}

    {%- else -%}
        {{ custom_alias_name | trim }}

    {%- endif -%}

{%- endmacro %}
```

---

### Using dbt_utils Macros

```yaml
# packages.yml
packages:
  - package: dbt-labs/dbt_utils
    version: 1.1.1
```

```bash
dbt deps  # Install packages
```

```sql
-- Use surrogate_key macro
SELECT
    {{ dbt_utils.generate_surrogate_key(['order_id', 'order_item_id']) }} AS unique_key,
    order_id,
    order_item_id,
    product_id
FROM {{ ref('stg_order_items') }}
```

```sql
-- Use date_spine macro
{{ dbt_utils.date_spine(
    datepart="day",
    start_date="cast('2020-01-01' as date)",
    end_date="cast('2025-12-31' as date)"
) }}
```

---

## 2.7 Packages - Extending dbt

### Popular Packages

```yaml
# packages.yml
packages:
  # Utility macros
  - package: dbt-labs/dbt_utils
    version: 1.1.1

  # Advanced testing
  - package: calogica/dbt_expectations
    version: 0.10.0

  # Code generation
  - package: dbt-labs/codegen
    version: 0.11.0

  # Audit helper
  - package: dbt-labs/audit_helper
    version: 0.9.0

  # Project evaluation
  - package: dbt-labs/dbt_project_evaluator
    version: 0.7.0
```

---

### dbt_utils Examples

```sql
-- Generate surrogate key
{{ dbt_utils.generate_surrogate_key(['col1', 'col2']) }}

-- Get column values as list
{{ dbt_utils.get_column_values(
    table=ref('customers'),
    column='customer_type'
) }}

-- Union tables
{{ dbt_utils.union_relations(
    relations=[ref('orders_2023'), ref('orders_2024')],
    exclude=['_loaded_at']
) }}

-- Pivot table
{{ dbt_utils.pivot(
    column='product_category',
    values=dbt_utils.get_column_values(ref('products'), 'product_category'),
    agg='sum',
    then_value='revenue'
) }}
```

---

### dbt_expectations Examples

```yaml
# models/schema.yml
version: 2

models:
  - name: stg_customers
    tests:
      - dbt_expectations.expect_table_row_count_to_be_between:
          min_value: 1000
          max_value: 1000000

    columns:
      - name: email
        tests:
          - dbt_expectations.expect_column_values_to_match_regex:
              regex: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"

      - name: created_at
        tests:
          - dbt_expectations.expect_column_values_to_be_between:
              min_value: "'2020-01-01'"
              max_value: "current_date"
```

---

## 🎯 Best Practices

### 1. Project Structure
- Follow the staging → intermediate → marts pattern
- Keep models small and focused
- Organize marts by business domain
- Use consistent naming conventions

### 2. Configuration
- Set defaults in `dbt_project.yml`
- Override with model-specific config when needed
- Use tags for selective runs
- Document configuration decisions

### 3. Sources
- Define all raw data as sources
- Test source data quality
- Monitor source freshness
- Use source descriptions

### 4. Seeds
- Only for small, static data
- Version control seeds in Git
- Test seed data quality
- Document seed purpose

### 5. Macros
- Extract repeated logic into macros
- Document macro parameters
- Test macros thoroughly
- Use packages for common patterns

### 6. Packages
- Pin package versions
- Review package code before using
- Keep packages updated
- Don't over-rely on packages

---

## 🔗 Related Notes

- [[01. dbt Fundamentals - Introduction & Core Concepts|Previous: Chapter 1 - Fundamentals]]
- [[03. dbt Models & Materializations|Next: Chapter 3 - Models & Materializations]]
- [[README|Project Overview]]

---

## 📚 Key Takeaways

1. **Three-layer architecture**: Staging (light transforms) → Intermediate (complex logic) → Marts (business-ready)
2. **dbt_project.yml is central**: Configures models, tests, seeds, and project settings
3. **Sources document raw data**: Lineage, freshness, and quality checks
4. **Seeds are for small static data**: Country codes, employee IDs, lookup tables
5. **Macros enable DRY code**: Reusable SQL snippets and functions
6. **Packages extend functionality**: dbt_utils, dbt_expectations, codegen
7. **Configuration cascades**: File → model → subdirectory → project level
8. **Organize by business domain**: Finance, marketing, operations marts

---

**Last Updated:** 2025-10-17
**Chapter Status:** ✅ Complete
