---
title: Query Optimization Techniques
date: 2025-10-14
tags: [sql, optimization, performance, explain, query-planning, data-engineering, indexing, architecture-performance]
status: active
learning_phase: "Architecture & Performance (Engineering)"
---

# Query Optimization Techniques

## Overview

Query optimization is essential for scalable data systems. This guide covers techniques for analyzing query performance, understanding execution plans, and implementing optimizations that dramatically improve query speed.

---

## Understanding Query Execution

### Query Processing Phases

```
1. PARSING       → Syntax validation, parse tree
2. REWRITING     → Simplification, view expansion
3. OPTIMIZATION  → Query planner creates execution plan
4. EXECUTION     → Execute plan, return results
```

### Query Planner's Job

- Choose best indexes
- Determine join order
- Select join algorithms
- Estimate row counts and costs
- Choose between sequential vs index scans

---

## EXPLAIN - Analyzing Query Plans

### Basic EXPLAIN

```sql
-- PostgreSQL
EXPLAIN
SELECT * FROM customers WHERE city = 'Seattle';

-- Output shows:
-- - Scan type (Seq Scan, Index Scan, etc.)
-- - Estimated cost
-- - Estimated rows
-- - Filter conditions
```

### EXPLAIN ANALYZE (Actual Execution)

```sql
-- Run query and show actual performance
EXPLAIN ANALYZE
SELECT
    c.customer_id,
    c.name,
    COUNT(o.order_id) AS order_count
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;

-- Shows:
-- - Planning time
-- - Execution time
-- - Actual vs estimated rows
-- - Actual cost
```

### Reading EXPLAIN Output

```sql
-- Example output:
Seq Scan on customers  (cost=0.00..18584.00 rows=1 width=100)
  (actual time=0.123..45.678 rows=5 loops=1)
  Filter: (city = 'Seattle'::text)
Planning Time: 0.234 ms
Execution Time: 45.901 ms

-- Key metrics:
-- cost=0.00..18584.00  → Startup cost..total cost
-- rows=1               → Estimated rows
-- width=100            → Average row size (bytes)
-- actual time=...      → Actual startup..total time (ms)
-- rows=5               → Actual rows returned
-- loops=1              → Times this node executed
```

### Different Scan Types

| Scan Type | Description | When Used |
|-----------|-------------|-----------|
| **Seq Scan** | Full table scan | No suitable index, small tables |
| **Index Scan** | Uses index + table lookup | Selective queries with index |
| **Index Only Scan** | Data entirely from index | Covering index |
| **Bitmap Index Scan** | Multiple indexes combined | OR conditions, range scans |

---

## Indexing Strategies

### When Indexes Help

```sql
-- ✅ FAST: Index on customer_id
SELECT * FROM orders WHERE customer_id = 100;

-- ✅ FAST: Composite index on (status, created_date)
SELECT * FROM orders
WHERE status = 'pending' AND created_date >= '2024-01-01';

-- ✅ FAST: Index on created_date (range scan)
SELECT * FROM orders
WHERE created_date BETWEEN '2024-01-01' AND '2024-01-31';
```

### When Indexes Don't Help

```sql
-- ❌ SLOW: Function on indexed column
SELECT * FROM orders
WHERE YEAR(created_date) = 2024;  -- Can't use index!

-- ✅ FAST: Rewrite without function
SELECT * FROM orders
WHERE created_date >= '2024-01-01' AND created_date < '2025-01-01';

-- ❌ SLOW: Leading wildcard
SELECT * FROM customers WHERE email LIKE '%@gmail.com';

-- ✅ FAST: Trailing wildcard
SELECT * FROM customers WHERE email LIKE 'john%';
```

### Composite Index Column Order

```sql
-- Index: (customer_id, order_date, status)

-- ✅ Uses index (left-most prefix rule)
SELECT * FROM orders WHERE customer_id = 100;
SELECT * FROM orders WHERE customer_id = 100 AND order_date >= '2024-01-01';
SELECT * FROM orders WHERE customer_id = 100 AND order_date >= '2024-01-01' AND status = 'shipped';

-- ❌ Doesn't use index (skips left-most column)
SELECT * FROM orders WHERE order_date >= '2024-01-01';
SELECT * FROM orders WHERE status = 'shipped';
```

**Rule:** Order index columns by selectivity (most selective first) and query patterns.

---

## Join Optimization

### Join Order Matters

```sql
-- ❌ BAD: Large table first
SELECT *
FROM orders o              -- 10 million rows
JOIN customers c           -- 100k rows
    ON o.customer_id = c.customer_id
WHERE c.country = 'USA';

-- ✅ GOOD: Filter small table first
SELECT *
FROM customers c           -- 100k rows → filtered to 10k
JOIN orders o              -- 10 million rows
    ON c.customer_id = o.customer_id
WHERE c.country = 'USA';
```

### Use Subqueries to Pre-filter

```sql
-- ❌ SLOW: Filter after join
SELECT *
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01';

-- ✅ FAST: Filter before join
SELECT *
FROM (
    SELECT * FROM orders
    WHERE order_date >= '2024-01-01'
) o
JOIN customers c ON o.customer_id = c.customer_id;
```

### Choose Appropriate Join Type

```sql
-- EXISTS for semi-join (find customers with orders)
-- ✅ EFFICIENT: Stops at first match
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.customer_id = c.customer_id
);

-- ❌ LESS EFFICIENT: Processes all matches
SELECT DISTINCT c.*
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id;
```

### Join Algorithms

| Algorithm | Description | Best For |
|-----------|-------------|----------|
| **Nested Loop** | Row-by-row iteration | Small tables, indexed joins |
| **Hash Join** | Build hash table | Large tables, equality joins |
| **Merge Join** | Sorted merge | Pre-sorted data, range joins |

---

## WHERE Clause Optimization

### Filter Early and Often

```sql
-- ❌ SLOW: Multiple passes
SELECT *
FROM (
    SELECT *
    FROM large_table
) t
WHERE created_date >= '2024-01-01'
  AND status = 'active';

-- ✅ FAST: Filter once
SELECT *
FROM large_table
WHERE created_date >= '2024-01-01'
  AND status = 'active';
```

### Use Indexed Columns in WHERE

```sql
-- ✅ GOOD: Uses index on customer_id
SELECT * FROM orders
WHERE customer_id = 100;

-- ❌ BAD: Function prevents index use
SELECT * FROM orders
WHERE UPPER(customer_name) = 'JOHN';

-- ✅ GOOD: Create functional index or compare lowercase
CREATE INDEX idx_customer_name_lower ON orders(LOWER(customer_name));
SELECT * FROM orders
WHERE LOWER(customer_name) = 'john';
```

### Avoid OR with Different Columns

```sql
-- ❌ SLOW: Can't use indexes efficiently
SELECT * FROM orders
WHERE customer_id = 100 OR order_date = '2024-01-01';

-- ✅ FAST: Use UNION
SELECT * FROM orders WHERE customer_id = 100
UNION
SELECT * FROM orders WHERE order_date = '2024-01-01';
```

---

## Subquery Optimization

### Correlated vs Non-Correlated

```sql
-- ❌ SLOW: Correlated subquery (runs for each row)
SELECT
    c.customer_id,
    c.name,
    (SELECT COUNT(*)
     FROM orders o
     WHERE o.customer_id = c.customer_id) AS order_count
FROM customers c;

-- ✅ FAST: Join with aggregation
SELECT
    c.customer_id,
    c.name,
    COALESCE(o.order_count, 0) AS order_count
FROM customers c
LEFT JOIN (
    SELECT customer_id, COUNT(*) AS order_count
    FROM orders
    GROUP BY customer_id
) o ON c.customer_id = o.customer_id;
```

### Use WITH (CTE) for Readability

```sql
-- Materialize subquery once
WITH high_value_customers AS (
    SELECT customer_id, SUM(total_amount) AS total_spent
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total_amount) > 10000
)
SELECT
    c.customer_id,
    c.name,
    hvc.total_spent
FROM customers c
JOIN high_value_customers hvc ON c.customer_id = hvc.customer_id;
```

---

## Aggregation Optimization

### Pre-aggregate Before Join

```sql
-- ❌ SLOW: Aggregate after join
SELECT
    c.customer_id,
    c.name,
    COUNT(o.order_id) AS order_count
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;

-- ✅ FAST: Aggregate before join
SELECT
    c.customer_id,
    c.name,
    COALESCE(o.order_count, 0) AS order_count
FROM customers c
LEFT JOIN (
    SELECT customer_id, COUNT(*) AS order_count
    FROM orders
    GROUP BY customer_id
) o ON c.customer_id = o.customer_id;
```

### Use Covering Indexes for Aggregations

```sql
-- Create index covering aggregation columns
CREATE INDEX idx_orders_customer_amount
ON orders(customer_id, total_amount);

-- Query can use index-only scan
SELECT customer_id, SUM(total_amount)
FROM orders
GROUP BY customer_id;
```

---

## LIMIT and Pagination

### Efficient Pagination

```sql
-- ❌ SLOW: OFFSET grows with page number
SELECT * FROM orders
ORDER BY order_id
LIMIT 100 OFFSET 10000;  -- Must scan 10,100 rows

-- ✅ FAST: Keyset pagination (seek method)
SELECT * FROM orders
WHERE order_id > 10100  -- Last ID from previous page
ORDER BY order_id
LIMIT 100;
```

### LIMIT with Complex Queries

```sql
-- ❌ SLOW: Sorts all rows, then limits
SELECT * FROM orders
ORDER BY created_date DESC, order_id DESC
LIMIT 10;

-- ✅ FAST: Use index on (created_date DESC, order_id DESC)
CREATE INDEX idx_orders_date_id_desc
ON orders(created_date DESC, order_id DESC);
```

---

## Avoiding Common Anti-Patterns

### Anti-Pattern 1: SELECT *

```sql
-- ❌ BAD: Fetches unnecessary data
SELECT * FROM orders
WHERE customer_id = 100;

-- ✅ GOOD: Specify needed columns
SELECT order_id, order_date, total_amount
FROM orders
WHERE customer_id = 100;
```

### Anti-Pattern 2: NOT IN with NULL

```sql
-- ❌ WRONG: Returns no rows if subquery has NULL
SELECT * FROM customers
WHERE customer_id NOT IN (SELECT customer_id FROM deleted_customers);

-- ✅ CORRECT: Use NOT EXISTS
SELECT * FROM customers c
WHERE NOT EXISTS (
    SELECT 1 FROM deleted_customers d
    WHERE d.customer_id = c.customer_id
);
```

### Anti-Pattern 3: Using Functions in WHERE

```sql
-- ❌ SLOW: Can't use index
SELECT * FROM orders
WHERE DATE(created_timestamp) = '2024-01-01';

-- ✅ FAST: Use range
SELECT * FROM orders
WHERE created_timestamp >= '2024-01-01 00:00:00'
  AND created_timestamp < '2024-01-02 00:00:00';
```

### Anti-Pattern 4: Implicit Type Conversion

```sql
-- ❌ SLOW: customer_id is INT, '100' is VARCHAR
SELECT * FROM orders
WHERE customer_id = '100';  -- Implicit conversion

-- ✅ FAST: Explicit type match
SELECT * FROM orders
WHERE customer_id = 100;
```

---

## Partitioning for Performance

### Table Partitioning Benefits

```sql
-- Partition by date range
CREATE TABLE orders (
    order_id BIGINT,
    order_date DATE,
    total_amount DECIMAL(10,2)
) PARTITION BY RANGE (order_date);

-- Create partitions
CREATE TABLE orders_2024_01 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE orders_2024_02 PARTITION OF orders
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

-- Query only scans relevant partition
SELECT * FROM orders
WHERE order_date >= '2024-01-15' AND order_date < '2024-01-20';
-- Only scans orders_2024_01 partition
```

### Partition Pruning

```sql
-- ✅ Partition pruning works
SELECT * FROM orders
WHERE order_date = '2024-01-15';  -- Scans 1 partition

-- ❌ Partition pruning doesn't work
SELECT * FROM orders
WHERE EXTRACT(MONTH FROM order_date) = 1;  -- Scans all partitions
```

---

## Parallel Query Execution

### Enable Parallel Execution

```sql
-- PostgreSQL: Configure parallel workers
SET max_parallel_workers_per_gather = 4;

-- Query may use parallel scan
EXPLAIN ANALYZE
SELECT customer_id, SUM(total_amount)
FROM orders
GROUP BY customer_id;

-- Look for "Parallel Seq Scan" in plan
```

### When Parallel Execution Helps

- Large table scans
- Heavy aggregations
- Complex joins
- Sorting large result sets

---

## Materialized Views

### When to Use Materialized Views

```sql
-- Expensive query run frequently
CREATE MATERIALIZED VIEW daily_sales_summary AS
SELECT
    DATE(order_date) AS sale_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS revenue
FROM orders
GROUP BY DATE(order_date);

-- Create index on materialized view
CREATE INDEX idx_sales_summary_date
ON daily_sales_summary(sale_date);

-- Query materialized view (fast)
SELECT * FROM daily_sales_summary
WHERE sale_date >= '2024-01-01';

-- Refresh periodically
REFRESH MATERIALIZED VIEW daily_sales_summary;
```

---

## Query Hints and Configuration

### PostgreSQL Configuration

```sql
-- Increase work memory for complex queries
SET work_mem = '256MB';

-- Increase shared buffers (cache)
SET shared_buffers = '1GB';

-- Enable query statistics
SET track_activities = ON;
SET track_counts = ON;
```

### Query Hints (Database-Specific)

```sql
-- PostgreSQL: Force index use (avoid if possible, let planner choose)
SET enable_seqscan = OFF;  -- Force index scans

-- SQL Server: Query hints
SELECT * FROM orders WITH (INDEX(idx_customer_id))
WHERE customer_id = 100;

-- Oracle: Hints
SELECT /*+ INDEX(orders idx_customer_id) */
    * FROM orders
WHERE customer_id = 100;
```

---

## Monitoring and Maintenance

### Identify Slow Queries

```sql
-- PostgreSQL: Enable pg_stat_statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Find slowest queries
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### Update Statistics

```sql
-- PostgreSQL: Update table statistics
ANALYZE orders;
ANALYZE customers;

-- Automatic vacuum and analyze (should be enabled)
SHOW autovacuum;
```

### Rebuild Indexes

```sql
-- PostgreSQL: Rebuild bloated index
REINDEX INDEX idx_orders_customer;
REINDEX TABLE orders;

-- MySQL: Optimize table (rebuilds indexes)
OPTIMIZE TABLE orders;
```

---

## Performance Testing Checklist

### Before Optimization

1. ✅ Run EXPLAIN ANALYZE
2. ✅ Identify bottlenecks (slow scans, sorts, joins)
3. ✅ Check index usage
4. ✅ Review row estimates vs 11.
5. ✅ Profile query execution time

### After Optimization

1. ✅ Compare EXPLAIN ANALYZE results
2. ✅ Verify index usage improved
3. ✅ Check execution time reduction
4. ✅ Test with representative data volume
5. ✅ Monitor resource usage (CPU, memory, I/O)

---

## Best Practices Summary

### ✅ Do's

1. **Index foreign keys** and WHERE clause columns
2. **Filter early** - WHERE before JOIN when possible
3. **Use EXISTS** instead of IN for subqueries
4. **Specify columns** instead of SELECT *
5. **Analyze queries** with EXPLAIN regularly
6. **Update statistics** after large data changes
7. **Partition large tables** by date or key ranges
8. **Use covering indexes** for frequently run queries

### ❌ Don'ts

1. **Don't use functions** on indexed columns in WHERE
2. **Don't use leading wildcards** (LIKE '%term')
3. **Don't use SELECT *** unless necessary
4. **Don't ignore EXPLAIN** output
5. **Don't use NOT IN** with nullable columns
6. **Don't over-index** - each index has write cost
7. **Don't use hints** unless absolutely necessary
8. **Don't optimize prematurely** - measure first

---

## Quick Optimization Decision Tree

```
Is query slow?
├─ YES → Run EXPLAIN ANALYZE
   ├─ Seq Scan on large table?
   │  └─ Add index on WHERE columns
   ├─ Slow JOIN?
   │  └─ Check index on join columns
   │  └─ Pre-filter/aggregate before join
   ├─ High sort cost?
   │  └─ Add index on ORDER BY columns
   │  └─ Use LIMIT for pagination
   ├─ Actual rows >> Estimated rows?
   │  └─ Run ANALYZE to update statistics
   └─ Still slow?
      └─ Consider partitioning, materialized views
└─ NO → Monitor and move on
```

---

## Related Concepts

- [[SQL Indexes - Performance Optimization]] - Indexing strategies
- [[Data Modeling & Table Design]] - Schema design for performance
- [[Window Functions - Advanced SQL Analytics]] - Analytical query patterns
- [[Advanced Join Patterns]] - Join optimization

---

## Key Takeaways

1. **EXPLAIN is your friend** - Always analyze before optimizing
2. **Indexes are critical** - But don't over-index
3. **Filter early** - WHERE before JOIN
4. **Avoid functions** on indexed columns in WHERE clauses
5. **Choose right join type** - EXISTS vs IN vs JOIN
6. **Partition large tables** - Especially time-series data
7. **Update statistics** regularly for accurate query planning
8. **Monitor slow queries** - Identify and optimize the 20% causing 80% of problems
