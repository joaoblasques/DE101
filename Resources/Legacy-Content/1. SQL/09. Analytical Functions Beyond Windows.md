---
title: Analytical Functions Beyond Windows
date: 2025-10-14
tags: [sql, analytics, pivot, unpivot, rollup, cube, grouping-sets, percentiles, data-engineering, advanced-queries]
status: active
learning_phase: "Advanced Queries (Analytical)"
---

# Analytical Functions Beyond Windows

## Overview

Beyond window functions, SQL provides powerful analytical capabilities for reshaping data, calculating advanced statistics, and performing multi-dimensional aggregations. These functions are essential for business intelligence and data analysis.

---

## PIVOT - Rows to Columns

### What is PIVOT?

Transform row data into columnar format, creating cross-tabulation reports.

### SQL Server PIVOT

```sql
-- Sample data: Sales by quarter
-- product | quarter | amount
-- Widget  | Q1      | 1000
-- Widget  | Q2      | 1500
-- Gadget  | Q1      | 800

-- Pivot to columns
SELECT *
FROM (
    SELECT product, quarter, amount
    FROM sales
) AS source_data
PIVOT (
    SUM(amount)
    FOR quarter IN ([Q1], [Q2], [Q3], [Q4])
) AS pivot_table;

-- Result:
-- product | Q1   | Q2   | Q3   | Q4
-- Widget  | 1000 | 1500 | NULL | NULL
-- Gadget  | 800  | NULL | NULL | NULL
```

### PostgreSQL PIVOT (Using CASE)

PostgreSQL doesn't have native PIVOT, use CASE statements:

```sql
SELECT
    product,
    SUM(CASE WHEN quarter = 'Q1' THEN amount ELSE 0 END) AS q1,
    SUM(CASE WHEN quarter = 'Q2' THEN amount ELSE 0 END) AS q2,
    SUM(CASE WHEN quarter = 'Q3' THEN amount ELSE 0 END) AS q3,
    SUM(CASE WHEN quarter = 'Q4' THEN amount ELSE 0 END) AS q4
FROM sales
GROUP BY product;
```

### PostgreSQL CROSSTAB Function

```sql
-- Requires tablefunc extension
CREATE EXTENSION IF NOT EXISTS tablefunc;

-- Crosstab with dynamic columns
SELECT *
FROM CROSSTAB(
    'SELECT product, quarter, SUM(amount)
     FROM sales
     GROUP BY product, quarter
     ORDER BY 1, 2',
    'SELECT DISTINCT quarter FROM sales ORDER BY 1'
) AS ct(product TEXT, q1 NUMERIC, q2 NUMERIC, q3 NUMERIC, q4 NUMERIC);
```

### Dynamic PIVOT

```sql
-- SQL Server: Dynamic PIVOT for unknown columns
DECLARE @columns NVARCHAR(MAX), @sql NVARCHAR(MAX);

SELECT @columns = STRING_AGG(QUOTENAME(quarter), ',')
FROM (SELECT DISTINCT quarter FROM sales) AS quarters;

SET @sql = N'
SELECT *
FROM (
    SELECT product, quarter, amount FROM sales
) AS source_data
PIVOT (
    SUM(amount) FOR quarter IN (' + @columns + ')
) AS pivot_table';

EXEC sp_executesql @sql;
```

---

## UNPIVOT - Columns to Rows

### What is UNPIVOT?

Transform columnar data into row format (opposite of PIVOT).

### SQL Server UNPIVOT

```sql
-- Source data:
-- product | q1   | q2   | q3   | q4
-- Widget  | 1000 | 1500 | 2000 | 1800

-- Unpivot to rows
SELECT product, quarter, amount
FROM (
    SELECT product, q1, q2, q3, q4
    FROM quarterly_sales
) AS source_data
UNPIVOT (
    amount FOR quarter IN (q1, q2, q3, q4)
) AS unpivot_table;

-- Result:
-- product | quarter | amount
-- Widget  | q1      | 1000
-- Widget  | q2      | 1500
-- Widget  | q3      | 2000
-- Widget  | q4      | 1800
```

### PostgreSQL UNPIVOT (Using UNION)

```sql
SELECT product, 'Q1' AS quarter, q1 AS amount FROM quarterly_sales
UNION ALL
SELECT product, 'Q2' AS quarter, q2 AS amount FROM quarterly_sales
UNION ALL
SELECT product, 'Q3' AS quarter, q3 AS amount FROM quarterly_sales
UNION ALL
SELECT product, 'Q4' AS quarter, q4 AS amount FROM quarterly_sales;
```

### PostgreSQL UNPIVOT (Using UNNEST)

```sql
SELECT
    product,
    quarters.quarter,
    amounts.amount
FROM quarterly_sales,
    UNNEST(ARRAY['Q1', 'Q2', 'Q3', 'Q4']) WITH ORDINALITY AS quarters(quarter, ord),
    UNNEST(ARRAY[q1, q2, q3, q4]) WITH ORDINALITY AS amounts(amount, ord)
WHERE quarters.ord = amounts.ord;
```

---

## ROLLUP - Hierarchical Aggregations

### What is ROLLUP?

Creates subtotals and grand totals in hierarchical order.

### Basic ROLLUP

```sql
-- Sales by region, state, city
SELECT
    region,
    state,
    city,
    SUM(amount) AS total_sales
FROM sales
GROUP BY ROLLUP (region, state, city)
ORDER BY region, state, city;

-- Results include:
-- 1. Detail: region, state, city
-- 2. Subtotal: region, state, NULL
-- 3. Subtotal: region, NULL, NULL
-- 4. Grand total: NULL, NULL, NULL
```

### Example Output

```
region  | state | city       | total_sales
--------|-------|------------|------------
West    | CA    | SF         | 1000
West    | CA    | LA         | 1500
West    | CA    | NULL       | 2500        -- CA subtotal
West    | WA    | Seattle    | 800
West    | WA    | NULL       | 800         -- WA subtotal
West    | NULL  | NULL       | 3300        -- West subtotal
East    | NY    | NYC        | 2000
East    | NY    | NULL       | 2000        -- NY subtotal
East    | NULL  | NULL       | 2000        -- East subtotal
NULL    | NULL  | NULL       | 5300        -- Grand total
```

### Partial ROLLUP

```sql
-- ROLLUP on specific columns only
SELECT
    region,
    state,
    SUM(amount) AS total_sales
FROM sales
GROUP BY region, ROLLUP(state);

-- Results:
-- region, state (detail)
-- region, NULL (region subtotal)
-- No grand total
```

---

## CUBE - Multi-dimensional Aggregations

### What is CUBE?

Creates all possible subtotal combinations (cross-dimensional analysis).

### Basic CUBE

```sql
SELECT
    region,
    product_category,
    SUM(amount) AS total_sales
FROM sales
GROUP BY CUBE (region, product_category);

-- Results include:
-- 1. Detail: region, product_category
-- 2. Subtotal: region, NULL (by region)
-- 3. Subtotal: NULL, product_category (by category)
-- 4. Grand total: NULL, NULL
```

### Example Output

```
region | product_category | total_sales
-------|------------------|------------
West   | Electronics      | 1000
West   | Clothing         | 500
West   | NULL             | 1500        -- West total
East   | Electronics      | 800
East   | Clothing         | 600
East   | NULL             | 1400        -- East total
NULL   | Electronics      | 1800        -- Electronics total
NULL   | Clothing         | 1100        -- Clothing total
NULL   | NULL             | 2900        -- Grand total
```

### CUBE vs ROLLUP

| Feature | ROLLUP | CUBE |
|---------|--------|------|
| **Aggregation Type** | Hierarchical | All combinations |
| **Subtotals** | Left-to-right hierarchy | All dimensions |
| **Use Case** | Organizational hierarchies | Cross-dimensional analysis |
| **Row Count** | n + 1 levels | 2^n combinations |

---

## GROUPING SETS - Custom Aggregations

### What is GROUPING SETS?

Define specific grouping combinations (more flexible than ROLLUP/CUBE).

### Basic GROUPING SETS

```sql
-- Specify exactly which groupings you want
SELECT
    region,
    product_category,
    quarter,
    SUM(amount) AS total_sales
FROM sales
GROUP BY GROUPING SETS (
    (region, product_category),    -- By region and category
    (region, quarter),              -- By region and quarter
    (product_category, quarter),    -- By category and quarter
    ()                              -- Grand total
);
```

### Equivalent to ROLLUP

```sql
-- These are equivalent:
GROUP BY ROLLUP(region, state, city)

GROUP BY GROUPING SETS (
    (region, state, city),
    (region, state),
    (region),
    ()
)
```

### Equivalent to CUBE

```sql
-- These are equivalent:
GROUP BY CUBE(region, product)

GROUP BY GROUPING SETS (
    (region, product),
    (region),
    (product),
    ()
)
```

---

## GROUPING Function

### Identifying Aggregation Levels

The `GROUPING()` function identifies whether a column is part of the aggregation.

```sql
SELECT
    region,
    state,
    SUM(amount) AS total_sales,
    GROUPING(region) AS is_region_total,
    GROUPING(state) AS is_state_total,
    CASE
        WHEN GROUPING(region) = 1 THEN 'Grand Total'
        WHEN GROUPING(state) = 1 THEN 'Region Total'
        ELSE 'Detail'
    END AS aggregation_level
FROM sales
GROUP BY ROLLUP(region, state);
```

**GROUPING() returns:**
- `0` if column is part of grouping (detail row)
- `1` if column is aggregated (subtotal row)

### Using GROUPING for Labels

```sql
SELECT
    CASE
        WHEN GROUPING(region) = 1 THEN 'All Regions'
        ELSE region
    END AS region,
    CASE
        WHEN GROUPING(product) = 1 THEN 'All Products'
        ELSE product
    END AS product,
    SUM(amount) AS total_sales
FROM sales
GROUP BY CUBE(region, product);
```

---

## Percentiles and Statistical Functions

### Percentile Calculations

```sql
-- PostgreSQL, MySQL 8.0+
SELECT
    department,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary) AS median_salary,
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY salary) AS q1_salary,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY salary) AS q3_salary,
    PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY salary) AS p90_salary
FROM employees
GROUP BY department;

-- PERCENTILE_CONT: Continuous (interpolates)
-- PERCENTILE_DISC: Discrete (actual values only)
```

### Window Function Alternative

```sql
-- Calculate percentiles using window functions
SELECT DISTINCT
    department,
    PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY salary)
        OVER (PARTITION BY department) AS median_salary
FROM employees;
```

### Multiple Percentiles at Once

```sql
-- PostgreSQL: Array of percentiles
SELECT
    department,
    PERCENTILE_CONT(ARRAY[0.25, 0.50, 0.75, 0.90])
        WITHIN GROUP (ORDER BY salary) AS percentiles
FROM employees
GROUP BY department;

-- Result: {25000, 50000, 75000, 90000}
```

---

## Statistical Aggregate Functions

### Variance and Standard Deviation

```sql
SELECT
    product_category,
    AVG(price) AS avg_price,
    STDDEV(price) AS std_dev,        -- Standard deviation (sample)
    STDDEV_POP(price) AS std_dev_pop, -- Population std dev
    VARIANCE(price) AS variance,      -- Variance (sample)
    VAR_POP(price) AS var_pop         -- Population variance
FROM products
GROUP BY product_category;
```

### Correlation and Covariance

```sql
-- Correlation between price and sales
SELECT
    CORR(price, units_sold) AS correlation,
    COVAR_POP(price, units_sold) AS covariance_pop,
    COVAR_SAMP(price, units_sold) AS covariance_samp
FROM product_sales;

-- Interpretation:
-- correlation: -1 to 1 (-1 = perfect negative, 1 = perfect positive)
-- 0 = no correlation
```

### Regression Functions

```sql
-- Linear regression: y = mx + b
SELECT
    REGR_SLOPE(sales, advertising_spend) AS slope,           -- m
    REGR_INTERCEPT(sales, advertising_spend) AS intercept,   -- b
    REGR_R2(sales, advertising_spend) AS r_squared,          -- Goodness of fit
    REGR_COUNT(sales, advertising_spend) AS n                -- Sample size
FROM marketing_data;

-- Predict sales based on advertising spend
SELECT
    advertising_spend,
    REGR_INTERCEPT(sales, advertising_spend) OVER () +
    REGR_SLOPE(sales, advertising_spend) OVER () * advertising_spend
        AS predicted_sales
FROM marketing_data;
```

---

## Advanced Aggregation Patterns

### Pattern 1: Running Total with Reset

```sql
-- Running total that resets per group
SELECT
    order_date,
    product_id,
    daily_sales,
    SUM(daily_sales) OVER (
        PARTITION BY product_id
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM daily_product_sales;
```

### Pattern 2: Ratio to Parent Aggregation

```sql
-- Sales as percentage of category total
SELECT
    product_category,
    product_name,
    sales,
    sales * 100.0 / SUM(sales) OVER (PARTITION BY product_category) AS pct_of_category,
    sales * 100.0 / SUM(sales) OVER () AS pct_of_total
FROM product_sales;
```

### Pattern 3: Top N per Group with ROLLUP

```sql
-- Top 3 products per category + category totals
WITH ranked_products AS (
    SELECT
        product_category,
        product_name,
        sales,
        ROW_NUMBER() OVER (PARTITION BY product_category ORDER BY sales DESC) AS rn
    FROM product_sales
)
SELECT
    product_category,
    product_name,
    SUM(sales) AS total_sales
FROM ranked_products
WHERE rn <= 3
GROUP BY ROLLUP(product_category, product_name);
```

### Pattern 4: Moving Average with Multiple Windows

```sql
-- 7-day, 30-day, and 90-day moving averages
SELECT
    order_date,
    daily_revenue,
    AVG(daily_revenue) OVER (
        ORDER BY order_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS avg_7_day,
    AVG(daily_revenue) OVER (
        ORDER BY order_date
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_30_day,
    AVG(daily_revenue) OVER (
        ORDER BY order_date
        ROWS BETWEEN 89 PRECEDING AND CURRENT ROW
    ) AS avg_90_day
FROM daily_sales;
```

### Pattern 5: Cohort Analysis with GROUPING SETS

```sql
-- Analyze retention by signup month and month number
SELECT
    DATE_TRUNC('month', signup_date) AS cohort_month,
    EXTRACT(MONTH FROM AGE(activity_date, signup_date)) AS months_since_signup,
    COUNT(DISTINCT user_id) AS active_users,
    GROUPING(DATE_TRUNC('month', signup_date)) AS is_total_across_cohorts,
    GROUPING(EXTRACT(MONTH FROM AGE(activity_date, signup_date))) AS is_total_across_months
FROM user_activity
GROUP BY GROUPING SETS (
    (DATE_TRUNC('month', signup_date), EXTRACT(MONTH FROM AGE(activity_date, signup_date))),
    (DATE_TRUNC('month', signup_date)),
    (EXTRACT(MONTH FROM AGE(activity_date, signup_date))),
    ()
);
```

---

## Histogram and Distribution Analysis

### Creating Histograms

```sql
-- Bucket values into ranges
SELECT
    WIDTH_BUCKET(price, 0, 1000, 10) AS price_bucket,
    COUNT(*) AS product_count,
    MIN(price) AS min_price,
    MAX(price) AS max_price
FROM products
WHERE price BETWEEN 0 AND 1000
GROUP BY WIDTH_BUCKET(price, 0, 1000, 10)
ORDER BY price_bucket;

-- Creates 10 equal-width buckets from 0 to 1000
-- Bucket 1: 0-100, Bucket 2: 100-200, etc.
```

### Quantile-Based Bucketing

```sql
-- Create quartile buckets
SELECT
    product_id,
    price,
    NTILE(4) OVER (ORDER BY price) AS price_quartile
FROM products;

-- Creates 4 roughly equal-sized groups
-- Quartile 1: bottom 25%, Quartile 4: top 25%
```

---

## Practical Examples

### Example 1: Sales Dashboard with Multiple Dimensions

```sql
SELECT
    COALESCE(region, 'All Regions') AS region,
    COALESCE(product_category, 'All Categories') AS category,
    COALESCE(TO_CHAR(sale_date, 'YYYY-MM'), 'All Months') AS month,
    SUM(amount) AS total_sales,
    COUNT(DISTINCT order_id) AS order_count,
    AVG(amount) AS avg_order_value
FROM sales
WHERE sale_date >= '2024-01-01'
GROUP BY CUBE(region, product_category, TO_CHAR(sale_date, 'YYYY-MM'))
ORDER BY region, category, month;
```

### Example 2: Percentile-Based Customer Segmentation

```sql
WITH customer_stats AS (
    SELECT
        customer_id,
        SUM(order_amount) AS total_spent,
        COUNT(*) AS order_count,
        PERCENTILE_CONT(0.33) WITHIN GROUP (ORDER BY SUM(order_amount)) OVER () AS p33,
        PERCENTILE_CONT(0.67) WITHIN GROUP (ORDER BY SUM(order_amount)) OVER () AS p67
    FROM orders
    GROUP BY customer_id
)
SELECT
    customer_id,
    total_spent,
    order_count,
    CASE
        WHEN total_spent <= p33 THEN 'Bronze'
        WHEN total_spent <= p67 THEN 'Silver'
        ELSE 'Gold'
    END AS customer_tier
FROM customer_stats;
```

### Example 3: Year-over-Year Growth with ROLLUP

```sql
SELECT
    EXTRACT(YEAR FROM order_date) AS year,
    product_category,
    SUM(amount) AS revenue,
    LAG(SUM(amount)) OVER (
        PARTITION BY product_category
        ORDER BY EXTRACT(YEAR FROM order_date)
    ) AS prev_year_revenue,
    (SUM(amount) - LAG(SUM(amount)) OVER (
        PARTITION BY product_category
        ORDER BY EXTRACT(YEAR FROM order_date)
    )) * 100.0 / NULLIF(LAG(SUM(amount)) OVER (
        PARTITION BY product_category
        ORDER BY EXTRACT(YEAR FROM order_date)
    ), 0) AS yoy_growth_pct
FROM orders
GROUP BY ROLLUP(EXTRACT(YEAR FROM order_date), product_category)
ORDER BY year, product_category;
```

---

## Best Practices

### ✅ Do's

1. **Use GROUPING SETS** for custom aggregation combinations
2. **Use GROUPING() function** to label subtotal rows
3. **Calculate percentiles** for better distribution understanding
4. **Use PIVOT** for cross-tabulation reports
5. **Combine ROLLUP with filters** for hierarchical analysis
6. **Use CUBE** for multi-dimensional analysis
7. **Document aggregation levels** clearly in reports

### ❌ Don'ts

1. **Don't use CUBE with many dimensions** (exponential row growth)
2. **Don't forget NULL handling** in subtotal rows
3. **Don't mix ROLLUP/CUBE inappropriately** - understand differences
4. **Don't calculate percentiles on small samples** (unreliable)
5. **Don't pivot too many columns** (wide tables, slow queries)

---

## Related Concepts

- [[Window Functions - Advanced SQL Analytics]] - Core window functions
- [[Data Modeling & Table Design]] - Dimensional modeling
- [[SQL Basics - Quick Reference]] - GROUP BY fundamentals
- [[CTEs - Common Table Expressions]] - Organizing complex analytics

---

## Key Takeaways

1. **ROLLUP** creates hierarchical subtotals (organizational structure)
2. **CUBE** creates all possible subtotal combinations (cross-dimensional)
3. **GROUPING SETS** provides custom aggregation combinations
4. **GROUPING()** identifies which rows are subtotals vs detail
5. **PIVOT/UNPIVOT** reshape data between row and column formats
6. **Percentiles** provide better insights than averages for distributions
7. **Statistical functions** (STDDEV, CORR, REGR) enable advanced analysis
8. Choose appropriate aggregation based on analysis needs - not all require CUBE
