---
title: Data Definition Language (DDL)
date: 2025-10-14
tags: [sql, ddl, create, alter, drop, constraints, data-types, partitioning, data-engineering, foundation-basics]
status: active
learning_phase: "Foundation (Basics)"
---

# Data Definition Language (DDL)

## Overview

**DDL (Data Definition Language)** consists of SQL commands used to define and modify database structure. These commands create, alter, and delete database objects like tables, indexes, and schemas.

**Core DDL Commands:**
- CREATE - Create new objects
- ALTER - Modify existing objects
- DROP - Delete objects
- TRUNCATE - Remove all data from table

---

## CREATE - Creating Database Objects

### CREATE DATABASE

```sql
-- Create database
CREATE DATABASE ecommerce;

-- Create database if it doesn't exist
CREATE DATABASE IF NOT EXISTS ecommerce;

-- Create database with specific encoding (PostgreSQL)
CREATE DATABASE ecommerce
    ENCODING 'UTF8'
    LC_COLLATE = 'en_US.UTF-8'
    LC_CTYPE = 'en_US.UTF-8';
```

### CREATE SCHEMA

```sql
-- Create schema (namespace for tables)
CREATE SCHEMA sales;

-- Create schema with authorization
CREATE SCHEMA sales AUTHORIZATION sales_admin;

-- Use schema
SET search_path TO sales;

-- Or reference explicitly
SELECT * FROM sales.orders;
```

### CREATE TABLE - Basic Syntax

```sql
CREATE TABLE customers (
    customer_id INT,
    name VARCHAR(100),
    email VARCHAR(100),
    signup_date DATE,
    is_active BOOLEAN
);
```

### CREATE TABLE with Constraints

```sql
CREATE TABLE customers (
    -- Primary key
    customer_id INT PRIMARY KEY,

    -- Not null constraint
    name VARCHAR(100) NOT NULL,

    -- Unique constraint
    email VARCHAR(100) UNIQUE NOT NULL,

    -- Check constraint
    age INT CHECK (age >= 18),

    -- Default value
    signup_date DATE DEFAULT CURRENT_DATE,
    is_active BOOLEAN DEFAULT TRUE,

    -- Foreign key (inline)
    country_id INT REFERENCES countries(country_id)
);
```

### CREATE TABLE with Multiple Constraints

```sql
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Table-level constraints
    CONSTRAINT fk_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,

    CONSTRAINT chk_status
        CHECK (status IN ('pending', 'processing', 'shipped', 'delivered', 'cancelled')),

    CONSTRAINT chk_amount
        CHECK (total_amount >= 0),

    CONSTRAINT uk_order_date_customer
        UNIQUE (order_date, customer_id)
);
```

### CREATE TABLE from SELECT

```sql
-- Create table with data from query
CREATE TABLE high_value_customers AS
SELECT
    customer_id,
    name,
    email,
    total_spent
FROM customers
WHERE total_spent > 10000;

-- Create empty table with same structure
CREATE TABLE customers_backup AS
SELECT * FROM customers
WHERE 1 = 0;  -- False condition, no rows copied
```

### CREATE TEMPORARY TABLE

```sql
-- Temporary table (exists only for session)
CREATE TEMPORARY TABLE temp_calculations (
    id INT,
    value DECIMAL(10,2),
    calculated_result DECIMAL(10,2)
);

-- Automatically dropped at end of session
```

---

## Data Types

### Numeric Types

```sql
CREATE TABLE numeric_examples (
    -- Integers
    tiny_int TINYINT,           -- 1 byte: -128 to 127
    small_int SMALLINT,         -- 2 bytes: -32,768 to 32,767
    medium_int MEDIUMINT,       -- 3 bytes (MySQL)
    regular_int INT,            -- 4 bytes: -2B to 2B
    big_int BIGINT,             -- 8 bytes: -9 quintillion to 9 quintillion

    -- Decimals (exact)
    price DECIMAL(10,2),        -- 10 total digits, 2 after decimal
    amount NUMERIC(15,4),       -- Same as DECIMAL

    -- Floating point (approximate)
    measurement FLOAT,          -- 4 bytes, ~7 decimal digits precision
    scientific DOUBLE,          -- 8 bytes, ~15 decimal digits precision

    -- Auto-increment
    id SERIAL,                  -- PostgreSQL: auto-incrementing integer
    -- id INT AUTO_INCREMENT,   -- MySQL syntax
);
```

**Best Practices:**
- Use **DECIMAL/NUMERIC** for money (exact)
- Use **INT/BIGINT** for counts, IDs
- Use **FLOAT/DOUBLE** only for scientific data
- Use **BIGINT** for timestamps, large IDs

### String Types

```sql
CREATE TABLE string_examples (
    -- Fixed length (padded with spaces)
    country_code CHAR(2),       -- Exactly 2 characters
    product_sku CHAR(10),       -- Exactly 10 characters

    -- Variable length
    name VARCHAR(100),          -- Up to 100 characters
    email VARCHAR(255),         -- Common email length
    description TEXT,           -- Unlimited length (typically)

    -- Binary data
    profile_image BLOB,         -- Binary Large Object
    file_data BYTEA             -- PostgreSQL binary
);
```

**Length Guidelines:**
- Email: VARCHAR(255)
- Name: VARCHAR(100)
- Phone: VARCHAR(20)
- URL: VARCHAR(2000)
- Short descriptions: VARCHAR(500)
- Long text: TEXT

### Date and Time Types

```sql
CREATE TABLE datetime_examples (
    -- Date only
    birth_date DATE,            -- YYYY-MM-DD

    -- Time only
    opening_time TIME,          -- HH:MM:SS

    -- Date and time
    created_at TIMESTAMP,       -- YYYY-MM-DD HH:MM:SS
    updated_at TIMESTAMPTZ,     -- With timezone (PostgreSQL)

    -- Year only
    year_established YEAR       -- MySQL: 1901 to 2155
);
```

### Boolean Type

```sql
CREATE TABLE boolean_examples (
    is_active BOOLEAN,          -- TRUE/FALSE
    is_deleted BOOLEAN DEFAULT FALSE,
    is_premium BOOLEAN NOT NULL DEFAULT FALSE
);
```

### JSON Types

```sql
CREATE TABLE json_examples (
    -- JSON data (PostgreSQL, MySQL 5.7+)
    metadata JSON,
    settings JSONB,             -- Binary JSON (PostgreSQL, more efficient)

    -- Example usage
    user_preferences JSONB DEFAULT '{}'::JSONB
);
```

### Array Types (PostgreSQL)

```sql
CREATE TABLE array_examples (
    tags TEXT[],                -- Array of strings
    scores INT[],               -- Array of integers
    matrix INT[][]              -- Multi-dimensional array
);
```

---

## Constraints

### PRIMARY KEY

```sql
-- Single column primary key
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100)
);

-- Composite primary key
CREATE TABLE order_items (
    order_id INT,
    product_id INT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);

-- Named primary key
CREATE TABLE customers (
    customer_id INT,
    name VARCHAR(100),
    CONSTRAINT pk_customers PRIMARY KEY (customer_id)
);
```

### FOREIGN KEY

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,

    -- Foreign key with actions
    CONSTRAINT fk_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON DELETE CASCADE           -- Delete orders when customer deleted
        ON UPDATE CASCADE           -- Update if customer_id changes
);

-- Foreign key actions:
-- CASCADE - propagate change
-- SET NULL - set to NULL
-- SET DEFAULT - set to default value
-- RESTRICT - prevent deletion/update
-- NO ACTION - same as RESTRICT
```

### UNIQUE

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),

    -- Composite unique constraint
    CONSTRAINT uk_phone_country UNIQUE (phone, country_code)
);
```

### NOT NULL

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    description TEXT             -- NULL allowed
);
```

### CHECK

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INT CHECK (age >= 18 AND age <= 100),
    salary DECIMAL(10,2) CHECK (salary > 0),
    status VARCHAR(20) CHECK (status IN ('active', 'inactive', 'terminated')),

    -- Multiple column check
    CONSTRAINT chk_dates CHECK (start_date <= end_date)
);
```

### DEFAULT

```sql
CREATE TABLE audit_log (
    log_id BIGINT PRIMARY KEY,
    event_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_processed BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'pending'
);
```

---

## ALTER - Modifying Tables

### ADD COLUMN

```sql
-- Add single column
ALTER TABLE customers
ADD COLUMN phone VARCHAR(20);

-- Add column with default
ALTER TABLE customers
ADD COLUMN loyalty_points INT DEFAULT 0;

-- Add multiple columns
ALTER TABLE customers
ADD COLUMN address VARCHAR(200),
ADD COLUMN city VARCHAR(50),
ADD COLUMN postal_code VARCHAR(20);
```

### DROP COLUMN

```sql
-- Drop single column
ALTER TABLE customers
DROP COLUMN phone;

-- Drop multiple columns
ALTER TABLE customers
DROP COLUMN address,
DROP COLUMN city;

-- Drop with cascade (removes dependent objects)
ALTER TABLE customers
DROP COLUMN email CASCADE;
```

### MODIFY/ALTER COLUMN

```sql
-- Change data type (PostgreSQL)
ALTER TABLE customers
ALTER COLUMN phone TYPE VARCHAR(30);

-- Change data type (MySQL)
ALTER TABLE customers
MODIFY COLUMN phone VARCHAR(30);

-- Set NOT NULL
ALTER TABLE customers
ALTER COLUMN email SET NOT NULL;

-- Drop NOT NULL
ALTER TABLE customers
ALTER COLUMN phone DROP NOT NULL;

-- Set default
ALTER TABLE customers
ALTER COLUMN status SET DEFAULT 'active';

-- Drop default
ALTER TABLE customers
ALTER COLUMN status DROP DEFAULT;
```

### RENAME COLUMN

```sql
-- Rename column (PostgreSQL, MySQL 8.0+)
ALTER TABLE customers
RENAME COLUMN phone TO phone_number;

-- MySQL older versions
ALTER TABLE customers
CHANGE COLUMN phone phone_number VARCHAR(20);
```

### ADD/DROP CONSTRAINTS

```sql
-- Add primary key
ALTER TABLE customers
ADD PRIMARY KEY (customer_id);

-- Add foreign key
ALTER TABLE orders
ADD CONSTRAINT fk_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers(customer_id);

-- Add unique constraint
ALTER TABLE customers
ADD CONSTRAINT uk_email UNIQUE (email);

-- Add check constraint
ALTER TABLE products
ADD CONSTRAINT chk_price CHECK (price > 0);

-- Drop constraint
ALTER TABLE orders
DROP CONSTRAINT fk_customer;

-- Drop primary key
ALTER TABLE customers
DROP PRIMARY KEY;
```

### RENAME TABLE

```sql
-- Rename table
ALTER TABLE customers RENAME TO clients;

-- Or (PostgreSQL)
ALTER TABLE customers RENAME TO clients;

-- MySQL specific
RENAME TABLE old_name TO new_name;
```

---

## DROP - Deleting Objects

### DROP TABLE

```sql
-- Drop table
DROP TABLE customers;

-- Drop if exists (no error if doesn't exist)
DROP TABLE IF EXISTS customers;

-- Drop with cascade (removes dependent objects)
DROP TABLE customers CASCADE;

-- Drop multiple tables
DROP TABLE orders, order_items, customers;
```

### DROP DATABASE

```sql
-- Drop database
DROP DATABASE ecommerce;

-- Drop if exists
DROP DATABASE IF EXISTS ecommerce;
```

### DROP INDEX

```sql
-- Drop index
DROP INDEX idx_customers_email;

-- Drop if exists
DROP INDEX IF EXISTS idx_customers_email;

-- PostgreSQL syntax
DROP INDEX IF EXISTS idx_customers_email CASCADE;
```

---

## TRUNCATE - Remove All Data

```sql
-- Remove all rows (fast, resets auto-increment)
TRUNCATE TABLE staging_data;

-- With cascade (also truncate referencing tables)
TRUNCATE TABLE customers CASCADE;

-- Multiple tables
TRUNCATE TABLE orders, order_items;
```

**TRUNCATE vs DELETE:**

| Feature | TRUNCATE | DELETE |
|---------|----------|--------|
| Speed | Very fast | Slower |
| WHERE clause | No | Yes |
| Rollback | Usually no | Yes |
| Triggers | Doesn't fire | Fires |
| Auto-increment | Resets | Preserves |
| Logging | Minimal | Full |

---

## Partitioning

### Range Partitioning

```sql
-- PostgreSQL
CREATE TABLE sales (
    sale_id BIGINT,
    sale_date DATE NOT NULL,
    amount DECIMAL(10,2)
) PARTITION BY RANGE (sale_date);

-- Create partitions
CREATE TABLE sales_2024_q1 PARTITION OF sales
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE sales_2024_q2 PARTITION OF sales
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

CREATE TABLE sales_2024_q3 PARTITION OF sales
    FOR VALUES FROM ('2024-07-01') TO ('2024-10-01');

CREATE TABLE sales_2024_q4 PARTITION OF sales
    FOR VALUES FROM ('2024-10-01') TO ('2025-01-01');
```

### List Partitioning

```sql
CREATE TABLE sales_by_region (
    sale_id BIGINT,
    region VARCHAR(20) NOT NULL,
    amount DECIMAL(10,2)
) PARTITION BY LIST (region);

CREATE TABLE sales_north_america PARTITION OF sales_by_region
    FOR VALUES IN ('USA', 'Canada', 'Mexico');

CREATE TABLE sales_europe PARTITION OF sales_by_region
    FOR VALUES IN ('UK', 'Germany', 'France', 'Spain');

CREATE TABLE sales_asia PARTITION OF sales_by_region
    FOR VALUES IN ('China', 'Japan', 'India');
```

### Hash Partitioning

```sql
CREATE TABLE orders (
    order_id BIGINT,
    customer_id INT,
    amount DECIMAL(10,2)
) PARTITION BY HASH (customer_id);

-- Create hash partitions
CREATE TABLE orders_p0 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

---

## Indexes

### CREATE INDEX

```sql
-- Basic index
CREATE INDEX idx_customers_email ON customers(email);

-- Unique index
CREATE UNIQUE INDEX idx_customers_email_unique ON customers(email);

-- Composite index
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- Partial index (filtered)
CREATE INDEX idx_active_customers ON customers(customer_id)
WHERE is_active = TRUE;

-- Expression index
CREATE INDEX idx_email_lower ON customers(LOWER(email));

-- Covering index (PostgreSQL)
CREATE INDEX idx_orders_covering ON orders(customer_id)
INCLUDE (order_date, total_amount);
```

### DROP INDEX

```sql
DROP INDEX idx_customers_email;

-- If exists
DROP INDEX IF EXISTS idx_customers_email;
```

---

## Views

### CREATE VIEW

```sql
-- Simple view
CREATE VIEW active_customers AS
SELECT customer_id, name, email
FROM customers
WHERE is_active = TRUE;

-- View with joins
CREATE VIEW order_summary AS
SELECT
    o.order_id,
    c.name AS customer_name,
    o.order_date,
    o.total_amount
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id;

-- View with aggregation
CREATE VIEW customer_stats AS
SELECT
    c.customer_id,
    c.name,
    COUNT(o.order_id) AS total_orders,
    SUM(o.total_amount) AS total_spent
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name;
```

### CREATE OR REPLACE VIEW

```sql
-- Update view definition
CREATE OR REPLACE VIEW active_customers AS
SELECT customer_id, name, email, signup_date
FROM customers
WHERE is_active = TRUE
  AND signup_date >= '2024-01-01';
```

### MATERIALIZED VIEW

```sql
-- PostgreSQL materialized view (stores results)
CREATE MATERIALIZED VIEW daily_sales AS
SELECT
    DATE(order_date) AS sale_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS revenue
FROM orders
GROUP BY DATE(order_date);

-- Refresh materialized view
REFRESH MATERIALIZED VIEW daily_sales;

-- Concurrent refresh (doesn't lock view)
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales;
```

### DROP VIEW

```sql
DROP VIEW active_customers;

-- If exists
DROP VIEW IF EXISTS active_customers;

-- With cascade
DROP VIEW order_summary CASCADE;
```

---

## Sequences (Auto-increment)

### CREATE SEQUENCE

```sql
-- PostgreSQL sequence
CREATE SEQUENCE customer_id_seq
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 9999999999
    CACHE 1;

-- Use in table
CREATE TABLE customers (
    customer_id INT DEFAULT nextval('customer_id_seq') PRIMARY KEY,
    name VARCHAR(100)
);

-- Or use SERIAL (shorthand)
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,  -- Automatically creates sequence
    name VARCHAR(100)
);
```

### ALTER SEQUENCE

```sql
-- Reset sequence
ALTER SEQUENCE customer_id_seq RESTART WITH 1;

-- Change increment
ALTER SEQUENCE customer_id_seq INCREMENT BY 10;
```

---

## Common Table Patterns

### Audit Columns Pattern

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,

    -- Audit columns
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by VARCHAR(50),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(50)
);
```

### Soft Delete Pattern

```sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,

    -- Soft delete columns
    is_deleted BOOLEAN DEFAULT FALSE,
    deleted_at TIMESTAMP,
    deleted_by VARCHAR(50)
);

-- Query only active records
CREATE VIEW active_customers AS
SELECT * FROM customers WHERE is_deleted = FALSE;
```

### Versioning Pattern

```sql
CREATE TABLE product_versions (
    version_id INT PRIMARY KEY,
    product_id INT NOT NULL,
    name VARCHAR(100),
    price DECIMAL(10,2),
    version_number INT NOT NULL,
    effective_date TIMESTAMP NOT NULL,
    expiration_date TIMESTAMP,
    is_current BOOLEAN DEFAULT TRUE,

    UNIQUE (product_id, version_number)
);
```

---

## Best Practices

### Naming Conventions

```sql
-- Tables: plural, lowercase with underscores
customers
order_items
user_preferences

-- Columns: singular, lowercase with underscores
customer_id
first_name
created_at

-- Indexes: idx_table_column(s)
idx_customers_email
idx_orders_customer_date

-- Constraints: type_table_column(s)
pk_customers
fk_orders_customer
uk_customers_email
chk_products_price
```

### Always Include

```sql
CREATE TABLE example (
    -- Surrogate primary key
    id BIGINT PRIMARY KEY,

    -- Business columns
    name VARCHAR(100) NOT NULL,

    -- Audit trail
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Soft delete
    is_deleted BOOLEAN DEFAULT FALSE
);
```

### Data Type Selection

```sql
-- ✅ GOOD: Appropriate types
CREATE TABLE good_example (
    id BIGINT,                          -- Large enough for scale
    amount DECIMAL(10,2),               -- Exact for money
    email VARCHAR(255),                 -- Standard email length
    created_at TIMESTAMP                -- Date and time
);

-- ❌ BAD: Inappropriate types
CREATE TABLE bad_example (
    id INT,                             -- Too small, will overflow
    amount FLOAT,                       -- Imprecise for money
    email VARCHAR(50),                  -- Too short
    created_at VARCHAR(50)              -- Storing date as string
);
```

---

## Related Concepts

- [[Data Manipulation (DML)]] - INSERT, UPDATE, DELETE
- [[Data Modeling & Table Design]] - Schema design principles
- [[SQL Indexes - Performance Optimization]] - Indexing strategies
- [[SQL Basics - Quick Reference]] - Foundation SQL

---

## Key Takeaways

1. **DDL defines structure**, DML manipulates data
2. **Choose appropriate data types** - DECIMAL for money, BIGINT for large IDs
3. **Use constraints** to enforce data integrity
4. **Add audit columns** (created_at, updated_at) to all tables
5. **Use IF EXISTS/IF NOT EXISTS** to make scripts idempotent
6. **Partition large tables** by date for better performance
7. **Name consistently** - Use clear, standard naming conventions
8. **Include indexes** on foreign keys and frequently queried columns
