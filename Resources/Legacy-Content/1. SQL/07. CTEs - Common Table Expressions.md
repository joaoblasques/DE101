---
title: CTEs - Common Table Expressions
date: 2025-10-14
tags: [sql, cte, data-engineering, query-optimization, advanced-queries]
source: https://de101.startdataengineering.com/cte
status: active
learning_phase: "Advanced Queries (Analytical)"
---

# CTEs - Common Table Expressions

## Overview

A **CTE (Common Table Expression)** is a named SELECT statement that can be reused within a single query. CTEs provide a way to write more readable and maintainable SQL by breaking complex queries into logical, reusable components.

## Why Use CTEs?

1. **Improve code readability** - Makes complex queries easier to understand
2. **Reduce query complexity** - Break down monolithic queries into digestible parts
3. **Simplify testing** - Test individual CTEs independently
4. **Enhance maintainability** - Easier to modify and debug specific parts
5. **Avoid code repetition** - Reference the same subquery multiple times without duplicating code

## Basic Syntax

### Single CTE

```sql
WITH cte_name AS (
    SELECT column1, column2
    FROM table_name
    WHERE condition
)
SELECT *
FROM cte_name;
```

### Multiple CTEs

```sql
WITH
  first_cte AS (
    SELECT column1, column2
    FROM table1
  ),
  second_cte AS (
    SELECT column3, column4
    FROM table2
  )
SELECT
    f.column1,
    s.column3
FROM first_cte f
JOIN second_cte s ON f.column1 = s.column3;
```

**Important:** The last CTE does not have a comma after it.

## Practical Example

### Calculating Discount Impact on Orders

This example calculates how much revenue was lost to discounts:

```sql
WITH lineitem_agg AS (
    SELECT
        l_orderkey,
        SUM(l_extendedprice) AS total_price_without_discount
    FROM
        lineitem
    GROUP BY
        l_orderkey
)
SELECT
    o.o_orderkey,
    o.o_totalprice,
    l.total_price_without_discount - o.o_totalprice AS amount_lost_to_discount
FROM
    orders o
JOIN
    lineitem_agg l ON o.o_orderkey = l.l_orderkey;
```

**Benefits of this approach:**
- The aggregation logic is isolated in `lineitem_agg`
- The main query focuses on the business logic (calculating discount impact)
- Easy to test the aggregation independently

## Advanced CTE Patterns

### Recursive CTEs

CTEs can be recursive, useful for hierarchical data or graph traversal:

```sql
WITH RECURSIVE employee_hierarchy AS (
    -- Base case: top-level employees
    SELECT
        employee_id,
        name,
        manager_id,
        1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: employees with managers
    SELECT
        e.employee_id,
        e.name,
        e.manager_id,
        eh.level + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM employee_hierarchy;
```

### Chaining CTEs for Complex Transformations

```sql
WITH
  -- Step 1: Filter data
  filtered_orders AS (
    SELECT *
    FROM orders
    WHERE o_orderdate >= '2024-01-01'
  ),
  -- Step 2: Aggregate
  order_summary AS (
    SELECT
        o_custkey,
        COUNT(*) AS order_count,
        SUM(o_totalprice) AS total_spent
    FROM filtered_orders
    GROUP BY o_custkey
  ),
  -- Step 3: Enrich with customer data
  customer_metrics AS (
    SELECT
        c.c_name,
        c.c_mktsegment,
        os.order_count,
        os.total_spent,
        os.total_spent / os.order_count AS avg_order_value
    FROM order_summary os
    JOIN customer c ON os.o_custkey = c.c_custkey
  )
SELECT *
FROM customer_metrics
WHERE avg_order_value > 1000
ORDER BY total_spent DESC;
```

## Best Practices

### Do's ✅

1. **Keep CTEs focused** - Each CTE should do one thing well
2. **Use descriptive names** - Names like `high_value_customers` instead of `cte1`
3. **Limit CTE count** - Keep it under 5 CTEs per query for readability
4. **Add comments** - Explain the purpose of each CTE
5. **Format consistently** - Use indentation and line breaks for clarity

### Don'ts ❌

1. **Avoid overuse** - If a CTE is used across multiple queries, create a VIEW or TABLE instead
2. **Don't nest too deeply** - More than 3-4 levels of CTE dependencies can be confusing
3. **Avoid performance assumptions** - CTEs may not always be materialized; test performance
4. **Don't use for simple queries** - A single SELECT is clearer than a one-line CTE

## CTEs vs Subqueries vs Views

| Feature | CTE | Subquery | View |
|---------|-----|----------|------|
| **Scope** | Single query | Single query | Database-wide |
| **Reusability** | Within query | No | Across queries |
| **Readability** | High | Medium | High |
| **Performance** | Similar to subquery | Varies | Cached/optimized |
| **Maintenance** | Query-level | Query-level | Schema-level |

### When to Use What?

- **CTE**: Complex queries needing multiple steps, better readability
- **Subquery**: Simple one-off calculations, filtering
- **View**: Logic reused across multiple queries, abstraction layer

## Performance Considerations

### Materialization
- Some databases (PostgreSQL 12+) can materialize CTEs
- Use `MATERIALIZED` or `NOT MATERIALIZED` hints when available
- Test both approaches for performance-critical queries

```sql
-- PostgreSQL syntax
WITH MATERIALIZED orders_2024 AS (
    SELECT * FROM orders WHERE o_orderdate >= '2024-01-01'
)
SELECT * FROM orders_2024;
```

### Optimization Tips
1. **Filter early** - Apply WHERE clauses in CTEs to reduce data volume
2. **Index appropriately** - Ensure base tables have proper indexes
3. **Analyze execution plans** - Use `EXPLAIN` to understand query performance
4. **Consider temporary tables** - For very large intermediate results

## Common Use Cases

1. **Data Transformation Pipelines** - Step-by-step data cleaning and transformation
2. **Hierarchical Queries** - Organization charts, bill of materials, category trees
3. **Running Calculations** - Year-over-year comparisons, cumulative sums
4. **Code Reuse** - Reference the same subquery multiple times
5. **Debugging Complex Queries** - Isolate and test individual components

## Example: Multi-Step Analytics Query

```sql
WITH
  -- Get recent orders
  recent_orders AS (
    SELECT *
    FROM orders
    WHERE o_orderdate >= CURRENT_DATE - INTERVAL '90 days'
  ),
  -- Calculate customer metrics
  customer_stats AS (
    SELECT
        o_custkey,
        COUNT(*) AS order_count,
        SUM(o_totalprice) AS total_revenue,
        AVG(o_totalprice) AS avg_order_value
    FROM recent_orders
    GROUP BY o_custkey
  ),
  -- Segment customers
  customer_segments AS (
    SELECT
        *,
        CASE
            WHEN total_revenue > 10000 THEN 'Premium'
            WHEN total_revenue > 5000 THEN 'Gold'
            WHEN total_revenue > 1000 THEN 'Silver'
            ELSE 'Bronze'
        END AS segment
    FROM customer_stats
  )
SELECT
    segment,
    COUNT(*) AS customer_count,
    SUM(total_revenue) AS segment_revenue,
    AVG(avg_order_value) AS segment_avg_order
FROM customer_segments
GROUP BY segment
ORDER BY segment_revenue DESC;
```

## Related Concepts

- [[SQL Basics - Quick Reference]] - Foundation SQL concepts
- [[Dimensional Data Modeling - Day 1]] - Data warehouse design
- Window Functions - Often used with CTEs for advanced analytics
- Temporary Tables - Alternative for complex transformations

## References

- [Data Engineering 101 - CTEs](https://de101.startdataengineering.com/cte)
- PostgreSQL Documentation: WITH Queries
- SQL Standard: Common Table Expressions

---

## Key Takeaways

1. CTEs make SQL more readable by breaking complex logic into named components
2. Use the `WITH` keyword to define one or more CTEs before your main query
3. Keep CTEs simple and focused (< 5 per query)
4. For frequently reused logic, consider creating views or tables instead
5. CTEs are excellent for testing, debugging, and maintaining complex queries
