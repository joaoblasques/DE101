---
title: Window Functions - Advanced SQL Analytics
date: 2025-10-14
tags: [sql, window-functions, analytics, data-engineering, advanced-sql, advanced-queries]
source: https://de101.startdataengineering.com/windows
status: active
learning_phase: "Advanced Queries (Analytical)"
---

# Window Functions - Advanced SQL Analytics

## Overview

**Window functions** allow you to operate on a set of rows at a time and produce output that has the **exact same grain as the input**. This is fundamentally different from `GROUP BY`, which aggregates rows and changes the output granularity.

### Key Difference: Window Functions vs GROUP BY

| Feature | Window Functions | GROUP BY |
|---------|-----------------|----------|
| **Output Rows** | Same as input | Aggregated (fewer rows) |
| **Row Context** | Preserves individual rows | Collapses to groups |
| **Use Case** | Running totals, rankings, row comparisons | Summary statistics |
| **Access to Other Rows** | Yes | No |

**When to use Window Functions:** Need to use values from other rows to compute a value for the current row without losing row-level detail.

## Core Concepts

### 1. Partition
Defines a set of rows based on specified column(s). Rows with the same partition values are grouped together for the window function calculation.

```sql
PARTITION BY column_name
```

### 2. Order By
Specifies the ordering of rows within each partition. Critical for ranking and analytical functions.

```sql
ORDER BY column_name [ASC|DESC]
```

### 3. Window Frame
Specifies which rows relative to the current row should be included in the function computation.

```sql
ROWS BETWEEN start_point AND end_point
RANGE BETWEEN start_point AND end_point
```

## Window Function Syntax

```sql
SELECT
    column1,
    column2,
    FUNCTION_NAME() OVER (
        PARTITION BY partition_column
        ORDER BY order_column
        [ROWS/RANGE BETWEEN start AND end]
    ) AS window_result
FROM table_name;
```

## Types of Window Functions

### 1. Ranking Functions

#### ROW_NUMBER()
Assigns a unique sequential integer to each row within a partition.

```sql
SELECT
    c_name,
    c_mktsegment,
    total_spent,
    ROW_NUMBER() OVER (
        PARTITION BY c_mktsegment
        ORDER BY total_spent DESC
    ) AS row_num
FROM customer_summary;
```

**Output:**
| c_name | c_mktsegment | total_spent | row_num |
|--------|--------------|-------------|---------|
| Alice  | AUTOMOBILE   | 50000       | 1       |
| Bob    | AUTOMOBILE   | 45000       | 2       |
| Carol  | BUILDING     | 60000       | 1       |
| Dave   | BUILDING     | 60000       | 2       |

**Use cases:**
- Paginating results
- Deduplication (keeping first/last occurrence)
- Assigning unique identifiers within groups

#### RANK()
Assigns ranks to rows with gaps for ties. If two rows tie for rank 2, the next rank is 4.

```sql
SELECT
    product_name,
    category,
    sales,
    RANK() OVER (
        PARTITION BY category
        ORDER BY sales DESC
    ) AS sales_rank
FROM products;
```

**Output with ties:**
| product | category | sales | sales_rank |
|---------|----------|-------|------------|
| A       | Tech     | 1000  | 1          |
| B       | Tech     | 900   | 2          |
| C       | Tech     | 900   | 2          |
| D       | Tech     | 800   | 4          |

#### DENSE_RANK()
Assigns ranks without gaps. If two rows tie for rank 2, the next rank is 3.

```sql
SELECT
    product_name,
    category,
    sales,
    DENSE_RANK() OVER (
        PARTITION BY category
        ORDER BY sales DESC
    ) AS dense_sales_rank
FROM products;
```

**Output with ties:**
| product | category | sales | dense_sales_rank |
|---------|----------|-------|------------------|
| A       | Tech     | 1000  | 1                |
| B       | Tech     | 900   | 2                |
| C       | Tech     | 900   | 2                |
| D       | Tech     | 800   | 3                |

### 2. Aggregate Window Functions

Standard aggregate functions can be used as window functions:

#### Running Totals (Cumulative Sum)

```sql
SELECT
    order_date,
    order_amount,
    SUM(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM orders;
```

#### Moving Average

```sql
SELECT
    order_date,
    order_amount,
    AVG(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS three_day_moving_avg
FROM daily_orders;
```

#### Percentage of Total

```sql
SELECT
    product_name,
    category,
    sales,
    sales * 100.0 / SUM(sales) OVER (PARTITION BY category) AS pct_of_category_sales
FROM product_sales;
```

### 3. Value Functions

#### LAG()
Access data from a previous row (n rows back).

```sql
SELECT
    order_date,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY order_date) AS previous_day_revenue,
    revenue - LAG(revenue, 1) OVER (ORDER BY order_date) AS day_over_day_change
FROM daily_revenue;
```

**Parameters:**
- First: Column to retrieve
- Second: Number of rows back (default: 1)
- Third: Default value if no previous row exists

#### LEAD()
Access data from a subsequent row (n rows ahead).

```sql
SELECT
    order_date,
    revenue,
    LEAD(revenue, 1) OVER (ORDER BY order_date) AS next_day_revenue,
    LEAD(revenue, 1) OVER (ORDER BY order_date) - revenue AS expected_growth
FROM daily_revenue;
```

#### FIRST_VALUE()
Returns the first value in the window frame.

```sql
SELECT
    employee_name,
    department,
    salary,
    FIRST_VALUE(salary) OVER (
        PARTITION BY department
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS highest_dept_salary
FROM employees;
```

#### LAST_VALUE()
Returns the last value in the window frame.

```sql
SELECT
    order_date,
    order_amount,
    LAST_VALUE(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS most_recent_order
FROM orders;
```

**Important:** Always specify `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` with `LAST_VALUE()` to ensure you get the actual last value in the partition.

#### NTILE(n)
Divides rows into approximately equal groups (buckets).

```sql
SELECT
    customer_name,
    total_spent,
    NTILE(4) OVER (ORDER BY total_spent DESC) AS spending_quartile
FROM customer_summary;
```

**Use cases:**
- Creating percentile buckets
- Segmenting data into equal groups
- A/B test group assignment

## Window Frame Specifications

### Frame Types

#### 1. ROWS - Physical Row Position

```sql
-- Current row only (default for RANK, ROW_NUMBER)
ROWS BETWEEN CURRENT ROW AND CURRENT ROW

-- All previous rows and current row
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- 2 rows before to 1 row after (5-row window)
ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING

-- All rows in partition
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

#### 2. RANGE - Logical Value Range

```sql
-- All rows with same ORDER BY value
RANGE BETWEEN CURRENT ROW AND CURRENT ROW

-- Date range window (7-day trailing window)
RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW

-- Value range (within $100)
RANGE BETWEEN 100 PRECEDING AND 100 FOLLOWING
```

### Frame Boundaries

| Boundary | Description |
|----------|-------------|
| `UNBOUNDED PRECEDING` | Start of partition |
| `n PRECEDING` | n rows/values before current row |
| `CURRENT ROW` | Current row |
| `n FOLLOWING` | n rows/values after current row |
| `UNBOUNDED FOLLOWING` | End of partition |

## Practical Examples

### Example 1: Top N per Group

Find the top 3 customers by spending in each market segment:

```sql
WITH ranked_customers AS (
    SELECT
        c_name,
        c_mktsegment,
        total_spent,
        ROW_NUMBER() OVER (
            PARTITION BY c_mktsegment
            ORDER BY total_spent DESC
        ) AS rank
    FROM customer_summary
)
SELECT
    c_name,
    c_mktsegment,
    total_spent
FROM ranked_customers
WHERE rank <= 3;
```

### Example 2: Year-over-Year Growth

```sql
SELECT
    EXTRACT(YEAR FROM order_date) AS year,
    SUM(order_amount) AS annual_revenue,
    LAG(SUM(order_amount), 1) OVER (ORDER BY EXTRACT(YEAR FROM order_date)) AS prev_year_revenue,
    (SUM(order_amount) - LAG(SUM(order_amount), 1) OVER (ORDER BY EXTRACT(YEAR FROM order_date)))
        * 100.0 / LAG(SUM(order_amount), 1) OVER (ORDER BY EXTRACT(YEAR FROM order_date)) AS yoy_growth_pct
FROM orders
GROUP BY EXTRACT(YEAR FROM order_date);
```

### Example 3: Running Total with Reset

Calculate running total that resets for each customer:

```sql
SELECT
    customer_id,
    order_date,
    order_amount,
    SUM(order_amount) OVER (
        PARTITION BY customer_id
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS customer_lifetime_value
FROM orders
ORDER BY customer_id, order_date;
```

### Example 4: Deduplication with ROW_NUMBER

Keep only the most recent record for each customer:

```sql
WITH ranked_records AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY customer_id
            ORDER BY updated_at DESC
        ) AS rn
    FROM customer_records
)
SELECT *
FROM ranked_records
WHERE rn = 1;
```

### Example 5: Gap and Island Detection

Find consecutive date ranges:

```sql
WITH date_groups AS (
    SELECT
        user_id,
        activity_date,
        activity_date - ROW_NUMBER() OVER (
            PARTITION BY user_id
            ORDER BY activity_date
        ) * INTERVAL '1 DAY' AS group_id
    FROM user_activity
)
SELECT
    user_id,
    MIN(activity_date) AS streak_start,
    MAX(activity_date) AS streak_end,
    COUNT(*) AS streak_length
FROM date_groups
GROUP BY user_id, group_id;
```

### Example 6: Median Calculation

```sql
WITH ordered_salaries AS (
    SELECT
        department,
        salary,
        ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary) AS row_num,
        COUNT(*) OVER (PARTITION BY department) AS total_count
    FROM employees
)
SELECT
    department,
    AVG(salary) AS median_salary
FROM ordered_salaries
WHERE row_num IN (FLOOR((total_count + 1) / 2.0), CEIL((total_count + 1) / 2.0))
GROUP BY department;
```

## Performance Considerations

### Optimization Tips

1. **Use appropriate indexes** - Index columns in PARTITION BY and ORDER BY clauses
2. **Limit partitions** - Fewer, larger partitions are generally more efficient
3. **Specify frame bounds** - Explicit frames can improve performance
4. **Avoid redundant calculations** - Compute window functions once and reuse

### Example: Reusing Window Specifications

```sql
SELECT
    customer_id,
    order_date,
    order_amount,
    SUM(order_amount) OVER w AS running_total,
    AVG(order_amount) OVER w AS running_avg,
    COUNT(*) OVER w AS order_count
FROM orders
WINDOW w AS (PARTITION BY customer_id ORDER BY order_date);
```

## Common Patterns and Use Cases

### 1. Time-Series Analysis
- Moving averages
- Running totals
- Period-over-period comparisons
- Trend detection

### 2. Ranking and Top-N Queries
- Leaderboards
- Top performers per category
- Percentile calculations

### 3. Data Quality
- Deduplication
- Finding gaps in sequences
- Identifying anomalies

### 4. Business Analytics
- Customer lifetime value
- Cohort analysis
- Retention rates
- Conversion funnels

### 5. Financial Calculations
- Cumulative returns
- Rolling volatility
- Portfolio rebalancing

## Window Functions vs Alternatives

### Window Functions vs Self-Joins

**Window Function:**
```sql
SELECT
    employee_name,
    salary,
    AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary
FROM employees;
```

**Self-Join Equivalent:**
```sql
SELECT
    e1.employee_name,
    e1.salary,
    dept_avg.avg_salary AS dept_avg_salary
FROM employees e1
JOIN (
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
) dept_avg ON e1.department = dept_avg.department;
```

**Advantages of Window Functions:**
- More concise and readable
- Better performance (single pass)
- Easier to maintain

## Common Pitfalls and Solutions

### Pitfall 1: LAST_VALUE Without Proper Frame

```sql
-- WRONG: Default frame only goes to current row
SELECT
    order_date,
    LAST_VALUE(order_amount) OVER (ORDER BY order_date) AS last_amount
FROM orders;

-- CORRECT: Specify full frame
SELECT
    order_date,
    LAST_VALUE(order_amount) OVER (
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS last_amount
FROM orders;
```

### Pitfall 2: Forgetting ORDER BY in Ranking Functions

```sql
-- WRONG: Results are non-deterministic
SELECT ROW_NUMBER() OVER (PARTITION BY category) FROM products;

-- CORRECT: Always specify ORDER BY
SELECT ROW_NUMBER() OVER (PARTITION BY category ORDER BY product_id) FROM products;
```

### Pitfall 3: Performance with Large Windows

```sql
-- SLOW: Large frame for every row
SELECT SUM(amount) OVER (ORDER BY date ROWS BETWEEN 10000 PRECEDING AND CURRENT ROW)
FROM transactions;

-- BETTER: Use appropriate frame size
SELECT SUM(amount) OVER (ORDER BY date ROWS BETWEEN 30 PRECEDING AND CURRENT ROW)
FROM transactions;
```

## Advanced Techniques

### Multiple Window Specifications

```sql
SELECT
    product_name,
    category,
    sales,
    -- Rank within category
    RANK() OVER (PARTITION BY category ORDER BY sales DESC) AS category_rank,
    -- Rank overall
    RANK() OVER (ORDER BY sales DESC) AS overall_rank,
    -- Percentage of category total
    sales * 100.0 / SUM(sales) OVER (PARTITION BY category) AS pct_of_category,
    -- Percentage of grand total
    sales * 100.0 / SUM(sales) OVER () AS pct_of_total
FROM product_sales;
```

### Conditional Aggregation in Windows

```sql
SELECT
    order_date,
    order_amount,
    SUM(CASE WHEN order_status = 'completed' THEN order_amount ELSE 0 END)
        OVER (ORDER BY order_date) AS completed_revenue,
    SUM(CASE WHEN order_status = 'cancelled' THEN order_amount ELSE 0 END)
        OVER (ORDER BY order_date) AS cancelled_revenue
FROM orders;
```

## Related Concepts

- [[CTEs - Common Table Expressions]] - Often used with window functions
- [[SQL Basics - Quick Reference]] - Foundation SQL concepts
- [[Dimensional Data Modeling - Day 1]] - Analytical data structures

## References

- [Data Engineering 101 - Window Functions](https://de101.startdataengineering.com/windows)
- PostgreSQL Window Functions Documentation
- SQL Standard: Window Function Specifications

---

## Key Takeaways

1. **Window functions preserve row-level detail** - Unlike GROUP BY, they don't collapse rows
2. **Three key components** - PARTITION BY, ORDER BY, and window frame specifications
3. **Multiple function types** - Ranking, aggregate, and value functions
4. **Frame matters** - Especially for LAST_VALUE and aggregate functions
5. **Performance tool** - Often more efficient than self-joins or correlated subqueries
6. **Essential for analytics** - Running totals, rankings, and row comparisons are core analytical patterns
