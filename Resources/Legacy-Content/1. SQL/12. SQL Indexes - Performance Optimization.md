---
title: SQL Indexes - Performance Optimization
date: 2025-10-14
tags: [sql, indexes, performance, optimization, database-internals, data-engineering, architecture-performance]
status: active
learning_phase: "Architecture & Performance (Engineering)"
---

# SQL Indexes - Performance Optimization

## Overview

**Indexes** are database structures that improve the speed of data retrieval operations on tables. Think of them like a book's index: instead of scanning every page to find a topic, you consult the index to jump directly to the relevant pages.

### The Trade-off

| Benefit | Cost |
|---------|------|
| âš¡ **Faster reads** (SELECT, WHERE, JOIN) | ğŸŒ **Slower writes** (INSERT, UPDATE, DELETE) |
| ğŸ¯ **Efficient data access** | ğŸ’¾ **Additional storage space** |
| ğŸ” **Improved query performance** | ğŸ”§ **Maintenance overhead** |

**Key Insight:** Indexes are optimizations for read-heavy workloads. Too many indexes can actually hurt performance.

---

## How Indexes Work

### Without an Index (Full Table Scan)

```sql
SELECT * FROM customers WHERE customer_id = 12345;
```

**Process:**
1. Database reads row 1 â†’ Not a match
2. Database reads row 2 â†’ Not a match
3. Database reads row 3 â†’ Not a match
4. ... continues through ALL rows until found

**Time Complexity:** O(n) - Linear scan through entire table

### With an Index on customer_id

**Process:**
1. Database consults the index (B-tree structure)
2. Navigates directly to the matching row
3. Returns result immediately

**Time Complexity:** O(log n) - Logarithmic lookup via tree structure

### Visual Analogy

```
WITHOUT INDEX:               WITH INDEX:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Row 1        â”‚            â”‚   B-Tree     â”‚
â”‚ Row 2        â”‚            â”‚    Index     â”‚
â”‚ Row 3        â”‚    vs      â”‚  â”Œâ”€â”´â”€â”      â”‚
â”‚ Row 4        â”‚            â”‚ â”Œâ”˜   â””â”     â”‚
â”‚ ...          â”‚            â”‚ ğŸ‘†   Direct  â”‚
â”‚ Row 100000   â”‚            â”‚      Access  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 (Linear Scan)               (Fast Lookup)
```

---

## Common Index Types

### 1. Primary Key Index

**Automatically created** on the primary key column(s). Enforces uniqueness and provides fast lookups.

```sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,  -- Automatically indexed
    name VARCHAR(100),
    email VARCHAR(100)
);
```

**Characteristics:**
- Unique values only
- Cannot be NULL
- One per table
- Usually a clustered index (data physically ordered by this key)

### 2. Unique Index

Ensures column values are unique, similar to primary key but allows NULLs and you can have multiple unique indexes.

```sql
-- Create unique index on email
CREATE UNIQUE INDEX idx_customer_email ON customers(email);

-- Prevents duplicate emails
INSERT INTO customers VALUES (1, 'John', 'john@example.com');
INSERT INTO customers VALUES (2, 'Jane', 'john@example.com');  -- ERROR!
```

### 3. Single-Column Index

Index on a single column for fast lookups on that column.

```sql
-- Index on frequently queried column
CREATE INDEX idx_customer_name ON customers(name);

-- This query benefits from the index
SELECT * FROM customers WHERE name = 'John Doe';
```

### 4. Composite (Multi-Column) Index

Index on multiple columns. Column order matters!

```sql
-- Composite index on (last_name, first_name)
CREATE INDEX idx_customer_full_name ON customers(last_name, first_name);

-- âœ… USES INDEX (left-most column)
SELECT * FROM customers WHERE last_name = 'Smith';

-- âœ… USES INDEX (left-most + next column)
SELECT * FROM customers WHERE last_name = 'Smith' AND first_name = 'John';

-- âŒ DOES NOT USE INDEX (skips left-most column)
SELECT * FROM customers WHERE first_name = 'John';
```

**Left-Most Prefix Rule:** Composite indexes can be used if your query starts with the left-most column(s) in the index definition.

### 5. Covering Index

An index that contains **all columns** needed for a query, avoiding table access entirely.

```sql
-- Create index covering all columns in query
CREATE INDEX idx_customer_covering ON customers(customer_id, name, email);

-- This query is satisfied entirely by the index (no table access)
SELECT customer_id, name, email
FROM customers
WHERE customer_id = 100;
```

**Benefit:** Index-only scan - extremely fast as it never touches the main table.

### 6. Partial Index (Filtered Index)

Index on a subset of rows that match a condition.

```sql
-- Index only active customers
CREATE INDEX idx_active_customers ON customers(customer_id)
WHERE status = 'active';

-- Smaller index, faster maintenance, but only helps this specific query
SELECT * FROM customers WHERE status = 'active' AND customer_id = 100;
```

**Use Cases:**
- Large tables with a frequently queried subset
- Archival data (index only recent records)
- Status-based filtering (active vs inactive)

### 7. Full-Text Index

Specialized index for searching text content.

```sql
-- Create full-text index (syntax varies by database)
CREATE FULLTEXT INDEX idx_product_description ON products(description);

-- Search for products containing "wireless"
SELECT * FROM products
WHERE MATCH(description) AGAINST ('wireless bluetooth');
```

**Use Cases:**
- Document search
- Product descriptions
- Article content
- Log message searching

---

## When to Create an Index

### âœ… Good Candidates for Indexing

1. **Primary key columns** (automatic)
2. **Foreign key columns** (used in JOINs)
   ```sql
   CREATE INDEX idx_orders_customer_id ON orders(customer_id);
   ```

3. **Columns in WHERE clauses**
   ```sql
   -- Frequently filtered by status
   CREATE INDEX idx_orders_status ON orders(status);
   ```

4. **Columns in ORDER BY clauses**
   ```sql
   -- Frequently sorted by date
   CREATE INDEX idx_orders_date ON orders(order_date);
   ```

5. **Columns used in GROUP BY**
   ```sql
   CREATE INDEX idx_orders_customer ON orders(customer_id);
   ```

6. **Columns in JOIN conditions**
   ```sql
   -- Both sides of JOIN should be indexed
   CREATE INDEX idx_orders_product_id ON orders(product_id);
   CREATE INDEX idx_products_id ON products(product_id);  -- Usually PK
   ```

### âŒ Poor Candidates for Indexing

1. **Small tables** (< 1000 rows) - Full scan is fast enough
2. **Columns with low cardinality** (few unique values)
   - Example: `gender` (M/F), `boolean` flags
   - Index won't help much, just wastes space

3. **Columns frequently updated**
   - Every UPDATE must also update the index
   - Slows down write operations

4. **Wide columns** (large text/blob fields)
   - Indexes become very large
   - Consider full-text or partial indexes instead

5. **Tables with heavy write operations**
   - INSERT/UPDATE/DELETE all must maintain indexes
   - Each index adds overhead

---

## Index Creation Syntax

### Basic Syntax

```sql
-- Standard index
CREATE INDEX index_name ON table_name(column_name);

-- Unique index
CREATE UNIQUE INDEX index_name ON table_name(column_name);

-- Composite index
CREATE INDEX index_name ON table_name(column1, column2, column3);

-- Partial/filtered index (PostgreSQL)
CREATE INDEX index_name ON table_name(column_name) WHERE condition;

-- Include additional columns (covering index - SQL Server/PostgreSQL)
CREATE INDEX index_name ON table_name(key_column) INCLUDE (non_key_column1, non_key_column2);
```

### Dropping Indexes

```sql
-- Drop an index
DROP INDEX index_name;

-- PostgreSQL syntax
DROP INDEX IF EXISTS index_name;

-- SQL Server syntax
DROP INDEX index_name ON table_name;
```

### Viewing Existing Indexes

```sql
-- PostgreSQL
SELECT * FROM pg_indexes WHERE tablename = 'customers';

-- MySQL
SHOW INDEX FROM customers;

-- SQL Server
SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID('customers');

-- Spark SQL
SHOW INDEXES ON table_name;
```

---

## Performance Analysis

### Using EXPLAIN to Analyze Queries

The `EXPLAIN` command shows how the database executes a query, including whether indexes are used.

#### Without Index

```sql
EXPLAIN SELECT * FROM customers WHERE email = 'john@example.com';
```

**Output:**
```
Seq Scan on customers  (cost=0.00..18584.00 rows=1 width=100)
  Filter: (email = 'john@example.com'::text)
```

**Interpretation:**
- `Seq Scan` = Full table scan (slow)
- High cost value
- Must read all rows and filter

#### With Index

```sql
CREATE INDEX idx_customer_email ON customers(email);
EXPLAIN SELECT * FROM customers WHERE email = 'john@example.com';
```

**Output:**
```
Index Scan using idx_customer_email on customers  (cost=0.43..8.45 rows=1 width=100)
  Index Cond: (email = 'john@example.com'::text)
```

**Interpretation:**
- `Index Scan` = Using index (fast)
- Much lower cost
- Direct lookup via index

### Key EXPLAIN Metrics

| Metric | Meaning |
|--------|---------|
| **Seq Scan** | Full table scan - consider adding index |
| **Index Scan** | Using index - good! |
| **Index Only Scan** | Covered by index - excellent! |
| **Bitmap Index Scan** | Multiple indexes combined |
| **Cost** | Estimated query cost (lower is better) |
| **Rows** | Estimated number of rows returned |

---

## Index Maintenance

### Index Statistics

Databases maintain statistics about data distribution to optimize query plans. Keep them updated!

```sql
-- PostgreSQL
ANALYZE table_name;

-- MySQL
ANALYZE TABLE table_name;

-- SQL Server
UPDATE STATISTICS table_name;
```

### Rebuilding Indexes

Over time, indexes can become fragmented. Rebuilding reorganizes them.

```sql
-- PostgreSQL
REINDEX INDEX index_name;
REINDEX TABLE table_name;

-- MySQL
OPTIMIZE TABLE table_name;

-- SQL Server
ALTER INDEX index_name ON table_name REBUILD;
```

**When to rebuild:**
- After large bulk inserts/updates/deletes
- Regularly scheduled maintenance (weekly/monthly)
- When query performance degrades over time

### Monitoring Index Usage

```sql
-- PostgreSQL: Find unused indexes
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS number_of_scans
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY schemaname, tablename;

-- Consider dropping indexes that are never used
```

---

## Advanced Indexing Strategies

### 1. Composite Index Optimization

**Order matters!** Place the most selective (highest cardinality) column first.

```sql
-- âŒ SUBOPTIMAL: gender has only 2 values
CREATE INDEX idx_bad ON users(gender, age, city);

-- âœ… OPTIMAL: city is more selective
CREATE INDEX idx_good ON users(city, age, gender);
```

**Rule of Thumb:** Order columns by selectivity (most unique first).

### 2. Index for Sorting and Grouping

Indexes can eliminate sort operations.

```sql
-- Index matching ORDER BY clause
CREATE INDEX idx_orders_date_desc ON orders(order_date DESC);

-- This query avoids a sort step
SELECT * FROM orders ORDER BY order_date DESC LIMIT 100;
```

### 3. Partial Index for Common Queries

```sql
-- Only index recent orders (last 90 days)
CREATE INDEX idx_recent_orders ON orders(order_date)
WHERE order_date >= CURRENT_DATE - INTERVAL '90 days';

-- Much smaller, faster to maintain than full index
```

### 4. Expression/Function-Based Indexes

Index the result of an expression or function.

```sql
-- Index lowercase email for case-insensitive search
CREATE INDEX idx_email_lower ON customers(LOWER(email));

-- Now this query uses the index
SELECT * FROM customers WHERE LOWER(email) = 'john@example.com';
```

### 5. Include Non-Key Columns (Covering Indexes)

```sql
-- Include columns to create covering index
CREATE INDEX idx_orders_covering ON orders(customer_id)
INCLUDE (order_date, total_amount, status);

-- All columns in this query are in the index
SELECT order_date, total_amount, status
FROM orders
WHERE customer_id = 100;
```

---

## Real-World Example: E-commerce Database

```sql
-- Orders table
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,           -- Automatically indexed
    customer_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    order_date TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL
);

-- Index foreign keys for JOINs
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_product_id ON orders(product_id);

-- Index for common query: recent orders by status
CREATE INDEX idx_orders_date_status ON orders(order_date DESC, status)
WHERE order_date >= '2024-01-01';

-- Index for customer order history (covering index)
CREATE INDEX idx_customer_orders ON orders(customer_id, order_date DESC)
INCLUDE (total_amount, status);

-- Composite index for analytics queries
CREATE INDEX idx_orders_analytics ON orders(order_date, status, product_id);
```

**Query Performance:**

```sql
-- âœ… Uses idx_orders_customer_id
SELECT * FROM orders WHERE customer_id = 100;

-- âœ… Uses idx_customer_orders (index-only scan)
SELECT order_date, total_amount, status
FROM orders
WHERE customer_id = 100
ORDER BY order_date DESC;

-- âœ… Uses idx_orders_date_status
SELECT * FROM orders
WHERE order_date >= '2024-01-01' AND status = 'completed';

-- âœ… Uses idx_orders_analytics
SELECT product_id, COUNT(*)
FROM orders
WHERE order_date >= '2024-01-01' AND status = 'completed'
GROUP BY product_id;
```

---

## Index Anti-Patterns

### 1. Over-Indexing

```sql
-- âŒ BAD: Too many overlapping indexes
CREATE INDEX idx1 ON orders(customer_id);
CREATE INDEX idx2 ON orders(customer_id, order_date);
CREATE INDEX idx3 ON orders(customer_id, order_date, status);
CREATE INDEX idx4 ON orders(customer_id, status);

-- âœ… GOOD: Strategic composite index
CREATE INDEX idx_orders_composite ON orders(customer_id, order_date, status);
-- This one index can serve most queries
```

### 2. Indexing Low-Cardinality Columns

```sql
-- âŒ BAD: Only 2-3 possible values
CREATE INDEX idx_gender ON users(gender);        -- M/F
CREATE INDEX idx_active ON users(is_active);     -- true/false

-- Index won't help much, wastes space
```

### 3. Not Using Left-Most Prefix

```sql
CREATE INDEX idx_composite ON users(last_name, first_name, email);

-- âŒ DOES NOT USE INDEX: skips left-most column
SELECT * FROM users WHERE email = 'john@example.com';

-- âœ… USES INDEX: starts with left-most column
SELECT * FROM users WHERE last_name = 'Smith' AND email = 'john@example.com';
```

### 4. Function on Indexed Column

```sql
CREATE INDEX idx_created_date ON orders(created_date);

-- âŒ DOES NOT USE INDEX: function on column
SELECT * FROM orders WHERE YEAR(created_date) = 2024;

-- âœ… USES INDEX: rewrite query
SELECT * FROM orders
WHERE created_date >= '2024-01-01' AND created_date < '2025-01-01';
```

### 5. Indexing Everything

**Problem:** Every index adds overhead to INSERT, UPDATE, DELETE operations.

**Solution:** Only index columns that are:
- Frequently used in WHERE, JOIN, ORDER BY, GROUP BY
- On tables with significant read operations
- On sufficiently large tables where full scan is expensive

---

## Best Practices Checklist

### âœ… Do's

1. **Index foreign keys** - Essential for JOIN performance
2. **Index WHERE clause columns** - If frequently queried
3. **Use composite indexes strategically** - Order by selectivity
4. **Monitor index usage** - Drop unused indexes
5. **Analyze queries with EXPLAIN** - Verify indexes are used
6. **Update statistics regularly** - Keep query planner informed
7. **Create covering indexes** - For critical frequent queries
8. **Use partial indexes** - For large tables with common filters

### âŒ Don'ts

1. **Don't index small tables** - Full scan is fast enough
2. **Don't index low-cardinality columns** - Minimal benefit
3. **Don't over-index** - Each index has maintenance cost
4. **Don't index wide columns** - Use alternatives like full-text
5. **Don't forget to maintain** - Rebuild fragmented indexes
6. **Don't create redundant indexes** - Composite can cover singles
7. **Don't index write-heavy tables excessively** - Slows writes
8. **Don't apply functions to indexed columns in WHERE** - Breaks index usage

---

## Measuring Index Impact

### Before and After Comparison

```sql
-- 1. Record current performance
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 100 AND status = 'completed';

-- Output: Execution Time: 523 ms

-- 2. Create index
CREATE INDEX idx_orders_customer_status ON orders(customer_id, status);

-- 3. Test again
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 100 AND status = 'completed';

-- Output: Execution Time: 12 ms

-- Result: 43x faster! ğŸš€
```

### Key Performance Indicators

| Metric | Before Index | After Index | Improvement |
|--------|-------------|-------------|-------------|
| Execution Time | 523 ms | 12 ms | 43x faster |
| Rows Scanned | 1,000,000 | 150 | Reduced 99.9% |
| I/O Operations | 8,000 | 5 | Reduced 99.9% |
| Query Cost | 18,584 | 8.45 | Reduced 99.9% |

---

## Database-Specific Considerations

### PostgreSQL
- Supports partial indexes: `WHERE` clause in index definition
- Excellent support for expression indexes
- BRIN indexes for large sequential data
- GiST/GIN indexes for full-text and JSON

### MySQL
- InnoDB always has clustered primary key index
- Full-text indexes available (FULLTEXT)
- Prefix indexes for long strings: `INDEX(column(10))`

### SQL Server
- Clustered vs non-clustered indexes
- Included columns: `CREATE INDEX ... INCLUDE (...)`
- Filtered indexes: `WHERE` clause support

### Spark/Hive
- Limited index support (depends on file format)
- Partitioning serves similar purpose to indexes
- Bucketing for join optimization
- Z-ordering in Delta Lake for multi-column optimization

---

## Related Concepts

- [[SQL Basics - Quick Reference]] - Fundamental SQL concepts
- [[Window Functions - Advanced SQL Analytics]] - Complex queries that benefit from indexes
- [[CTEs - Common Table Expressions]] - Query organization
- Query Optimization - Broader performance topic
- Database Internals - B-tree structures, storage engines

---

## Quick Reference Card

```
INDEX TYPE           USE CASE                    SYNTAX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Primary Key         Unique identifier           CREATE TABLE t (id INT PRIMARY KEY)
Unique              Unique constraint           CREATE UNIQUE INDEX idx ON t(col)
Single Column       Simple lookups              CREATE INDEX idx ON t(col)
Composite           Multi-column queries        CREATE INDEX idx ON t(col1, col2)
Covering            Index-only scans            CREATE INDEX idx ON t(col) INCLUDE (col2)
Partial             Filtered subset             CREATE INDEX idx ON t(col) WHERE condition
Full-Text           Text search                 CREATE FULLTEXT INDEX idx ON t(col)

WHEN TO INDEX                    WHEN NOT TO INDEX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ“ Foreign keys                   âœ— Small tables (< 1000 rows)
âœ“ WHERE clause columns           âœ— Low cardinality columns
âœ“ JOIN conditions                âœ— Frequently updated columns
âœ“ ORDER BY columns               âœ— Wide text/blob columns
âœ“ GROUP BY columns               âœ— Write-heavy tables
âœ“ Large tables                   âœ— Columns never queried

ANALYSIS COMMANDS                MAINTENANCE COMMANDS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EXPLAIN query                    ANALYZE table
EXPLAIN ANALYZE query            REINDEX index/table
SHOW INDEX FROM table            DROP INDEX IF EXISTS idx
```

---

## Key Takeaways

1. **Indexes dramatically speed up reads** - But slow down writes
2. **Choose wisely** - Index columns used in WHERE, JOIN, ORDER BY, GROUP BY
3. **Composite indexes follow left-most prefix rule** - Column order matters
4. **Use EXPLAIN to verify** - Ensure indexes are actually being used
5. **Maintain regularly** - Update statistics, rebuild fragmented indexes
6. **Don't over-index** - Each index has storage and write overhead
7. **Monitor and adjust** - Drop unused indexes, add indexes for slow queries
8. **Covering indexes are powerful** - Eliminate table access entirely

**Remember:** Indexing is about balance. The goal is optimal performance for your specific query patterns, not indexing everything "just in case."
