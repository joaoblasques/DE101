---
title: String Manipulation & Pattern Matching
date: 2025-10-14
tags: [sql, strings, regex, pattern-matching, text-processing, data-engineering, core-skills]
status: active
learning_phase: "Core Skills (Practical Operations)"
---

# String Manipulation & Pattern Matching

## Overview

String manipulation is essential for data cleaning, transformation, and text analysis. This guide covers SQL functions for working with text data, from basic operations to advanced pattern matching with regular expressions.

---

## Basic String Functions

### Length and Size

```sql
-- Get string length
SELECT LENGTH('Hello World');                         -- 11 (PostgreSQL, MySQL)
SELECT LEN('Hello World');                            -- 11 (SQL Server)
SELECT CHAR_LENGTH('Hello World');                    -- 11 (MySQL)

-- Byte length (can differ for multi-byte characters)
SELECT OCTET_LENGTH('Hello');                         -- PostgreSQL
SELECT LENGTH('Hello');                               -- MySQL (bytes)
```

### Case Conversion

```sql
-- Convert to uppercase
SELECT UPPER('hello world');                          -- 'HELLO WORLD'
SELECT UCASE('hello world');                          -- MySQL alternative

-- Convert to lowercase
SELECT LOWER('HELLO WORLD');                          -- 'hello world'
SELECT LCASE('HELLO WORLD');                          -- MySQL alternative

-- Use cases: Case-insensitive comparisons
SELECT * FROM customers
WHERE LOWER(email) = LOWER('John@Example.COM');
```

### Concatenation

```sql
-- Using || operator (PostgreSQL, SQLite)
SELECT 'Hello' || ' ' || 'World';                     -- 'Hello World'
SELECT first_name || ' ' || last_name AS full_name
FROM customers;

-- Using CONCAT function (MySQL, PostgreSQL, SQL Server)
SELECT CONCAT('Hello', ' ', 'World');                 -- 'Hello World'
SELECT CONCAT(first_name, ' ', last_name) AS full_name
FROM customers;

-- CONCAT with NULL handling
SELECT CONCAT('Hello', NULL, 'World');                -- 'HelloWorld' (MySQL)
-- NULL values are ignored

-- CONCAT_WS (with separator)
SELECT CONCAT_WS(', ', city, state, country);         -- 'Seattle, WA, USA'
SELECT CONCAT_WS(' ', first_name, middle_name, last_name);
-- NULL values are ignored
```

### Trimming Whitespace

```sql
-- Remove leading and trailing spaces
SELECT TRIM('  Hello World  ');                       -- 'Hello World'

-- Remove leading spaces only
SELECT LTRIM('  Hello World  ');                      -- 'Hello World  '

-- Remove trailing spaces only
SELECT RTRIM('  Hello World  ');                      -- '  Hello World'

-- Remove specific characters (PostgreSQL)
SELECT TRIM(BOTH '.' FROM '...Hello...');             -- 'Hello'
SELECT TRIM(LEADING '0' FROM '00042');                -- '42'

-- Clean data example
SELECT
    customer_id,
    TRIM(LOWER(email)) AS cleaned_email
FROM customers;
```

### Substrings

```sql
-- SUBSTRING / SUBSTR
-- Syntax: SUBSTRING(string, start_position, length)

-- PostgreSQL, MySQL (1-indexed)
SELECT SUBSTRING('Hello World', 1, 5);                -- 'Hello'
SELECT SUBSTRING('Hello World', 7, 5);                -- 'World'
SELECT SUBSTRING('Hello World', 7);                   -- 'World' (to end)

-- SQL Server
SELECT SUBSTRING('Hello World', 1, 5);                -- 'Hello'

-- Extract domain from email
SELECT
    email,
    SUBSTRING(email, POSITION('@' IN email) + 1) AS domain
FROM customers;
```

### String Position/Search

```sql
-- Find position of substring (1-indexed, 0 if not found)

-- PostgreSQL
SELECT POSITION('World' IN 'Hello World');            -- 7
SELECT STRPOS('Hello World', 'World');                -- 7

-- MySQL
SELECT LOCATE('World', 'Hello World');                -- 7
SELECT INSTR('Hello World', 'World');                 -- 7

-- SQL Server
SELECT CHARINDEX('World', 'Hello World');             -- 7

-- Case-insensitive search
SELECT POSITION(LOWER('world') IN LOWER('Hello World'));  -- 7
```

### Replace

```sql
-- Replace substring
SELECT REPLACE('Hello World', 'World', 'SQL');        -- 'Hello SQL'

-- Clean phone numbers
SELECT
    customer_id,
    REPLACE(REPLACE(REPLACE(phone, '-', ''), '(', ''), ')', '') AS cleaned_phone
FROM customers;

-- Multiple replacements
SELECT
    REPLACE(
        REPLACE(
            REPLACE(text_column, '\n', ' '),
        '\t', ' '),
    '\r', '')
FROM data_table;
```

### Padding

```sql
-- Left pad
SELECT LPAD('42', 5, '0');                            -- '00042'
SELECT LPAD('SQL', 10, '*');                          -- '*******SQL'

-- Right pad
SELECT RPAD('42', 5, '0');                            -- '42000'
SELECT RPAD('SQL', 10, '*');                          -- 'SQL*******'

-- Use case: Format IDs
SELECT
    LPAD(CAST(order_id AS VARCHAR), 8, '0') AS formatted_id
FROM orders;
-- Result: 00000123, 00000456, etc.
```

### Repeat

```sql
-- Repeat string N times
SELECT REPEAT('*', 5);                                -- '*****'
SELECT REPEAT('-', 10);                               -- '----------'

-- Create visual separator
SELECT
    product_name,
    REPEAT('=', LENGTH(product_name)) AS underline
FROM products;
```

### Reverse

```sql
-- Reverse string
SELECT REVERSE('Hello');                              -- 'olleH'

-- Use case: Check palindromes
SELECT
    word,
    word = REVERSE(word) AS is_palindrome
FROM words;
```

---

## Pattern Matching with LIKE

### Basic LIKE

```sql
-- % matches any sequence of characters
-- _ matches exactly one character

-- Starts with
SELECT * FROM customers
WHERE name LIKE 'John%';                              -- John, Johnson, Johnny

-- Ends with
SELECT * FROM customers
WHERE email LIKE '%@gmail.com';                       -- Gmail addresses

-- Contains
SELECT * FROM products
WHERE description LIKE '%wireless%';                  -- Contains 'wireless'

-- Exact length with multiple characters
SELECT * FROM products
WHERE sku LIKE 'ABC-___';                             -- ABC-123, ABC-XYZ
```

### Case Sensitivity

```sql
-- PostgreSQL (case-insensitive with ILIKE)
SELECT * FROM customers
WHERE name ILIKE 'john%';                             -- John, JOHN, john

-- MySQL (case-insensitive by default, use BINARY for case-sensitive)
SELECT * FROM customers
WHERE name LIKE 'john%';                              -- Case-insensitive
WHERE BINARY name LIKE 'john%';                       -- Case-sensitive

-- SQL Server (depends on collation)
SELECT * FROM customers
WHERE name COLLATE Latin1_General_CS_AS LIKE 'john%'; -- Case-sensitive
```

### Complex LIKE Patterns

```sql
-- Multiple patterns with OR
SELECT * FROM products
WHERE name LIKE '%phone%'
   OR name LIKE '%tablet%'
   OR name LIKE '%laptop%';

-- Exclude pattern with NOT LIKE
SELECT * FROM customers
WHERE email NOT LIKE '%@temporary%'
  AND email NOT LIKE '%@test%';

-- Character ranges (MySQL, PostgreSQL with SIMILAR TO)
SELECT * FROM products
WHERE sku SIMILAR TO '[A-Z][0-9][0-9][0-9]';         -- A123, B456

-- Escape special characters
SELECT * FROM data
WHERE text_column LIKE '%50\%%' ESCAPE '\';          -- Matches '50%'
```

---

## Regular Expressions

### PostgreSQL Regex

```sql
-- Match pattern with ~
SELECT * FROM customers
WHERE email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- Case-insensitive match with ~*
SELECT * FROM customers
WHERE name ~* '^john';                                -- john, John, JOHN

-- Does NOT match with !~
SELECT * FROM customers
WHERE email !~ '@(temp|test|example)\.com$';

-- Extract with REGEXP_MATCHES
SELECT
    email,
    REGEXP_MATCHES(email, '^([^@]+)@(.+)$') AS parts
FROM customers;
-- Returns: {username, domain}

-- Replace with REGEXP_REPLACE
SELECT REGEXP_REPLACE(
    phone,
    '(\d{3})(\d{3})(\d{4})',
    '(\1) \2-\3'
) AS formatted_phone
FROM customers;
-- '5551234567' -> '(555) 123-4567'

-- Split string with REGEXP_SPLIT_TO_ARRAY
SELECT REGEXP_SPLIT_TO_ARRAY('apple,banana,cherry', ',');
-- Returns: {apple, banana, cherry}

-- Split to table with REGEXP_SPLIT_TO_TABLE
SELECT REGEXP_SPLIT_TO_TABLE('apple,banana,cherry', ',') AS fruit;
-- Returns rows: apple, banana, cherry
```

### MySQL Regex

```sql
-- Match pattern with REGEXP or RLIKE
SELECT * FROM customers
WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$';

-- Case-insensitive (default in MySQL)
SELECT * FROM customers
WHERE name REGEXP '^john';

-- NOT matching
SELECT * FROM customers
WHERE email NOT REGEXP '@(temp|test|example)\\.com$';

-- REGEXP_LIKE (MySQL 8.0+)
SELECT * FROM customers
WHERE REGEXP_LIKE(email, '^[a-z0-9]+@[a-z]+\\.[a-z]{2,}$', 'i');
-- 'i' flag = case-insensitive

-- REGEXP_REPLACE (MySQL 8.0+)
SELECT REGEXP_REPLACE(
    phone,
    '([0-9]{3})([0-9]{3})([0-9]{4})',
    '(\\1) \\2-\\3'
) AS formatted_phone
FROM customers;

-- REGEXP_SUBSTR (MySQL 8.0+)
SELECT REGEXP_SUBSTR(email, '[^@]+') AS username
FROM customers;

-- REGEXP_INSTR (MySQL 8.0+)
SELECT REGEXP_INSTR(email, '@') AS at_position
FROM customers;
```

### SQL Server Regex (Limited)

SQL Server doesn't have native regex. Use LIKE or CLR functions:

```sql
-- Limited pattern matching with PATINDEX
SELECT PATINDEX('%[0-9]%', 'abc123def');              -- 4 (position of first digit)

-- For advanced regex, use:
-- 1. CLR (Common Language Runtime) functions
-- 2. External tools (SSIS, Python, etc.)
-- 3. Multiple LIKE statements
```

---

## Common Regex Patterns

### Email Validation

```sql
-- Basic email pattern
SELECT * FROM customers
WHERE email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';

-- More permissive
SELECT * FROM customers
WHERE email ~* '^[^@\s]+@[^@\s]+\.[^@\s]+$';
```

### Phone Number Validation

```sql
-- US phone: (123) 456-7890 or 123-456-7890
SELECT * FROM customers
WHERE phone ~ '^\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}$';

-- Digits only (10 or 11 digits)
SELECT * FROM customers
WHERE phone ~ '^[0-9]{10,11}$';
```

### URL Validation

```sql
-- Basic URL pattern
SELECT * FROM websites
WHERE url ~ '^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$';
```

### Postal Code Validation

```sql
-- US ZIP code (12345 or 12345-6789)
SELECT * FROM addresses
WHERE zip_code ~ '^\d{5}(-\d{4})?$';

-- Canadian postal code (A1A 1A1)
SELECT * FROM addresses
WHERE postal_code ~ '^[A-Z]\d[A-Z]\s?\d[A-Z]\d$';
```

### Extract Numbers from String

```sql
-- PostgreSQL
SELECT REGEXP_REPLACE('Order #12345', '[^0-9]', '', 'g');  -- '12345'

-- MySQL 8.0+
SELECT REGEXP_REPLACE('Order #12345', '[^0-9]', '');       -- '12345'

-- Extract all numbers
SELECT REGEXP_MATCHES('Price: $19.99', '\d+\.?\d*', 'g');  -- {19.99}
```

---

## String Splitting and Arrays

### PostgreSQL String to Array

```sql
-- Split string into array
SELECT STRING_TO_ARRAY('apple,banana,cherry', ',');
-- Result: {apple,banana,cherry}

-- Use in query
SELECT
    order_id,
    UNNEST(STRING_TO_ARRAY(product_ids, ',')) AS product_id
FROM orders;

-- Split and count
SELECT
    tag_string,
    CARDINALITY(STRING_TO_ARRAY(tag_string, ',')) AS tag_count
FROM posts;
```

### MySQL String Splitting

```sql
-- MySQL doesn't have native split, but can use:

-- SUBSTRING_INDEX for simple cases
SELECT SUBSTRING_INDEX('apple,banana,cherry', ',', 1);     -- 'apple'
SELECT SUBSTRING_INDEX('apple,banana,cherry', ',', 2);     -- 'apple,banana'

-- Get last element
SELECT SUBSTRING_INDEX('apple,banana,cherry', ',', -1);    -- 'cherry'

-- Extract specific element (2nd)
SELECT SUBSTRING_INDEX(
    SUBSTRING_INDEX('apple,banana,cherry', ',', 2),
    ',',
    -1
);  -- 'banana'

-- For complex splitting, use recursive CTE (MySQL 8.0+) or application logic
```

### Array to String

```sql
-- PostgreSQL
SELECT ARRAY_TO_STRING(ARRAY['apple', 'banana', 'cherry'], ', ');
-- Result: 'apple, banana, cherry'

-- MySQL
SELECT GROUP_CONCAT(fruit SEPARATOR ', ')
FROM (VALUES ROW('apple'), ROW('banana'), ROW('cherry')) AS fruits(fruit);
```

---

## Advanced String Operations

### String Aggregation

```sql
-- PostgreSQL
SELECT
    customer_id,
    STRING_AGG(product_name, ', ' ORDER BY product_name) AS products
FROM order_items
GROUP BY customer_id;

-- MySQL
SELECT
    customer_id,
    GROUP_CONCAT(product_name ORDER BY product_name SEPARATOR ', ') AS products
FROM order_items
GROUP BY customer_id;

-- SQL Server
SELECT
    customer_id,
    STRING_AGG(product_name, ', ') WITHIN GROUP (ORDER BY product_name) AS products
FROM order_items
GROUP BY customer_id;
```

### JSON String Functions

```sql
-- PostgreSQL
SELECT
    '{"name": "John", "age": 30}'::JSON->>'name' AS name;  -- 'John'

-- Extract from JSON string
SELECT
    json_column->>'field' AS extracted_value
FROM table_with_json;

-- MySQL
SELECT JSON_EXTRACT('{"name": "John"}', '$.name');         -- "John"
SELECT JSON_UNQUOTE(JSON_EXTRACT('{"name": "John"}', '$.name'));  -- John
```

### Encoding/Decoding

```sql
-- PostgreSQL: Base64 encoding
SELECT ENCODE('Hello World', 'base64');                    -- 'SGVsbG8gV29ybGQ='
SELECT DECODE('SGVsbG8gV29ybGQ=', 'base64');              -- 'Hello World'

-- URL encoding (PostgreSQL with extensions)
-- Requires url_encode extension
```

### Fuzzy Matching

```sql
-- PostgreSQL: Levenshtein distance (requires fuzzystrmatch extension)
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;

SELECT LEVENSHTEIN('kitten', 'sitting');                   -- 3 (edit distance)

-- Find similar strings
SELECT
    name,
    LEVENSHTEIN(LOWER(name), LOWER('john')) AS distance
FROM customers
WHERE LEVENSHTEIN(LOWER(name), LOWER('john')) <= 2
ORDER BY distance;

-- Soundex (phonetic matching)
SELECT SOUNDEX('Smith');                                   -- 'S530'
SELECT SOUNDEX('Smythe');                                  -- 'S530' (same!)

-- Find phonetically similar names
SELECT * FROM customers
WHERE SOUNDEX(last_name) = SOUNDEX('Smith');
```

---

## Data Cleaning Patterns

### Pattern 1: Standardize Email

```sql
UPDATE customers
SET email = TRIM(LOWER(email))
WHERE email IS NOT NULL;
```

### Pattern 2: Clean Phone Numbers

```sql
-- Remove all non-digits
UPDATE customers
SET phone = REGEXP_REPLACE(phone, '[^0-9]', '', 'g')
WHERE phone IS NOT NULL;

-- Format consistently
UPDATE customers
SET phone = REGEXP_REPLACE(
    phone,
    '([0-9]{3})([0-9]{3})([0-9]{4})',
    '(\1) \2-\3'
)
WHERE LENGTH(REGEXP_REPLACE(phone, '[^0-9]', '', 'g')) = 10;
```

### Pattern 3: Extract and Standardize Names

```sql
-- Extract first and last name from full name
SELECT
    full_name,
    SPLIT_PART(full_name, ' ', 1) AS first_name,
    SPLIT_PART(full_name, ' ', 2) AS last_name
FROM customers;

-- Title case names
SELECT INITCAP('john doe');                                -- 'John Doe' (PostgreSQL)
```

### Pattern 4: Remove Extra Whitespace

```sql
-- Replace multiple spaces with single space
SELECT REGEXP_REPLACE(text_column, '\s+', ' ', 'g') AS cleaned_text
FROM data_table;

-- Remove all whitespace
SELECT REGEXP_REPLACE(text_column, '\s', '', 'g') AS no_spaces
FROM data_table;
```

### Pattern 5: Extract Domain from URL

```sql
-- Extract domain from URL
SELECT
    url,
    REGEXP_REPLACE(
        REGEXP_REPLACE(url, '^https?://(www\.)?', ''),
        '/.*$',
        ''
    ) AS domain
FROM websites;
-- 'https://www.example.com/path' -> 'example.com'
```

---

## Performance Considerations

### Index String Columns

```sql
-- Regular index
CREATE INDEX idx_customers_email ON customers(email);

-- Functional index for case-insensitive search
CREATE INDEX idx_customers_email_lower ON customers(LOWER(email));

-- Now this query uses the index
SELECT * FROM customers WHERE LOWER(email) = 'john@example.com';
```

### Use Full-Text Search for Large Text

```sql
-- PostgreSQL: Create tsvector column
ALTER TABLE articles ADD COLUMN search_vector TSVECTOR;

-- Populate search vector
UPDATE articles
SET search_vector = TO_TSVECTOR('english', title || ' ' || body);

-- Create GIN index
CREATE INDEX idx_articles_search ON articles USING GIN(search_vector);

-- Search efficiently
SELECT * FROM articles
WHERE search_vector @@ TO_TSQUERY('english', 'data & engineering');
```

### Avoid Leading Wildcards

```sql
-- ❌ SLOW: Cannot use index
SELECT * FROM customers WHERE email LIKE '%@gmail.com';

-- ✅ FAST: Can use index
SELECT * FROM customers WHERE email LIKE 'john%';

-- For leading wildcards, consider:
-- 1. Full-text search indexes
-- 2. Reverse string technique
-- 3. Trigram indexes (PostgreSQL)
```

---

## Best Practices

### ✅ Do's

1. **Use TRIM** to clean user input
2. **Normalize case** for comparisons (LOWER/UPPER)
3. **Use regex** for complex pattern validation
4. **Index frequently searched columns**
5. **Use string aggregation** for array-like data
6. **Validate** email, phone, URL formats
7. **Use CONCAT_WS** to handle NULL values

### ❌ Don'ts

1. **Don't use LIKE with leading %** on large tables without full-text index
2. **Don't store concatenated data** - normalize instead
3. **Don't compare strings without normalization** (case, whitespace)
4. **Don't forget to escape** special characters in regex
5. **Don't use regex when LIKE is sufficient** (performance)
6. **Don't store formatted data** - format on display

---

## Quick Reference

```
FUNCTION                USE CASE                           EXAMPLE
─────────────────────────────────────────────────────────────────────────────
LENGTH/LEN             String length                       LENGTH('hello') → 5
UPPER/LOWER            Case conversion                     UPPER('hello') → 'HELLO'
TRIM/LTRIM/RTRIM       Remove whitespace                   TRIM('  hi  ') → 'hi'
CONCAT/||              Join strings                        'a' || 'b' → 'ab'
SUBSTRING              Extract substring                   SUBSTRING('hello', 1, 3) → 'hel'
REPLACE                Replace substring                   REPLACE('hi', 'i', 'ello') → 'hello'
LIKE/%/_               Basic pattern matching              name LIKE 'John%'
REGEXP/~               Advanced pattern matching           email ~ '^[a-z]+@'
REGEXP_REPLACE         Replace with regex                  Clean phone numbers
STRING_AGG             Aggregate to string                 'a, b, c'
```

---

## Related Concepts

- [[Data Quality & Validation]] - String validation patterns
- [[SQL Basics - Quick Reference]] - Foundation SQL
- [[Working with JSON/Semi-Structured Data]] - JSON string functions
- [[SQL Indexes - Performance Optimization]] - Indexing strategies

---

## Key Takeaways

1. **Normalize strings** before comparison (TRIM, LOWER)
2. **Use LIKE for simple patterns**, regex for complex ones
3. **Validate input** with regex patterns
4. **Index string columns** used in WHERE clauses
5. **Clean data** at ingestion time, not query time
6. **Use string aggregation** (STRING_AGG, GROUP_CONCAT) for denormalization
7. **Choose appropriate functions** for database platform
8. **Full-text search** for large text searching (don't use LIKE '%term%')
