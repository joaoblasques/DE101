---
title: SQL Basics - Quick Reference
date: 2025-10-09
tags: [sql, select, where, join, group-by, having, basics, data-engineering, foundation-basics]
status: active
learning_phase: "Foundation (Basics)"
---


**Source:** [DE101 Chapter 1](https://de101.startdataengineering.com/sql_basics)
**Created:** 2025-10-09
**Last Updated:** 2025-10-10
**Status:** ‚úÖ Complete (All sections 1.1-1.12)

---

## üóÇÔ∏è Spark Catalog Structure

```
Catalog ‚Üí Schema ‚Üí Table
```

**Best Practice:** Always use full path when referencing tables
```sql
-- Full path reference
SELECT * FROM schema_name.table_name;

-- Or set default schema
USE schema_name;
SELECT * FROM table_name;
```

---

## 1. SELECT Statements

### Basic Syntax
```sql
-- All columns
SELECT * FROM table_name;

-- Specific columns
SELECT column1, column2, column3 FROM table_name;

-- Limit results
SELECT * FROM table_name LIMIT 10;
```

---

## 2. WHERE Clause - Filtering Data

### Comparison Operators
| Operator | Meaning |
|----------|---------|
| `<` | Less than |
| `>` | Greater than |
| `<=` | Less than or equal to |
| `>=` | Greater than or equal to |
| `=` | Equal |
| `<>` or `!=` | Not equal |

### Logical Operators
```sql
-- AND: Both conditions must be true
SELECT * FROM customer
WHERE c_nationkey = 20
  AND c_acctbal > 1000;

-- OR: Either condition must be true
SELECT * FROM customer
WHERE c_nationkey = 20
   OR c_nationkey = 15;
```

### Pattern Matching with LIKE
| Wildcard | Meaning | Example |
|----------|---------|---------|
| `%` | Zero or more characters | `'%381%'` matches "Customer381" |
| `_` | Exactly one character | `'_381_'` matches "A381B" |

```sql
-- Find names containing '381'
SELECT * FROM customer
WHERE c_name LIKE '%381%';

-- Find names starting with 'Customer'
SELECT * FROM customer
WHERE c_name LIKE 'Customer%';
```

---

## 3. ORDER BY - Sorting Results

```sql
-- Ascending (default)
SELECT * FROM customer
ORDER BY c_acctbal;

-- Descending
SELECT * FROM customer
ORDER BY c_acctbal DESC;

-- Multiple columns
SELECT * FROM customer
ORDER BY c_nationkey, c_acctbal DESC;
```

---

## 4. JOIN Types

### Visual Guide
```
INNER JOIN:      [A ‚à© B]     Only matching rows
LEFT JOIN:       [A ‚à™ (A‚à©B)] All from left + matches
RIGHT JOIN:      [(A‚à©B) ‚à™ B] Matches + all from right
FULL OUTER JOIN: [A ‚à™ B]     All rows from both
CROSS JOIN:      [A √ó B]     Cartesian product
```

### Syntax Examples

#### INNER JOIN (Most Common)
```sql
SELECT c.c_name, o.o_orderdate, o.o_totalprice
FROM customer c
INNER JOIN orders o ON c.c_custkey = o.o_custkey;
```

#### LEFT OUTER JOIN
```sql
-- All customers, with their orders if they exist
SELECT c.c_name, o.o_orderkey
FROM customer c
LEFT OUTER JOIN orders o ON c.c_custkey = o.o_custkey;
```

#### RIGHT OUTER JOIN
```sql
-- All orders, with customer info if it exists
SELECT c.c_name, o.o_orderkey
FROM customer c
RIGHT OUTER JOIN orders o ON c.c_custkey = o.o_custkey;
```

#### FULL OUTER JOIN
```sql
-- All customers and all orders
SELECT c.c_name, o.o_orderkey
FROM customer c
FULL OUTER JOIN orders o ON c.c_custkey = o.o_custkey;
```

#### CROSS JOIN
```sql
-- Every customer paired with every order (use with caution!)
SELECT c.c_name, o.o_orderkey
FROM customer c
CROSS JOIN orders o;
```

**‚ö†Ô∏è Warning:** CROSS JOIN creates `rows_in_A √ó rows_in_B` results. Can be huge!

---

## 5. GROUP BY & Aggregations

### Aggregate Functions
| Function | Purpose | Example |
|----------|---------|---------|
| `COUNT()` | Count rows | `COUNT(*)` or `COUNT(column)` |
| `SUM()` | Total of values | `SUM(revenue)` |
| `AVG()` | Average of values | `AVG(price)` |
| `MIN()` | Minimum value | `MIN(date)` |
| `MAX()` | Maximum value | `MAX(amount)` |

### Basic GROUP BY
```sql
-- Count orders by priority
SELECT
    o_orderpriority,
    COUNT(*) AS num_orders
FROM orders
GROUP BY o_orderpriority;
```

### Multiple Aggregations
```sql
-- Summary statistics by nation
SELECT
    c_nationkey,
    COUNT(*) AS customer_count,
    AVG(c_acctbal) AS avg_balance,
    MIN(c_acctbal) AS min_balance,
    MAX(c_acctbal) AS max_balance
FROM customer
GROUP BY c_nationkey;
```

### GROUP BY with JOIN
```sql
-- Customer order counts
SELECT
    c.c_name,
    COUNT(o.o_orderkey) AS order_count,
    SUM(o.o_totalprice) AS total_spent
FROM customer c
LEFT JOIN orders o ON c.c_custkey = o.o_custkey
GROUP BY c.c_name;
```

---

## 6. HAVING Clause - Filter Aggregated Results

### WHERE vs HAVING
| Clause | When It Filters | Use Case |
|--------|----------------|----------|
| `WHERE` | **Before** aggregation | Filter individual rows |
| `HAVING` | **After** aggregation | Filter grouped results |

### Syntax Rule
`HAVING` must come **after** the `GROUP BY` clause.

```sql
-- Query execution order:
-- 1. FROM - Get data from table
-- 2. WHERE - Filter individual rows
-- 3. GROUP BY - Group rows
-- 4. HAVING - Filter groups
-- 5. SELECT - Choose columns to display
-- 6. ORDER BY - Sort results
```

### Basic HAVING Example
```sql
-- Only show order priorities with more than 3 orders
SELECT
  o_orderpriority,
  COUNT(*) AS num_orders
FROM
  orders
GROUP BY
  o_orderpriority
HAVING
  COUNT(*) > 3;
```

### Combining WHERE and HAVING
```sql
-- Filter rows first (WHERE), then filter groups (HAVING)
SELECT
  c_nationkey,
  AVG(c_acctbal) AS avg_balance,
  COUNT(*) AS customer_count
FROM
  customer
WHERE
  c_acctbal > 0  -- Filter: only customers with positive balance
GROUP BY
  c_nationkey
HAVING
  COUNT(*) >= 10;  -- Filter: only nations with 10+ customers
```

### Multiple Conditions in HAVING
```sql
-- Complex filtering on aggregated results
SELECT
  c_nationkey,
  COUNT(*) AS customer_count,
  AVG(c_acctbal) AS avg_balance,
  SUM(c_acctbal) AS total_balance
FROM customer
GROUP BY c_nationkey
HAVING
  COUNT(*) > 100
  AND AVG(c_acctbal) > 4000
  AND SUM(c_acctbal) > 500000;
```

**Key Insight:** Use WHERE to reduce data early (better performance), then use HAVING to filter the aggregated results.

---

## üìä Common Patterns

### Finding Top N Records
```sql
-- Top 10 customers by account balance
SELECT c_name, c_acctbal
FROM customer
ORDER BY c_acctbal DESC
LIMIT 10;
```

### Filtering with Multiple Conditions
```sql
-- High-value customers from specific nations
SELECT c_name, c_nationkey, c_acctbal
FROM customer
WHERE c_nationkey IN (1, 5, 10)
  AND c_acctbal > 5000
ORDER BY c_acctbal DESC;
```

### Summary with Filtering (Using HAVING)
```sql
-- Nations with average balance over $4000
SELECT
    c_nationkey,
    COUNT(*) AS customer_count,
    AVG(c_acctbal) AS avg_balance
FROM customer
GROUP BY c_nationkey
HAVING AVG(c_acctbal) > 4000;  -- Filter aggregated results
```

---

## üéØ Best Practices

1. **Use table aliases** for readability (especially with JOINs)
   ```sql
   SELECT c.c_name, o.o_orderdate
   FROM customer c
   JOIN orders o ON c.c_custkey = o.o_custkey;
   ```

2. **Specify column names** instead of `SELECT *` in production
   - Improves performance
   - Makes queries self-documenting
   - Prevents issues when table schema changes

3. **Use appropriate JOIN types**
   - INNER JOIN: When you only want matching records
   - LEFT JOIN: When you want all records from the primary table
   - CROSS JOIN: Rarely needed; be very careful!

4. **Filter early with WHERE** before aggregating
   ```sql
   -- Good: Filter before aggregation
   SELECT c_nationkey, COUNT(*)
   FROM customer
   WHERE c_acctbal > 1000
   GROUP BY c_nationkey;
   ```

5. **Use meaningful aliases** for calculated columns
   ```sql
   SELECT COUNT(*) AS total_customers  -- Not just COUNT(*)
   ```

---

## üîç Quick Troubleshooting

| Issue | Solution |
|-------|----------|
| "Table not found" | Use full path: `schema.table` or `USE schema` |
| Too many results | Add `LIMIT` clause |
| Need to filter aggregations | Use `HAVING` clause after `GROUP BY` |
| Cartesian product (huge results) | Check your JOIN conditions! |
| Column ambiguous | Use table aliases: `table.column` |
| "Column must appear in GROUP BY" | Either add column to GROUP BY or use it in aggregate function |

---

## 7. CASE Statements - Conditional Logic

**Core Concept:** Implement IF/ELSE logic within SQL queries.

```sql
SELECT
    o_orderkey,
    o_totalprice,
    CASE
        WHEN o_totalprice > 100000 THEN 'high'
        WHEN o_totalprice BETWEEN 25000 AND 100000 THEN 'medium'
        ELSE 'low'
    END AS order_price_bucket
FROM orders;
```

**Use Cases:**
- Data bucketing/categorization
- Complex transformations
- Multiple conditional checks
- Default handling with ELSE

---

## 8. Set Operations - UNION & EXCEPT

### UNION
Combines results from multiple queries (removes duplicates).

```sql
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'
UNION
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_92%';
```

### UNION ALL
Combines results (keeps all duplicates).

```sql
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'
UNION ALL
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_92%';
```

### EXCEPT
Subtracts one query result from another.

```sql
-- Get customers with '_91' but NOT '_191'
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%_91%'
EXCEPT
SELECT c_custkey, c_name FROM customer WHERE c_name LIKE '%191%';
```

**Requirements:**
- Both queries must have same number of columns
- Column types must be compatible
- Column names from first query are used

---

## 9. Subqueries - Queries within Queries

**Core Concept:** Use a query result as a table in another query.

```sql
-- Subquery in FROM clause
SELECT
  n.n_name AS nation_name,
  s.quantity AS supplied_items
FROM nation n
LEFT JOIN (
    SELECT
        n.n_nationkey,
        SUM(l_quantity) AS quantity
    FROM lineitem l
    JOIN supplier s ON l.l_suppkey = s.s_suppkey
    JOIN nation n ON s.s_nationkey = n.n_nationkey
    GROUP BY n.n_nationkey
) s ON n.n_nationkey = s.n_nationkey;
```

**Use Cases:**
- Complex aggregations before joining
- Multi-step transformations
- Breaking complex logic into readable parts
- Filtering on aggregated data

---

## 10. Data Type Conversion & NULL Handling

### CAST - Change Data Types
```sql
-- Convert date to string
SELECT CAST(o_orderdate AS STRING) FROM orders;

-- Convert string to integer
SELECT CAST('123' AS INT);
```

### COALESCE - Handle NULLs
Returns first non-null value from a list.

```sql
-- Provide default for null phone numbers
SELECT
    c_name,
    COALESCE(c_phone, 'No phone') AS phone
FROM customer;

-- Chain multiple fallbacks
SELECT COALESCE(primary_email, backup_email, 'noemail@example.com');
```

**Production Tip:** Always use COALESCE to handle nulls gracefully!

---

## 11. Built-in Functions

### String Functions
```sql
CONCAT(str1, str2)        -- Combine strings
UPPER(str) / LOWER(str)   -- Change case
LENGTH(str)               -- String length
SUBSTRING(str, pos, len)  -- Extract substring
TRIM(str)                 -- Remove whitespace
```

### Date/Time Functions
```sql
CURRENT_DATE              -- Today's date
CURRENT_TIMESTAMP         -- Current date and time
DATE_ADD(date, days)      -- Add days to date
DATE_DIFF(date1, date2)   -- Days between dates
YEAR(date) / MONTH(date)  -- Extract components
```

### Numeric Functions
```sql
ROUND(num, decimals)      -- Round to decimal places
FLOOR(num)                -- Round down
CEIL(num) / CEILING(num)  -- Round up
ABS(num)                  -- Absolute value
```

---

## 12. Views - Reusable Queries

**Core Concept:** Save queries as virtual tables for reuse.

### Creating Views
```sql
CREATE VIEW high_value_orders AS
SELECT *
FROM orders
WHERE o_totalprice > 100000;
```

### Using Views
```sql
-- Use like any other table
SELECT * FROM high_value_orders;

-- Join with other tables
SELECT c.c_name, h.o_totalprice
FROM customer c
JOIN high_value_orders h ON c.c_custkey = h.o_custkey;
```

**Benefits:**
- Simplify complex queries
- Reusable logic across queries
- Abstract complexity from users
- Security (limit column access)

---

## üìö Next Chapter

**Chapter 2:** Advanced SQL patterns and optimization

---

## üîó Related Notes

- [[Daily Progress/2025-10-10 - SQL Basics Chapter 1 Complete!|Chapter 1 Complete - All Sections]]
- [[Daily Progress/2025-10-09 - SQL Basics (Chapter 1)|Day 1 - Sections 1.1-1.4.5]]
- [[README|Project Overview]]

---

**Last Updated:** 2025-10-10
**Chapter Status:** ‚úÖ Complete
