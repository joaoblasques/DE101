---
title: Python Basics - Data Structures & Control Flow
date: 2025-10-16
tags: [python, data-structures, control-flow, oop, functions, classes, data-engineering, foundation-basics]
status: active
learning_phase: "Foundation (Basics)"
source: https://de101.startdataengineering.com/py_basics
---

**Source:** [DE101 Chapter 4 - Python Basics](https://de101.startdataengineering.com/py_basics)
**Created:** 2025-10-16
**Last Updated:** 2025-10-16
**Status:** âœ… Complete

---

## Overview

Python is the connective tissue in data pipelines, enabling manipulation of data through standard libraries and providing tools to organize code with functions and classes. This chapter covers fundamental concepts essential for data engineering work.

---

## 4.1 Data Structures - Choose the Right Tool

### Core Concepts

**Variables** are named storage locations containing values that can be manipulated through operations.

**Operations** are computations performed on variables - arithmetic for numbers, transformations for text.

**Data Structures** organize data in different ways, each optimized for specific use cases.

---

### Python Data Structures

#### 1. List - Ordered Collections

**Definition:** A collection of elements that can be accessed by their position (index). Lists retain the order of elements.

```python
# Creating lists
customers = ["Alice", "Bob", "Carol", "Dave"]
numbers = [1, 2, 3, 4, 5]
mixed = [1, "two", 3.0, True]

# Accessing elements (0-indexed)
first_customer = customers[0]  # "Alice"
last_customer = customers[-1]  # "Dave"

# Slicing
first_two = customers[0:2]  # ["Alice", "Bob"]
last_two = customers[-2:]   # ["Carol", "Dave"]

# Common operations
customers.append("Eve")        # Add to end
customers.insert(1, "Frank")   # Insert at position
customers.remove("Bob")        # Remove by value
popped = customers.pop()       # Remove and return last item
length = len(customers)        # Get list length

# List methods
customers.sort()               # Sort in place
reversed_list = customers[::-1]  # Reverse
```

**Use Cases:**
- Storing ordered collections
- Maintaining sequence of operations
- Building queues or stacks
- When you need index-based access

**Key Characteristics:**
- Ordered âœ…
- Mutable (can change) âœ…
- Allows duplicates âœ…
- Syntax: `[item1, item2, item3]`

---

#### 2. Dictionary - Key-Value Pairs

**Definition:** A collection of key-value pairs where each key is mapped to a value using a hash function. Provides fast data retrieval based on keys.

```python
# Creating dictionaries
customer = {
    "id": 101,
    "name": "Alice Johnson",
    "email": "alice@example.com",
    "balance": 5420.50
}

# Accessing values
customer_name = customer["name"]           # Direct access
customer_phone = customer.get("phone")     # Returns None if not found
customer_phone = customer.get("phone", "N/A")  # Default value

# Adding/updating
customer["phone"] = "555-0123"     # Add new key
customer["balance"] += 100         # Update existing

# Removing
del customer["email"]              # Remove key-value pair
phone = customer.pop("phone")      # Remove and return value

# Dictionary methods
keys = customer.keys()             # All keys
values = customer.values()         # All values
items = customer.items()           # Key-value pairs

# Check existence
has_email = "email" in customer    # False (we deleted it)

# Merging dictionaries (Python 3.9+)
defaults = {"status": "active", "tier": "standard"}
customer_with_defaults = defaults | customer
```

**Use Cases:**
- Storing structured records (like database rows)
- Configuration settings
- Caching computed values
- Counting occurrences (frequency maps)
- Lookup tables

**Key Characteristics:**
- Unordered (pre-Python 3.7), Ordered (Python 3.7+) âœ…
- Mutable âœ…
- Keys must be unique âœ…
- Fast lookups O(1) âœ…
- Syntax: `{key1: value1, key2: value2}`

---

#### 3. Set - Unique Elements

**Definition:** A collection of unique elements that automatically eliminates duplicates.

```python
# Creating sets
unique_ids = {101, 102, 103, 104}
from_list = set([1, 2, 2, 3, 3, 3])  # {1, 2, 3}

# Adding elements
unique_ids.add(105)
unique_ids.add(101)  # No effect - already exists

# Removing elements
unique_ids.remove(102)      # Raises error if not found
unique_ids.discard(999)     # No error if not found

# Set operations
set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}

union = set_a | set_b              # {1, 2, 3, 4, 5, 6}
intersection = set_a & set_b       # {3, 4}
difference = set_a - set_b         # {1, 2}
symmetric_diff = set_a ^ set_b     # {1, 2, 5, 6}

# Membership testing (very fast)
is_member = 3 in unique_ids
```

**Use Cases:**
- Removing duplicates from collections
- Membership testing
- Finding unique values
- Set operations (union, intersection, difference)
- Deduplication in data pipelines

**Key Characteristics:**
- Unordered âœ…
- Mutable âœ…
- No duplicates âœ…
- Fast membership testing O(1) âœ…
- Syntax: `{item1, item2, item3}`

---

#### 4. Tuple - Immutable Ordered Collections

**Definition:** A collection of immutable (non-changeable) elements that retains order once created.

```python
# Creating tuples
coordinates = (40.7128, -74.0060)
single_item = (42,)  # Note the comma!
from_list = tuple([1, 2, 3])

# Accessing (same as lists)
latitude = coordinates[0]
longitude = coordinates[1]

# Tuple unpacking
lat, lon = coordinates
x, y, z = (10, 20, 30)

# Cannot modify!
# coordinates[0] = 50  # This raises TypeError

# Tuples as dictionary keys (lists can't do this)
locations = {
    (40.7128, -74.0060): "New York",
    (51.5074, -0.1278): "London"
}

# Named tuples for clarity
from collections import namedtuple
Customer = namedtuple('Customer', ['id', 'name', 'email'])
customer = Customer(101, "Alice", "alice@example.com")
print(customer.name)  # More readable than customer[1]
```

**Use Cases:**
- Returning multiple values from functions
- Dictionary keys (when you need composite keys)
- Data that shouldn't change
- Coordinate pairs
- Database records (immutable rows)

**Key Characteristics:**
- Ordered âœ…
- Immutable (cannot change) âœ…
- Allows duplicates âœ…
- Faster than lists âœ…
- Syntax: `(item1, item2, item3)`

---

### Data Structure Comparison

| Structure | Ordered | Mutable | Duplicates | Syntax | Primary Use Case |
|-----------|---------|---------|------------|--------|------------------|
| **List** | âœ… | âœ… | âœ… | `[...]` | Ordered collections, sequences |
| **Dictionary** | âœ…* | âœ… | Keys: âŒ Values: âœ… | `{k:v}` | Key-value lookups, records |
| **Set** | âŒ | âœ… | âŒ | `{...}` | Unique items, set operations |
| **Tuple** | âœ… | âŒ | âœ… | `(...)` | Immutable data, multiple returns |

*Ordered as of Python 3.7+

---

### Choosing the Right Data Structure

**Use a List when:**
- Order matters
- You need index-based access
- Duplicates are allowed/expected
- You'll modify the collection

**Use a Dictionary when:**
- You need key-based lookups
- Storing structured records
- Fast access to values by identifier
- Representing JSON-like data

**Use a Set when:**
- You need unique elements only
- Performing set operations (union, intersection)
- Fast membership testing
- Removing duplicates

**Use a Tuple when:**
- Data should not change
- Returning multiple values from functions
- Using as dictionary keys
- Memory efficiency is important

---

## 4.2 Control Flow - Loops and Comprehensions

### Loop Fundamentals

**Loops** are code blocks that repeat multiple times, enabling data processing at scale.

---

### For Loops - Iteration Patterns

#### 1. Index-Based Iteration

```python
customers = ["Alice", "Bob", "Carol"]

# Using range and len
for i in range(len(customers)):
    print(f"Customer {i}: {customers[i]}")

# Output:
# Customer 0: Alice
# Customer 1: Bob
# Customer 2: Carol
```

**Use when:** You need the index position for calculations or modifications.

---

#### 2. Direct Element Iteration

```python
customers = ["Alice", "Bob", "Carol"]

# Iterate directly over elements
for customer in customers:
    print(f"Hello, {customer}!")

# Output:
# Hello, Alice!
# Hello, Bob!
# Hello, Carol!
```

**Use when:** You only need the element values, not positions.

**Best Practice:** Prefer this over index-based iteration when you don't need the index.

---

#### 3. Enumerated Iteration

```python
customers = ["Alice", "Bob", "Carol"]

# Get both index and element
for index, customer in enumerate(customers):
    print(f"{index + 1}. {customer}")

# Output:
# 1. Alice
# 2. Bob
# 3. Carol

# Start enumeration at different number
for num, customer in enumerate(customers, start=1):
    print(f"{num}. {customer}")
```

**Use when:** You need both the index and the element value.

---

#### 4. Dictionary Iteration

```python
customer = {
    "id": 101,
    "name": "Alice",
    "balance": 5420.50
}

# Iterate over keys (default)
for key in customer:
    print(key)

# Iterate over values
for value in customer.values():
    print(value)

# Iterate over key-value pairs
for key, value in customer.items():
    print(f"{key}: {value}")

# Output:
# id: 101
# name: Alice
# balance: 5420.50
```

---

#### 5. Nested Loops

```python
departments = ["Sales", "Engineering", "Marketing"]
employees = ["Alice", "Bob", "Carol"]

for dept in departments:
    for emp in employees:
        print(f"{emp} - {dept}")

# Creates all combinations:
# Alice - Sales
# Alice - Engineering
# Alice - Marketing
# Bob - Sales
# ... etc
```

**Use when:** Processing multi-dimensional data or creating combinations.

---

### List Comprehension - Concise Loops

**Definition:** A shorthand way of writing loops for creating new lists. Enables concise code for simple transformations.

#### Basic Syntax

```python
# Traditional loop
squares = []
for x in range(10):
    squares.append(x ** 2)

# List comprehension (one line!)
squares = [x ** 2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

---

#### With Conditions (Filtering)

```python
# Get even numbers
evens = [x for x in range(20) if x % 2 == 0]
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# Filter and transform
# Get squares of even numbers
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]

# String operations
names = ["alice", "bob", "carol"]
upper_names = [name.upper() for name in names]
# ["ALICE", "BOB", "CAROL"]
```

---

#### Nested List Comprehension

```python
# Create 3x3 matrix
matrix = [[i * j for j in range(3)] for i in range(3)]
# [[0, 0, 0], [0, 1, 2], [0, 2, 4]]

# Flatten nested list
nested = [[1, 2], [3, 4], [5, 6]]
flat = [item for sublist in nested for item in sublist]
# [1, 2, 3, 4, 5, 6]
```

---

#### If-Else in Comprehension

```python
# Conditional transformation
numbers = [1, 2, 3, 4, 5]
labels = ["even" if x % 2 == 0 else "odd" for x in numbers]
# ["odd", "even", "odd", "even", "odd"]
```

---

### Dictionary Comprehension

```python
# Create dictionary from lists
keys = ["a", "b", "c"]
values = [1, 2, 3]
dict_comp = {k: v for k, v in zip(keys, values)}
# {"a": 1, "b": 2, "c": 3}

# Transform dictionary
prices = {"apple": 1.0, "banana": 0.5, "orange": 0.75}
discounted = {item: price * 0.9 for item, price in prices.items()}
# {"apple": 0.9, "banana": 0.45, "orange": 0.675}

# Filter dictionary
expensive = {item: price for item, price in prices.items() if price > 0.6}
# {"apple": 1.0, "orange": 0.75}
```

---

### Set Comprehension

```python
# Create set of unique values
numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
unique_squares = {x ** 2 for x in numbers}
# {1, 4, 9, 16}
```

---

### When to Use Comprehension vs Traditional Loops

**Use Comprehension when:**
- Creating a new collection from an existing one
- Logic is simple (1-2 lines)
- Readability is maintained
- Primarily transformation or filtering

**Use Traditional Loop when:**
- Logic is complex (multiple operations)
- Need multiple statements per iteration
- Need to break/continue with complex conditions
- Side effects (printing, writing to files, etc.)

```python
# Good use of comprehension
prices = [item["price"] * 1.1 for item in products if item["in_stock"]]

# Bad use of comprehension (too complex)
# Better as traditional loop:
for item in products:
    if item["in_stock"]:
        price = item["price"] * 1.1
        tax = price * 0.08
        total = price + tax
        item["total_price"] = total
```

---

## 4.3 Functions and Classes - Code Organization

### Functions - Reusable Code Blocks

**Definition:** A block of code that performs a specific task, can be reused multiple times, and helps organize logic.

---

#### Basic Function Syntax

```python
# Simple function
def greet():
    print("Hello!")

# Call the function
greet()  # Output: Hello!
```

---

#### Functions with Parameters

```python
def greet_person(name):
    print(f"Hello, {name}!")

greet_person("Alice")  # Hello, Alice!
greet_person("Bob")    # Hello, Bob!

# Multiple parameters
def calculate_total(price, quantity, tax_rate):
    subtotal = price * quantity
    tax = subtotal * tax_rate
    total = subtotal + tax
    return total

total = calculate_total(10.99, 3, 0.08)
print(f"Total: ${total:.2f}")  # Total: $32.97
```

---

#### Return Values

```python
# Single return value
def square(x):
    return x ** 2

result = square(5)  # 25

# Multiple return values (as tuple)
def get_customer_info(customer_id):
    # Simulated database lookup
    name = "Alice Johnson"
    email = "alice@example.com"
    balance = 5420.50
    return name, email, balance

# Unpack returned values
name, email, balance = get_customer_info(101)
```

---

#### Default Parameters

```python
def create_user(username, role="user", active=True):
    return {
        "username": username,
        "role": role,
        "active": active
    }

# Use defaults
user1 = create_user("alice")
# {"username": "alice", "role": "user", "active": True}

# Override defaults
user2 = create_user("bob", role="admin", active=False)
# {"username": "bob", "role": "admin", "active": False}
```

---

#### Keyword Arguments

```python
def send_email(to, subject, body, cc=None, bcc=None):
    print(f"Sending email to {to}")
    print(f"Subject: {subject}")
    print(f"Body: {body}")
    if cc:
        print(f"CC: {cc}")

# Positional arguments
send_email("alice@example.com", "Welcome", "Hello Alice!")

# Named arguments (order doesn't matter)
send_email(
    subject="Meeting",
    to="bob@example.com",
    body="See you at 3pm",
    cc="team@example.com"
)
```

---

#### *args and **kwargs

```python
# *args - variable number of positional arguments
def sum_all(*numbers):
    return sum(numbers)

print(sum_all(1, 2, 3))        # 6
print(sum_all(1, 2, 3, 4, 5))  # 15

# **kwargs - variable number of keyword arguments
def create_record(**fields):
    return fields

record = create_record(id=101, name="Alice", age=30)
# {"id": 101, "name": "Alice", "age": 30}

# Combine all parameter types
def complex_func(required, *args, default="value", **kwargs):
    print(f"Required: {required}")
    print(f"Args: {args}")
    print(f"Default: {default}")
    print(f"Kwargs: {kwargs}")

complex_func(1, 2, 3, default="custom", extra="data")
```

---

#### Lambda Functions (Anonymous Functions)

```python
# Regular function
def square(x):
    return x ** 2

# Lambda equivalent
square = lambda x: x ** 2

# Common use: with built-in functions
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))
# [1, 4, 9, 16, 25]

# Sorting with lambda
customers = [
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": 25},
    {"name": "Carol", "age": 35}
]
sorted_by_age = sorted(customers, key=lambda c: c["age"])
```

---

### Classes - Object-Oriented Programming

**Definition:** A blueprint for creating objects that bundle data (attributes) and functionality (methods) together.

---

#### Basic Class Structure

```python
class Customer:
    # Class attribute (shared by all instances)
    company = "Acme Corp"

    # Constructor (initializer)
    def __init__(self, customer_id, name, email):
        # Instance attributes (unique to each object)
        self.customer_id = customer_id
        self.name = name
        self.email = email
        self.balance = 0.0

    # Instance method
    def add_funds(self, amount):
        self.balance += amount
        print(f"Added ${amount}. New balance: ${self.balance}")

    # Instance method
    def get_info(self):
        return f"{self.name} ({self.email}) - Balance: ${self.balance}"

# Create instances (objects)
customer1 = Customer(101, "Alice Johnson", "alice@example.com")
customer2 = Customer(102, "Bob Smith", "bob@example.com")

# Use methods
customer1.add_funds(100)  # Added $100. New balance: $100.0
customer1.add_funds(50)   # Added $50. New balance: $150.0

# Access attributes
print(customer1.name)      # Alice Johnson
print(customer1.balance)   # 150.0
print(customer1.get_info())  # Alice Johnson (alice@example.com) - Balance: $150.0
```

---

#### Encapsulation - Private Attributes

```python
class BankAccount:
    def __init__(self, account_number, initial_balance):
        self.account_number = account_number
        self.__balance = initial_balance  # Private attribute

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

    def get_balance(self):
        return self.__balance

account = BankAccount("12345", 1000)
account.deposit(500)
print(account.get_balance())  # 1500
# print(account.__balance)  # AttributeError - can't access private attribute
```

---

#### Class Methods and Static Methods

```python
class DataProcessor:
    version = "1.0"

    def __init__(self, data):
        self.data = data

    # Instance method (needs self)
    def process(self):
        return [x * 2 for x in self.data]

    # Class method (works with class, not instance)
    @classmethod
    def from_csv(cls, filepath):
        # Read data from CSV and create instance
        data = [1, 2, 3]  # Simplified
        return cls(data)

    # Static method (doesn't need class or instance)
    @staticmethod
    def validate_data(data):
        return all(isinstance(x, (int, float)) for x in data)

# Use class method as alternative constructor
processor = DataProcessor.from_csv("data.csv")

# Use static method
is_valid = DataProcessor.validate_data([1, 2, 3])  # True
```

---

#### Inheritance - Code Reuse

```python
# Base class
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        return f"I'm {self.name}, {self.age} years old"

# Derived class
class Customer(Person):
    def __init__(self, name, age, customer_id):
        # Call parent constructor
        super().__init__(name, age)
        self.customer_id = customer_id
        self.orders = []

    def place_order(self, order):
        self.orders.append(order)

    # Override parent method
    def introduce(self):
        base_intro = super().introduce()
        return f"{base_intro}, Customer ID: {self.customer_id}"

customer = Customer("Alice", 30, 101)
print(customer.introduce())
# I'm Alice, 30 years old, Customer ID: 101
customer.place_order({"item": "laptop", "price": 999})
```

---

#### Special Methods (Magic Methods)

```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    # String representation for users
    def __str__(self):
        return f"{self.name} - ${self.price}"

    # String representation for developers
    def __repr__(self):
        return f"Product('{self.name}', {self.price})"

    # Comparison operators
    def __eq__(self, other):
        return self.price == other.price

    def __lt__(self, other):
        return self.price < other.price

    # Arithmetic operations
    def __add__(self, other):
        return self.price + other.price

laptop = Product("Laptop", 999)
mouse = Product("Mouse", 25)

print(laptop)              # Laptop - $999
print(repr(laptop))        # Product('Laptop', 999)
print(laptop + mouse)      # 1024
print(laptop > mouse)      # True
```

---

### When to Use Functions vs Classes

**Use Functions when:**
- Performing a single, well-defined task
- Logic is stateless (doesn't need to remember data)
- Simple transformations or calculations
- Utility operations

**Use Classes when:**
- Bundling related data and operations
- Need to maintain state between operations
- Building reusable components
- Modeling real-world entities

```python
# Good use of function - stateless operation
def calculate_tax(amount, rate):
    return amount * rate

# Good use of class - maintains state
class ShoppingCart:
    def __init__(self):
        self.items = []
        self.total = 0.0

    def add_item(self, item, price):
        self.items.append({"item": item, "price": price})
        self.total += price

    def get_total_with_tax(self, tax_rate):
        return self.total * (1 + tax_rate)
```

---

## ðŸŽ¯ Best Practices

### Data Structures
1. **Choose appropriately** - Match data structure to access pattern
2. **Use sets for uniqueness** - Automatic deduplication
3. **Dictionary for lookups** - O(1) access time
4. **Tuples for immutability** - Safer, faster, hashable

### Control Flow
1. **Prefer comprehensions for simple cases** - More Pythonic
2. **Use traditional loops for complex logic** - Better readability
3. **Enumerate when you need index** - Don't use `range(len())`
4. **Direct iteration when possible** - `for item in items`

### Functions
1. **Single responsibility** - One function, one purpose
2. **Descriptive names** - `calculate_total()` not `calc()`
3. **Document complex functions** - Use docstrings
4. **Default parameters** - Make functions flexible

### Classes
1. **Encapsulation** - Keep internal data private
2. **Single responsibility** - One class, one concept
3. **Inheritance for "is-a"** - Don't overuse
4. **Composition over inheritance** - Often simpler

---

## ðŸ”— Related Notes

- [[05. Python for Data Integration - Extract & Load|Next: Chapter 5 - Data Integration]]
- [[README|Project Overview]]

---

## ðŸ“š Key Takeaways

1. **Lists** for ordered collections, **dicts** for lookups, **sets** for uniqueness, **tuples** for immutability
2. **Comprehensions** make code concise but only use for simple logic
3. **Functions** organize reusable logic, **classes** bundle data with behavior
4. **Choose the right tool** - Data structure choice impacts performance and clarity
5. **Python is readable** - Prefer clarity over cleverness

---

**Last Updated:** 2025-10-16
**Chapter Status:** âœ… Complete
